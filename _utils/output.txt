
===== .\run.py =====
# run.py
import argparse
import os
import sys
import yaml
from types import SimpleNamespace
import ray
from typing import Any, Callable

sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from scripts import demo as demo_script
from scripts import train_ppo, train_acl, train_marl, watch
from scripts import test_suite as test_suite_script
from scripts import evaluate as evaluate_script
from preprocessing import convert_weight
from scripts import check_all as check_all_script
from utils.seeding import set_seed

def ray_init_and_run(func, args):
    """Initializes Ray and runs a function that requires it."""
    if not ray.is_initialized():
        print("Initializing Ray...")
        ray.init(ignore_reinit_error=True)
    
    try:
        func(args)
    finally:
        if ray.is_initialized():
            ray.shutdown()
            print("Ray has been shut down.")

def load_config(config_path: str) -> dict:
    if not os.path.exists(config_path):
        print(f"ERROR: Config not found at '{config_path}'")
        sys.exit(1)
    with open(config_path, 'r', encoding='utf-8') as f:
        return yaml.safe_load(f)

def print_header(title: str):
    width = 80
    print("\n\n" + "#"*width + f"\n##{title:^76}##\n" + "#"*width)

def run_task(func: Callable, args_namespace: SimpleNamespace, task_name: str) -> Any:
    print_header(f"START TASK: {task_name.upper()}")
    try:
        is_no_args_func = 'args_namespace' not in func.__code__.co_varnames and func.__code__.co_argcount == 0
        result = func() if is_no_args_func else func(args_namespace)
        print_header(f"FINISHED TASK: {task_name.upper()}")
        return result
    except KeyboardInterrupt:
        print(f"\nINFO: Task '{task_name}' stopped by user.")
        sys.exit(0)
    except Exception as e:
        if e.__class__.__name__ == 'UserInterrupt':
            print(f"\nINFO: Task '{task_name}' stopped by user.")
            sys.exit(0)
        print(f"\nERROR: Task '{task_name}' failed.")
        import traceback
        traceback.print_exc()
        sys.exit(1)

def run_pipeline(args: SimpleNamespace):
    config = load_config(args.config)
    watch_config = config.get('WATCH', {})
    
    default_params = {
        'render': False, 'width': args.width, 'height': args.height, 'fullscreen': args.fullscreen,
        'horizon': 3000, 'roughness': None, 'stump_height': None,
        'stump_width': None, 'obstacle_spacing': None, 'input_vector': None,
        'water_level': None, 'creepers_width': None, 'creepers_height': None,
        'creepers_spacing': None, 'check_env': False, 'shared_policy': False,
        'use_cc': False, 'seed': args.seed
    }
    
    for stage_name in ['PPO', 'ACL', 'MARL']:
        stage_config = config.get(stage_name, {})
        if not stage_config.get('enabled', False):
            continue
        
        final_config = {**default_params, **stage_config}
        stage_args = SimpleNamespace(**final_config)

        checkpoint_path = None
        if stage_name == 'PPO':
            checkpoint_path = run_task(train_ppo.main, stage_args, "PPO Training")
        elif stage_name == 'ACL':
            checkpoint_path = run_task(train_acl.main, stage_args, "ACL Training")
        elif stage_name == 'MARL':
            checkpoint_path = run_task(train_marl.main, stage_args, f"MARL Training ({stage_args.mode})")

        if watch_config.get('enabled', False) and checkpoint_path:
            if stage_name == 'MARL':
                print_header("WATCH MARL (INFO)")
                print("RLlib MARL checkpoints are complex and not directly supported by 'watch.py'.")
                print(f"Best MARL checkpoint from tuning saved at: {checkpoint_path}")
            else:
                watch_args = SimpleNamespace(
                    model_path=checkpoint_path,
                    framework='sb3', num_episodes=5,
                    env=stage_args.env, body=stage_args.body,
                    width=args.width, height=args.height, fullscreen=args.fullscreen,
                    **watch_config, **vars(stage_args)
                )
                run_task(watch.main, watch_args, f"Watch {stage_name}")

    print_header("PIPELINE COMPLETE")

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Main entry point for TeachMyAgent.", formatter_class=argparse.RawTextHelpFormatter)
    subparsers = parser.add_subparsers(dest='command', required=True, help="Available commands")

    ray_commands = ['pipeline', 'train', 'test_suite']

    pipeline_parser = subparsers.add_parser('pipeline', help="Run the full training pipeline from a YAML config file.")
    pipeline_parser.add_argument('--config', type=str, default='configs/main_pipeline.yaml', help="Path to the main pipeline configuration file.")
    pipeline_parser.add_argument('--width', type=int, help="Override window width for watching.")
    pipeline_parser.add_argument('--height', type=int, help="Override window height for watching.")
    pipeline_parser.add_argument('--fullscreen', action='store_true', help="Override fullscreen for watching.")
    pipeline_parser.add_argument('--seed', type=int, default=None, help="Global seed for reproducibility. Overrides YAML config.")
    pipeline_parser.set_defaults(func=run_pipeline)

    train_parser = subparsers.add_parser('train', help="Train a specific algorithm.")
    train_parser.add_argument('--seed', type=int, default=None, help="Global seed for reproducibility.")
    train_subparsers = train_parser.add_subparsers(dest='algorithm', required=True)
    
    ppo_parser = train_subparsers.add_parser('ppo', help="Train PPO (single-agent)."); train_ppo.add_ppo_args(ppo_parser)
    ppo_parser.set_defaults(func=lambda args: run_task(train_ppo.main, args, "PPO Training"))
    
    acl_parser = train_subparsers.add_parser('acl', help="Train with Automatic Curriculum Learning."); train_acl.add_acl_args(acl_parser)
    acl_parser.set_defaults(func=lambda args: run_task(train_acl.main, args, "ACL Training"))
    
    marl_parser = train_subparsers.add_parser('marl', help="Train MARL (multi-agent)."); train_marl.add_marl_args(marl_parser)
    marl_parser.set_defaults(func=lambda args: run_task(train_marl.main, args, "MARL Training"))

    eval_parser = subparsers.add_parser('evaluate', help="Evaluate a trained single-agent model.")
    evaluate_script.add_evaluation_args(eval_parser)
    eval_parser.add_argument('--seed', type=int, default=None, help="Global seed for reproducibility.")
    eval_parser.set_defaults(func=lambda args: run_task(evaluate_script.evaluate_agent, args, "Evaluate Model"))

    watch_parser = subparsers.add_parser('watch', help="Watch a trained single-agent model."); watch.add_watch_args(watch_parser)
    watch_parser.add_argument('--seed', type=int, default=None, help="Global seed for reproducibility.")
    watch_parser.set_defaults(func=lambda args: run_task(watch.main, args, "Watch Model"))
    
    demo_parser = subparsers.add_parser('demo', help="Run a random agent in an environment."); demo_script.add_demo_args(demo_parser)
    demo_parser.add_argument('--seed', type=int, default=None, help="Global seed for reproducibility.")
    demo_parser.set_defaults(func=lambda args: run_task(demo_script.main, args, "Environment Demo"))
    
    check_parser = subparsers.add_parser('check_envs', help="Run comprehensive checks on all environments and bodies."); check_all_script.add_check_all_args(check_parser)
    check_parser.set_defaults(func=lambda args: run_task(check_all_script.main, args, "Environment Check"))
    
    test_parser = subparsers.add_parser('test_suite', help="Run the quick, integrated project test suite.")
    test_parser.set_defaults(func=test_suite_script.main)
    
    convert_parser = subparsers.add_parser('convert_weights', help="Convert legacy TF1 weights to PyTorch.")
    convert_parser.set_defaults(func=convert_weight.convert_tf1_to_pytorch)

    args = parser.parse_args()
    
    # START CHANGE: Smart seed handling
    # Priority: Command line > YAML config > No seed
    seed = args.seed
    if args.command == 'pipeline' and seed is None:
        try:
            config = load_config(args.config)
            for stage_name in ['PPO', 'ACL', 'MARL']:
                stage_config = config.get(stage_name, {})
                if stage_config.get('enabled', False):
                    seed_from_config = stage_config.get('seed')
                    if seed_from_config is not None:
                        print(f"INFO: Using seed '{seed_from_config}' from '{stage_name}' configuration in '{args.config}'.")
                        seed = seed_from_config
                        break # Use the first one found
        except Exception as e:
            print(f"WARNING: Could not load config to check for seed. Reason: {e}")
    
    if seed is not None:
        print(f"INFO: Setting global seed to {seed}.")
        set_seed(seed)
        # Ensure the args object carries the definitive seed value
        args.seed = seed
    # END CHANGE
    
    try:
        if args.command in ray_commands:
            ray_init_and_run(args.func, args)
        else:
            if hasattr(args, 'func'):
                is_no_args_func = 'args' not in args.func.__code__.co_varnames and args.func.__code__.co_argcount == 0
                if is_no_args_func:
                     run_task(args.func, None, args.command.upper())
                else:
                     run_task(args.func, args, args.command.upper())
            else:
                parser.print_help()
    finally:
        if ray.is_initialized():
            ray.shutdown()
            print("Final Ray shutdown completed.")

===== .\configs\main_pipeline.yaml =====
WATCH:
  enabled: false 
  fast_forward: true
  auto_skip_stuck: true

PPO:
  enabled: false
  run_id: "ppo_reach_the_end_run"
  env: "parkour"
  body: "classic_bipedal"
  
  total_timesteps: 2000000 
  save_freq: 200000
  n_envs: 16
  horizon: 5000

  ppo_config:
    gamma: 0.999 
    n_steps: 4096 
    ent_coef: 0.01 
    learning_rate_schedule:
      type: "linear"
      initial_value: 3e-4
    vf_coef: 0.5
    max_grad_norm: 0.5
    n_epochs: 10
    batch_size: 64
    gae_lambda: 0.95
    clip_range: 0.2 

ACL:
  enabled: true
  run_id: "acl_climbing_run_final"
  env: "parkour"
  body: "climbing_profile_chimpanzee"
  student_steps_per_stage: 200000
  total_stages: 40    
  eval_episodes: 10
  mastery_threshold: 0.0
  difficulty_increment: 0.025
  horizon: 5000
  n_envs: 16
  seed: 42
  
  creepers_width: 0.5
  creepers_height: 2.0
  creepers_spacing: 0.8

  ppo_config:
    gamma: 0.999
    n_steps: 4096
    ent_coef: 0.025
    learning_rate_schedule:
      type: "linear"
      initial_value: 1e-4
    vf_coef: 0.5
    max_grad_norm: 0.5
    n_epochs: 20
    batch_size: 128
    gae_lambda: 0.95
    clip_range: 0.2

MARL:
  enabled: false
  run_id: "marl_reach_the_end_run"
  mode: "interactive"
  n_agents: 2
  body: "classic_bipedal"
  num_workers: 12 
  num_gpus: 2
  horizon: 5000
  
  reward_type: "shared"

  shared_policy: true
  use_cc: true

  use_tune: false
  iterations: 150
  
  ppo_config:
    training:
      gamma: 0.999
      lr: 0.0003
      lambda_: 0.95
      clip_param: 0.2
      entropy_coeff: 0.01
      train_batch_size: 12288
    
    model:
      fcnet_hiddens: [512, 512]
      fcnet_activation: "tanh"
      
    env_runners:
      rollout_fragment_length: 1024

===== .\output\marl\test_suite_marl\rllib_checkpoint.json =====
{"class_and_ctor_args_file": "class_and_ctor_args.pkl", "state_file": "algorithm_state", "ray_version": "2.50.1", "ray_commit": "7cf6817996f5304b5c808453a997fc1570dcde25", "checkpoint_version": "2.1"}

===== .\output\marl\test_suite_marl\env_runner\metadata.json =====
{"class_and_ctor_args_file": "class_and_ctor_args.pkl", "state_file": "state", "ray_version": "2.50.1", "ray_commit": "7cf6817996f5304b5c808453a997fc1570dcde25", "checkpoint_version": "2.1"}

===== .\output\marl\test_suite_marl\env_runner\env_to_module_connector\metadata.json =====
{"class_and_ctor_args_file": "class_and_ctor_args.pkl", "state_file": "state", "ray_version": "2.50.1", "ray_commit": "7cf6817996f5304b5c808453a997fc1570dcde25", "checkpoint_version": "2.1"}

===== .\output\marl\test_suite_marl\env_runner\module_to_env_connector\metadata.json =====
{"class_and_ctor_args_file": "class_and_ctor_args.pkl", "state_file": "state", "ray_version": "2.50.1", "ray_commit": "7cf6817996f5304b5c808453a997fc1570dcde25", "checkpoint_version": "2.1"}

===== .\output\marl\test_suite_marl\learner_group\metadata.json =====
{"class_and_ctor_args_file": "class_and_ctor_args.pkl", "state_file": "state", "ray_version": "2.50.1", "ray_commit": "7cf6817996f5304b5c808453a997fc1570dcde25", "checkpoint_version": "2.1"}

===== .\output\marl\test_suite_marl\learner_group\learner\metadata.json =====
{"class_and_ctor_args_file": "class_and_ctor_args.pkl", "state_file": "state", "ray_version": "2.50.1", "ray_commit": "7cf6817996f5304b5c808453a997fc1570dcde25", "checkpoint_version": "2.1"}

===== .\output\marl\test_suite_marl\learner_group\learner\rl_module\metadata.json =====
{"class_and_ctor_args_file": "class_and_ctor_args.pkl", "state_file": "module_state", "ray_version": "2.50.1", "ray_commit": "7cf6817996f5304b5c808453a997fc1570dcde25", "checkpoint_version": "2.1"}

===== .\output\marl\test_suite_marl\learner_group\learner\rl_module\shared_policy\metadata.json =====
{"class_and_ctor_args_file": "class_and_ctor_args.pkl", "state_file": "module_state", "ray_version": "2.50.1", "ray_commit": "7cf6817996f5304b5c808453a997fc1570dcde25", "checkpoint_version": "2.1"}

===== .\preprocessing\convert_weight.py =====
import tensorflow as tf
import torch
import numpy as np
import os

# Suppress unnecessary TensorFlow 1.x warnings
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'
if tf.__version__.startswith('1.'):
    tf.logging.set_verbosity(tf.logging.ERROR)

def convert_tf1_to_pytorch(project_root=None):
    """
    Convert TensorFlow 1.x checkpoint weights to a PyTorch state_dict.
    """
    if project_root is None:
        project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

    TF_WEIGHTS_DIR = os.path.join(project_root, 'TeachMyAgent', 'environments', 'envs', 'PCGAgents', 'CPPN', 'weights', 'same_ground_ceiling_cppn')
    PYTORCH_WEIGHTS_PATH = os.path.join(project_root, 'TeachMyAgent', 'environments', 'envs', 'PCGAgents', 'CPPN', 'weights', 'same_ground_ceiling_cppn_pytorch.pt')

    # Skip conversion if PyTorch weights already exist
    if os.path.exists(PYTORCH_WEIGHTS_PATH):
        print(f"PyTorch weights already exist at: {PYTORCH_WEIGHTS_PATH}. Skipping conversion.")
        return
    
    TF_VAR_TO_PYTORCH_NAME = {
        'Variable':   '0.weight', 
        'Variable_1': '2.weight', 
        'Variable_2': '4.weight',
        'Variable_3': '6.weight', 
        'Variable_4': '8.weight',
    }

    print("Starting weight conversion...")
    checkpoint_path = tf.train.latest_checkpoint(TF_WEIGHTS_DIR)
    if not checkpoint_path:
        print(f"ERROR: No checkpoint found in {TF_WEIGHTS_DIR}.")
        return

    try:
        reader = tf.train.NewCheckpointReader(checkpoint_path)
        pytorch_state_dict = {}
        
        print("\n--- Variables found in checkpoint ---")
        for key in sorted(reader.get_variable_to_shape_map().keys()):
            print(f"  Name: {key}")
        print("------------------------------------------")
        
        for tf_name, pt_name in TF_VAR_TO_PYTORCH_NAME.items():
            if reader.has_tensor(tf_name):
                weight_numpy = reader.get_tensor(tf_name)
                # Transpose to match PyTorch Linear (out_features, in_features)
                pytorch_state_dict[pt_name] = torch.from_numpy(weight_numpy).float().T
            else:
                print(f"ERROR: Variable '{tf_name}' not found in checkpoint!")
                return
        print("\nWeight extraction and mapping successful.")

    except Exception as e:
        print(f"ERROR while reading checkpoint: {e}")
        return

    torch.save(pytorch_state_dict, PYTORCH_WEIGHTS_PATH)
    print(f"Converted weights saved to: {PYTORCH_WEIGHTS_PATH}")

if __name__ == '__main__':
    if not tf.__version__.startswith('1.'):
        print("Error: TensorFlow 1.x required to run this conversion script directly.")
        exit()
    convert_tf1_to_pytorch()


===== .\preprocessing\__init__.py =====


===== .\scripts\calculate_map_length.py =====
# scripts/calculate_map_length.py
import argparse
import sys
import numpy as np

def print_header(title):
    """Prints a standardized header."""
    width = 80
    print("\n" + "#"*width + f"\n##{title:^76}##\n" + "#"*width)

def add_calculate_length_args(parser):
    """Adds CLI arguments for the map length calculation."""
    parser.add_argument('--env', type=str, default='parkour', choices=['parkour', 'stump'],
                        help="Select the environment to calculate the length for.")
    return parser

def main(args):
    """
    Calculates the map length based on predefined constants in the environment code.
    This provides an instant estimate without running a simulation.
    """
    print_header(f"CALCULATING MAP LENGTH FOR '{args.env.upper()}'")

    # Import constants directly from the environment files
    if args.env == 'parkour':
        from TeachMyAgent.environments.envs.parametric_continuous_parkour import (
            SCALE, TERRAIN_STEP, TERRAIN_LENGTH, TERRAIN_END, INITIAL_TERRAIN_STARTPAD
        )
    elif args.env == 'stump':
        from TeachMyAgent.environments.envs.parametric_continuous_stump_tracks import (
            SCALE, TERRAIN_STEP, TERRAIN_LENGTH, TERRAIN_END, INITIAL_TERRAIN_STARTPAD
        )
    else:
        print(f"ERROR: Environment '{args.env}' not supported by this script.")
        sys.exit(1)

    # The condition to finish an episode is based on the agent's x-position
    finish_line_x = (TERRAIN_LENGTH + INITIAL_TERRAIN_STARTPAD - TERRAIN_END) * TERRAIN_STEP

    # Estimate required steps. This is a rough heuristic.
    # A bipedal walker's speed varies greatly. We can assume an average of ~0.2 units of distance per step.
    # So, steps = distance / speed_per_step
    estimated_steps = int(finish_line_x / 0.2)

    print("Environment Constants:")
    print(f"  - TERRAIN_LENGTH: {TERRAIN_LENGTH} (steps)")
    print(f"  - TERRAIN_STEP: {TERRAIN_STEP:.4f} (meters per step)")
    print(f"  - TERRAIN_STARTPAD: {INITIAL_TERRAIN_STARTPAD} (steps)")
    print(f"  - TERRAIN_END: {TERRAIN_END} (steps before actual end)")
    print("-" * 80)
    print(f"CALCULATION:")
    print(f"  - Finish Line X-Coordinate = ({TERRAIN_LENGTH} + {INITIAL_TERRAIN_STARTPAD} - {TERRAIN_END}) * {TERRAIN_STEP:.4f}")
    print(f"  - Finish Line at approx. x = {finish_line_x:.2f} meters")
    print("-" * 80)
    print("RECOMMENDATION:")
    print(f"An agent needs to travel approximately {finish_line_x:.2f} meters to finish the map.")
    print(f"A rough estimate of steps required would be around: {estimated_steps} steps.")
    print("\n=> Recommended 'horizon' value in your YAML file: {}".format(int(estimated_steps * 1.2)))
    print("(This includes a 20% buffer. Use 'check_length' command for a more accurate simulation-based value).")


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Instantly calculate the length of a procedurally generated map.")
    parser = add_calculate_length_args(parser)
    args = parser.parse_args()
    main(args)

===== .\scripts\check_all.py =====
# scripts/check_all.py
import argparse
import os
import sys
import subprocess
from types import SimpleNamespace

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from utils.shared_args import available_bodies

def print_header(text, char='='):
    width = 80
    print("\n" + char * width)
    print(f"{text:^{width}}")
    print(char * width)

def print_success(text):
    print(f"‚úÖ SUCCESS: {text}")

def print_failure(text):
    print(f"‚ùå FAILURE: {text}")

def add_check_all_args(parser):
    parser.add_argument('--env', type=str, default='all',
                        choices=['all', 'stump', 'parkour', 'marl-cooperative', 'marl-interactive'],
                        help="Environment type to test.")
    parser.add_argument('--body', type=str, default='all',
                        help="Body type to test. Use 'all' to test all available ones.")
    parser.add_argument('--steps', type=int, default=100,
                        help="Number of random steps to run in each test.")
    parser.add_argument('--delay', type=float, default=0.02,
                        help="Pause duration (seconds) between steps for visualization.")
    return parser

def main(args):
    all_bodies = available_bodies()
    bodies_to_test = all_bodies if args.body == 'all' else [args.body]

    if args.body != 'all' and args.body not in all_bodies:
        print(f"ERROR: Body '{args.body}' not found. Available bodies: {all_bodies}")
        sys.exit(1)

    all_envs = ['stump', 'parkour', 'marl-cooperative', 'marl-interactive']
    envs_to_test = all_envs if args.env == 'all' else [args.env]
        
    test_plan = [(env_key, body_name) for env_key in envs_to_test for body_name in bodies_to_test]
    
    failures = 0
    total_tests = len(test_plan)
    
    print_header(f"STARTING FULL TEST: {total_tests} TESTS")
    
    single_test_script_path = os.path.join(os.path.dirname(__file__), 'run_single_test.py')

    for i, (env_key, body_name) in enumerate(test_plan):
        test_name = f"Env: '{env_key}', Body: '{body_name}'"
        print(f"\n--- Test [{i+1}/{total_tests}]: {test_name} ---")

        command = [
            sys.executable,
            single_test_script_path,
            '--env', env_key,
            '--body', body_name,
            '--steps', str(args.steps),
            '--delay', str(args.delay)
        ]

        child_env = os.environ.copy()
        child_env['PYTHONIOENCODING'] = 'utf-8'
        
        result = subprocess.run(
            command, 
            capture_output=True, 
            text=True, 
            encoding='utf-8',
            errors='replace',
            env=child_env
        )

        if result.returncode == 0:
            print_success(test_name)
            if result.stdout:
                print(result.stdout.strip())
        else:
            print_failure(test_name)
            failures += 1
            print("------- ERROR FROM CHILD PROCESS -------")
            print(result.stdout)
            print(result.stderr)
            print("---------------------------------------")
            
    print_header("TEST SUMMARY")
    if failures == 0:
        print(f"üéâ All {total_tests} tests passed successfully! üéâ")
    else:
        print(f"üî• {failures} out of {total_tests} tests failed. Please check logs above.")
        sys.exit(1)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Run full environment and agent tests.")
    parser = add_check_all_args(parser)
    args = parser.parse_args()
    main(args)


===== .\scripts\check_map_length.py =====
# scripts/check_map_length.py
import argparse
import os
import sys
import time
import numpy as np
from types import SimpleNamespace

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from run import load_config
from utils.env_utils import build_and_setup_env, collect_env_params
from stable_baselines3 import PPO

def print_header(title):
    """Prints a standardized header."""
    width = 80
    print("\n" + "#"*width + f"\n##{title:^76}##\n" + "#"*width)

def add_check_length_args(parser):
    """Adds CLI arguments for the map length check."""
    parser.add_argument('--config', type=str, default='configs/main_pipeline.yaml', help="Path to the main pipeline configuration file.")
    parser.add_argument('--stage', type=str, required=True, choices=['PPO', 'ACL', 'MARL'], help="Which stage configuration to use for the test (e.g., PPO).")
    parser.add_argument('--model_path', type=str, default=None, help="(Optional) Path to a trained SB3 model (.zip) to run instead of the heuristic.")
    parser.add_argument('--timeout', type=int, default=10000, help="Maximum number of steps for this check before stopping.")
    parser.add_argument('--no-render', action='store_true', help="Run without rendering the environment.")
    parser.add_argument('--fast', action='store_true', help="Run rendering as fast as possible without delay.")
    return parser

def main(args):
    """
    Runs an intelligent exploratory agent to estimate the number of steps 
    required to finish a map based on a pipeline configuration.
    """
    print_header(f"CHECKING MAP LENGTH FOR STAGE: {args.stage}")

    # --- Configuration Loading ---
    config = load_config(args.config)
    stage_config = config.get(args.stage)

    if not stage_config:
        print(f"ERROR: Stage '{args.stage}' not found in '{args.config}'")
        sys.exit(1)
        
    stage_args = SimpleNamespace(**stage_config)
    
    stage_args.horizon = args.timeout 
    stage_args.render = not args.no_render
    stage_args.width = 1280
    stage_args.height = 720
    stage_args.fullscreen = False

    print("Building environment with parameters from stage '{}'".format(args.stage))
    user_params = collect_env_params(stage_args.env, stage_args)
    env = build_and_setup_env(stage_args.env, stage_args.body, user_params, 
                              render_mode="human" if stage_args.render else None, 
                              args=stage_args)

    # --- Agent Setup ---
    model = None
    if args.model_path:
        if os.path.exists(args.model_path):
            print(f"\nLoading model from: {args.model_path}")
            model = PPO.load(args.model_path)
        else:
            print(f"WARNING: Model not found at '{args.model_path}'. Using smart heuristic agent.")

    if model is None:
        print("\nUsing a smart heuristic agent to explore the map.")
        action_size = env.action_space.shape[0]
        
        # Define multiple strategies to move forward for classic_bipedal
        CANDIDATE_ACTIONS = [
            np.array([0.2, 0.1, -0.2, 0.1]),   # Strategy 1: Standard walk
            np.array([0.3, 0.0, -0.1, 0.0]),   # Strategy 2: Leaning forward
            np.array([-0.1, 0.3, 0.1, 0.3]),  # Strategy 3: High knee walk
            lambda: env.action_space.sample() # Strategy 4: Random action to get unstuck
        ]
        if action_size < 4: # Fallback for other bodies
            CANDIDATE_ACTIONS = [lambda: env.action_space.sample()]

    # --- Simulation Loop ---
    obs, info = env.reset()
    
    step = 0
    total_reward = 0
    done = False
    
    # Variables for smart heuristic
    current_action_index = 0
    last_check_step = 0
    last_check_pos_x = 0
    max_x_pos = -float('inf')
    steps_at_max_x = 0
    
    # Constants for stuck detection
    STUCK_CHECK_INTERVAL = 150
    STUCK_PROGRESS_THRESHOLD = 0.1 # meters

    print("\nStarting simulation... Press Ctrl+C to stop.")
    try:
        while not done:
            if stage_args.render:
                env.render()
                if not args.fast:
                    time.sleep(1./60.)

            # --- Action Selection ---
            if model:
                act, _ = model.predict(obs, deterministic=True)
            else:
                # Use the smart heuristic agent
                action_strategy = CANDIDATE_ACTIONS[current_action_index]
                act = action_strategy() if callable(action_strategy) else action_strategy

            # --- Environment Step ---
            obs, reward, terminated, truncated, info = env.step(act)
            done = terminated or truncated
            total_reward += reward
            step += 1
            
            # --- Progress Tracking for Heuristic Agent ---
            current_pos_x = env.unwrapped.agent_body.reference_head_object.position.x
            if current_pos_x > max_x_pos:
                max_x_pos = current_pos_x
                steps_at_max_x = step

            if not model and (step - last_check_step > STUCK_CHECK_INTERVAL):
                progress = current_pos_x - last_check_pos_x
                if progress < STUCK_PROGRESS_THRESHOLD:
                    print(f"  -> Agent stuck at step {step} (progress: {progress:.2f}m). Changing strategy...")
                    current_action_index = (current_action_index + 1) % len(CANDIDATE_ACTIONS)
                
                last_check_step = step
                last_check_pos_x = current_pos_x

            if step >= args.timeout:
                print("TIMEOUT: Reached maximum steps defined for the check.")
                break

    except KeyboardInterrupt:
        print("\nSimulation stopped by user.")
    finally:
        env.close()

    # --- Final Report ---
    print_header("CHECK COMPLETE")
    print(f"Total Simulation Steps: {step}")
    print(f"Total Reward: {total_reward:.2f}")

    print("\nPerformance Metrics:")
    print(f"  - Maximum X-Position Reached: {max_x_pos:.2f} meters")
    print(f"  - Steps to Reach Max Position: {steps_at_max_x}")
    
    if truncated and not terminated:
        print("\nResult: Episode was TRUNCATED (hit the timeout). The map is likely longer.")
    elif terminated:
        print("\nResult: Episode was TERMINATED (agent fell or reached the goal).")
    else:
        print("\nResult: Simulation stopped manually.")

    print("\nRECOMMENDATION:")
    print(f"Based on this run, a good starting 'horizon' value is around {int(steps_at_max_x * 1.2)}.")
    print("(This is based on steps to reach the furthest point + 20% buffer).")

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Check the approximate number of steps to complete a map.")
    parser = add_check_length_args(parser)
    args = parser.parse_args()
    main(args)

===== .\scripts\demo.py =====
# scripts/demo.py
import argparse
import time
import os
import sys
import numpy as np

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import TeachMyAgent.environments
from utils.env_utils import build_and_setup_env, collect_env_params, setup_render_window
from utils.shared_args import add_common_args, add_environment_args, add_render_args

def add_demo_args(parser):
    parser = add_common_args(parser)
    parser = add_environment_args(parser)
    parser = add_render_args(parser)
    parser.add_argument('--steps', type=int, default=2000, help="Number of steps to run in the demo.")
    return parser

def main(args):
    print(f"--- Demo Configuration ---\nEnvironment: {args.env}\nBody: {args.body}\n---------------------------")
    env = None
    try:
        user_params = collect_env_params(args.env, args)
        env = build_and_setup_env(args.env, args.body, user_params, render_mode="human")
        setup_render_window(env, args)
        obs, info = env.reset(seed=np.random.randint(1000))
        
        for step in range(args.steps):
            env.render()

            # Safe exit if window is closed
            if env.unwrapped.viewer and env.unwrapped.viewer.window and env.unwrapped.viewer.window.has_exit:
                print("Window closed. Exiting demo.")
                break

            action = env.action_space.sample()
            obs, reward, terminated, truncated, info = env.step(action)
            time.sleep(1.0 / 60.0)

            if terminated or truncated:
                print(f"Episode ended after {step+1} steps. Resetting environment.")
                obs, info = env.reset()
    except KeyboardInterrupt:
        print("\nDemo interrupted by user.")
    finally:
        if env:
            env.close()
            print("Environment closed.")

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description="Run an environment demo.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser = add_demo_args(parser)
    args = parser.parse_args()
    main(args)


===== .\scripts\evaluate.py =====
# scripts/evaluate.py
import argparse
import os
import sys
import time
import numpy as np
import zipfile
import tempfile
import shutil
from typing import Optional

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from stable_baselines3 import PPO
from stable_baselines3.common.env_util import make_vec_env
from stable_baselines3.common.vec_env import VecNormalize
from utils.env_utils import build_and_setup_env, collect_env_params, setup_render_window
from utils.shared_args import add_common_args, add_environment_args, add_render_args
from utils.seeding import set_seed

def add_evaluation_args(parser: argparse.ArgumentParser) -> argparse.ArgumentParser:
    """Adds evaluation-specific arguments to the parser."""
    parser = add_common_args(parser)
    parser = add_environment_args(parser)
    parser = add_render_args(parser)
    
    eval_group = parser.add_argument_group('Evaluation Parameters')
    eval_group.add_argument('--model_path', type=str, required=True, help="Path to the trained model (.zip file).")
    eval_group.add_argument('--num_episodes', type=int, default=20, help="Number of episodes to run for evaluation.")
    eval_group.add_argument('--render', action='store_true', help="Render the environment during evaluation.")
    eval_group.add_argument('--horizon', type=int, default=5000, help="Max steps per episode.")
    
    # Note: A separate seed is used here for evaluation to be independent of training seed
    eval_group.add_argument('--eval_seed', type=int, default=42, help="Base seed for evaluation episodes.")
    return parser

def evaluate_agent(args: argparse.Namespace):
    """Loads a trained agent and evaluates its performance over multiple episodes."""
    print(f"--- Starting Evaluation ---\nModel: {args.model_path}\nEnv: {args.env}\nBody: {args.body}\n--------------------")

    if not os.path.exists(args.model_path):
        print(f"ERROR: Model not found at '{args.model_path}'")
        sys.exit(1)
        
    set_seed(args.eval_seed)
    
    episode_rewards = []
    episode_lengths = []
    temp_dir = tempfile.mkdtemp()

    try:
        # Load VecNormalize stats from the zip file if they exist
        stats_path: Optional[str] = None
        with zipfile.ZipFile(args.model_path, 'r') as archive:
            if 'vecnormalize.pkl' in archive.namelist():
                archive.extract('vecnormalize.pkl', path=temp_dir)
                stats_path = os.path.join(temp_dir, 'vecnormalize.pkl')
                print("Found and extracted VecNormalize stats.")

        for i in range(args.num_episodes):
            print(f"\n--- Starting Evaluation Episode {i + 1}/{args.num_episodes} ---")
            
            # Create a new env for each episode with a different seed
            current_seed = args.eval_seed + i
            def env_constructor():
                set_seed(current_seed)
                env = build_and_setup_env(args.env, args.body, 
                                          collect_env_params(args.env, args), 
                                          render_mode="human" if args.render else None, 
                                          args=args)
                if args.render:
                    setup_render_window(env, args)
                return env

            venv = make_vec_env(env_constructor, n_envs=1)
            
            if stats_path:
                venv = VecNormalize.load(stats_path, venv)
                venv.training = False
                venv.norm_reward = False

            model = PPO.load(args.model_path, env=venv)

            obs = venv.reset()
            done = False
            total_reward = 0
            ep_len = 0
            
            while not done:
                if args.render:
                    venv.render()
                    time.sleep(1.0 / 60.0)

                action, _ = model.predict(obs, deterministic=True)
                obs, reward, done, info = venv.step(action)
                
                ep_len += 1
            
            final_reward = info[0].get('episode', {}).get('r', 0)
            episode_rewards.append(final_reward)
            episode_lengths.append(ep_len)
            print(f"Episode {i + 1} finished. Reward: {final_reward:.2f}, Length: {ep_len}")

            venv.close() # Close env to free up resources

        # --- Final Report ---
        mean_reward = np.mean(episode_rewards)
        std_reward = np.std(episode_rewards)
        print("\n" + "="*50)
        print("EVALUATION SUMMARY")
        print(f"Ran {args.num_episodes} episodes with base seed {args.eval_seed}.")
        print(f"Mean Reward: {mean_reward:.2f} +/- {std_reward:.2f}")
        print(f"Mean Length: {np.mean(episode_lengths):.2f}")
        print("="*50)

    except KeyboardInterrupt:
        print("\nEvaluation stopped by user.")
    finally:
        if os.path.exists(temp_dir):
            shutil.rmtree(temp_dir)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Evaluate a trained agent.")
    parser = add_evaluation_args(parser)
    args = parser.parse_args()
    evaluate_agent(args)

===== .\scripts\run_single_test.py =====
# scripts/run_single_test.py
import argparse
import os
import sys
import time
from types import SimpleNamespace

# Add root directory to import path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import TeachMyAgent.environments
from utils.env_utils import build_and_setup_env, setup_render_window
from TeachMyAgent.environments.envs.multi_agent_parametric_parkour import MultiAgentParkour
from TeachMyAgent.environments.envs.interactive_multi_agent_parkour import InteractiveMultiAgentParkour


def check_single_agent_env(env_key, body_name, steps, delay):
    """Single-agent test."""
    env = None
    try:
        fake_args = SimpleNamespace(fullscreen=False, width=None, height=None)
        env = build_and_setup_env(env_key, body_name, {}, render_mode="human")
        setup_render_window(env, fake_args)
        env.reset()
        for _ in range(steps):
            env.render()
            if env.unwrapped.viewer and env.unwrapped.viewer.window and env.unwrapped.viewer.window.has_exit:
                break
            action = env.action_space.sample()
            env.step(action)
            time.sleep(delay)
        return True
    finally:
        if env:
            env.close()


def check_multi_agent_env(mode, body_name, steps, delay):
    """Multi-agent test."""
    env = None
    try:
        fake_args = SimpleNamespace(fullscreen=False, width=None, height=None, n_agents=2)
        env_config = {
            "n_agents": fake_args.n_agents,
            "agent_body_type": body_name,
            "render_mode": "human"
        }

        if mode == 'cooperative':
            env = MultiAgentParkour(config=env_config)
            if env.envs:
                setup_render_window(env.envs[0], fake_args)
        else:  # interactive
            env = InteractiveMultiAgentParkour(config=env_config)
            setup_render_window(env, fake_args)
        
        env.reset()
        for _ in range(steps):
            env.render()
            viewer = env.viewer if hasattr(env, 'viewer') and env.viewer else (
                env.envs[0].viewer if hasattr(env, 'envs') and env.envs else None
            )
            if viewer and viewer.window and viewer.window.has_exit:
                break
            action = env.action_space.sample()
            _, _, terminated, truncated, _ = env.step(action)
            if terminated.get("__all__", False) or truncated.get("__all__", False):
                env.reset()
            time.sleep(delay)
        return True
    finally:
        if env:
            env.close()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Run a single environment test.")
    parser.add_argument('--env', type=str, required=True, help="Environment type.")
    parser.add_argument('--body', type=str, required=True, help="Body type.")
    parser.add_argument('--steps', type=int, default=100)
    parser.add_argument('--delay', type=float, default=0.02)
    args = parser.parse_args()

    try:
        success = False
        if args.env in ['stump', 'parkour']:
            success = check_single_agent_env(args.env, args.body, args.steps, args.delay)
        elif args.env == 'marl-cooperative':
            success = check_multi_agent_env('cooperative', args.body, args.steps, args.delay)
        elif args.env == 'marl-interactive':
            success = check_multi_agent_env('interactive', args.body, args.steps, args.delay)

        sys.exit(0 if success else 1)
    except Exception:
        import traceback
        traceback.print_exc()
        sys.exit(1)


===== .\scripts\test_suite.py =====
# scripts/test_suite.py
import argparse
import os
import sys
import yaml
from types import SimpleNamespace

# Add project root to path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from preprocessing import convert_weight
from scripts import demo as demo_script
from scripts import train_ppo
from scripts import train_acl
from scripts import train_marl
from scripts import watch


def print_header(text, char='='):
    width = 80
    print("\n" + char * width)
    print(f"{text:^{width}}")
    print(char * width)


def run_test(func, args_namespace, test_name):
    print_header(f"RUNNING TEST: {test_name.upper()}", char='-')
    if args_namespace:
        print(f"Args: {vars(args_namespace)}")
    try:
        result = func(args_namespace) if args_namespace else func()
        print(f"‚úÖ SUCCESS: {test_name} completed.")
        return result, True
    except Exception:
        print(f"‚ùå FAILURE: {test_name} failed.")
        import traceback
        traceback.print_exc()
        return None, False


def load_main_config():
    """Load main configuration from main_pipeline.yaml."""
    config_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'configs', 'main_pipeline.yaml')
    if not os.path.exists(config_path):
        print(f"ERROR: Config file not found at {config_path}")
        sys.exit(1)
    with open(config_path, 'r') as f:
        return yaml.safe_load(f)


def main(args=None):
    print_header("STARTING FULL PIPELINE TEST")
    overall_success = True
    
    main_config = load_main_config()

    # Test 1: Weight conversion
    _, success = run_test(convert_weight.convert_tf1_to_pytorch, None, "Convert Weight")
    if not success:
        overall_success = False

    # Test 2: Demo environment
    demo_args = SimpleNamespace(
        env='parkour', body='classic_bipedal', steps=50, 
        # START CHANGE: Set fullscreen to True
        fullscreen=True, 
        # END CHANGE
        width=None, height=None, # width/height will be ignored if fullscreen is True
        roughness=None, stump_height=None, stump_width=None, obstacle_spacing=None,
        input_vector=None, water_level=None, creepers_width=None, creepers_height=None, creepers_spacing=None
    )
    _, success = run_test(demo_script.main, demo_args, "Demo Parkour Env")
    if not success:
        overall_success = False

    # Test 3: PPO training (short) and playback
    ppo_config = main_config.get('PPO', {})
    ppo_config.update({
        'run_id': "test_suite_ppo",
        'total_timesteps': 256,
        'save_freq': 256,
        'n_envs': 2,
        'render': False,
        'fullscreen': False,
        'width': None,
        'height': None
    })
    ppo_args = SimpleNamespace(**ppo_config)
    
    model_path, success = run_test(train_ppo.main, ppo_args, "Train PPO (short)")
    if not success:
        overall_success = False
    elif model_path:
        watch_args = SimpleNamespace(
            model_path=model_path,
            framework='sb3',
            num_episodes=1,
            env=ppo_args.env,
            body=ppo_args.body,
            # START CHANGE: Set fullscreen to True
            fullscreen=True,
            # END CHANGE
            width=None, height=None,
            timeout=100,
            fast_forward=True,
            roughness=None, stump_height=None, stump_width=None, obstacle_spacing=None,
            input_vector=None, water_level=None, creepers_width=None, creepers_height=None, creepers_spacing=None
        )
        _, watch_success = run_test(watch.main, watch_args, "Watch Trained PPO Model")
        if not watch_success:
            overall_success = False

    # Test 4: ACL training (short)
    acl_config = main_config.get('ACL', {})
    acl_config.update({
        'run_id': "test_suite_acl",
        'total_stages': 2,
        'student_steps_per_stage': 128,
        'eval_episodes': 1,
        'mastery_threshold': 50.0,
        'n_envs': 2,
        'render': False,
        'fullscreen': False,
        'width': None,
        'height': None
    })
    acl_args = SimpleNamespace(**acl_config)
    _, success = run_test(train_acl.main, acl_args, "Train ACL (short)")
    if not success:
        overall_success = False

    # Test 5: MARL training (short) and playback
    marl_config = main_config.get('MARL', {})
    marl_config.update({
        'run_id': "test_suite_marl",
        'iterations': 2,
        'num_workers': 1,
        'num_gpus': 0,
        'check_env': False,
        'width': None,
        'height': None,
        'fullscreen': False,
        'use_tune': False
    })
    marl_args = SimpleNamespace(**marl_config)
    
    marl_checkpoint_path, success = run_test(train_marl.main, marl_args, "Train MARL (short)")
    if not success:
        overall_success = False
    elif marl_checkpoint_path:
        watch_marl_args = SimpleNamespace(
            model_path=marl_checkpoint_path,
            framework='rllib',
            num_episodes=1,
            timeout=100,
            fast_forward=True,
            mode=marl_args.mode,
            n_agents=marl_args.n_agents,
            body=marl_args.body,
            # START CHANGE: Set fullscreen to True
            fullscreen=True,
            # END CHANGE
            width=None, height=None,
            env='parkour', roughness=None, stump_height=None, stump_width=None, 
            obstacle_spacing=None, input_vector=None, water_level=None, 
            creepers_width=None, creepers_height=None, creepers_spacing=None
        )
        _, watch_marl_success = run_test(watch.main, watch_marl_args, "Watch Trained MARL Model")
        if not watch_marl_success:
            overall_success = False

    print_header("TEST SUITE SUMMARY")
    if overall_success:
        print("üéâüéâüéâ All pipeline tests passed successfully! üéâüéâüéâ")
    else:
        print("üî•üî•üî• ERRORS DETECTED DURING TESTING. üî•üî•üî•")
        sys.exit(1)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Run the project's integrated test suite.")
    main(None)

===== .\scripts\train_acl.py =====
# scripts/train_acl.py
import os
import sys
import time
import argparse
import numpy as np
import gymnasium as gym
from stable_baselines3 import PPO
from stable_baselines3.common.env_util import make_vec_env
from stable_baselines3.common.vec_env import VecNormalize
from typing import Callable, Union

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import TeachMyAgent.environments
from utils.env_utils import build_and_setup_env, setup_render_window
from utils.shared_args import add_common_args, add_environment_args, add_render_args

PARAM_SPACE_LIMS = np.array([
    [-1.0, 1.0],
    [-1.0, 1.0],
    [-1.0, 1.0],
    [0.0, 0.8],
])

EASY_PARAMS = np.array([0.0, 0.0, 0.0, 0.0])

def get_linear_schedule(initial_value: float) -> Callable[[float], float]:
    """Returns a linear schedule function for learning rate."""
    def func(progress_remaining: float) -> float:
        return progress_remaining * initial_value
    return func

def parse_schedule(config_value: Union[dict, float, str]):
    """Safely parses a schedule configuration from a dictionary."""
    if isinstance(config_value, dict):
        schedule_type = config_value.get("type")
        if schedule_type == "linear":
            initial_val = float(config_value["initial_value"])
            return get_linear_schedule(initial_val)
        else:
            raise ValueError(f"Unknown schedule type: {schedule_type}")
    return float(config_value)

def add_acl_args(parser: argparse.ArgumentParser) -> argparse.ArgumentParser:
    parser = add_common_args(parser)
    parser = add_environment_args(parser)
    parser = add_render_args(parser)
    group = parser.add_argument_group("ACL Training Parameters")
    group.add_argument("--run_id", type=str, default="acl_run1", help="Run identifier.")
    group.add_argument("--total_stages", type=int, default=500, help="Total number of curriculum stages.")
    group.add_argument("--student_steps_per_stage", type=int, default=2048 * 8, help="Training steps per stage.")
    group.add_argument("--eval_episodes", type=int, default=10, help="Number of evaluation episodes.")
    group.add_argument("--mastery_threshold", type=float, default=150.0, help="Reward threshold to increase difficulty.")
    group.add_argument("--difficulty_increment", type=float, default=0.01, help="Difficulty increase step.")
    group.add_argument("--render", action='store_true', help="Enable rendering during training and evaluation.")
    group.add_argument("--n_envs", type=int, default=8, help="Number of parallel environments for training.")
    parser.add_argument('--horizon', type=int, default=3000, help="Max steps per episode.")
    return parser

def sample_task_params(difficulty_ratio: float) -> dict:
    """
    Generates environment parameters based on a two-stage curriculum.
    """
    min_spacing = 0.05
    max_spacing = 2.0
    max_height = 10.0
    min_height = 1.5

    if difficulty_ratio < 0.5:
        stage_1_progress = difficulty_ratio * 2
        current_spacing = min_spacing + stage_1_progress * (max_spacing - min_spacing)
        current_height = max_height
    else:
        stage_2_progress = (difficulty_ratio - 0.5) * 2
        current_spacing = max_spacing
        current_height = max_height - stage_2_progress * (max_height - min_height)

    low_bounds = EASY_PARAMS
    high_bounds = np.array([lim[1] if p > 0 else lim[0] for p, lim in zip(EASY_PARAMS, PARAM_SPACE_LIMS)])
    current_max = low_bounds + difficulty_ratio * (high_bounds - low_bounds)
    sampled_terrain_params = np.random.uniform(low=low_bounds, high=current_max)

    return {
        "input_vector": sampled_terrain_params[:3],
        "water_level": sampled_terrain_params[3],
        "creepers_spacing": current_spacing,
        "creepers_height": current_height,
        "creepers_width": 0.5
    }

def evaluate_student(student_model: PPO, env_id: str, body_type: str, difficulty_ratio: float, num_episodes: int, args: argparse.Namespace, render_mode: str = None, stats_path: str = None) -> float:
    total_rewards = 0.0
    vec_eval_env = None
    try:
        def make_eval_env():
            task = sample_task_params(difficulty_ratio)
            return build_and_setup_env(env_id, body_type, task, render_mode=render_mode, args=args)

        vec_eval_env = make_vec_env(make_eval_env, n_envs=1)
        if stats_path and os.path.exists(stats_path):
            vec_eval_env = VecNormalize.load(stats_path, vec_eval_env)
            vec_eval_env.training = False
            vec_eval_env.norm_reward = False
        
        for i in range(num_episodes):
            print(f"  Evaluating Episode {i + 1}/{num_episodes}...")
            # START FIX: The evaluation environment is already recreated for each episode via make_vec_env,
            # so we don't need to call set_environment again. This makes it cleaner.
            # END FIX
            obs = vec_eval_env.reset()
            done = False
            episode_reward = 0.0
            while not done:
                if render_mode == "human":
                    vec_eval_env.render()
                action, _ = student_model.predict(obs, deterministic=True)
                obs, reward, done_vec, info = vec_eval_env.step(action)
                done = done_vec[0]
                if done: # Use the final info dict to get the true episode reward
                    episode_reward = info[0].get('episode', {}).get('r', 0)
            total_rewards += episode_reward
    finally:
        if vec_eval_env:
            vec_eval_env.close()

    return total_rewards / num_episodes

def main(args: argparse.Namespace) -> str:
    if args.env != "parkour":
        print(f"ERROR: ACL training currently supports only 'parkour', got '{args.env}'.")
        sys.exit(1)

    output_base = f"output/acl/{args.run_id}"
    model_dir = os.path.join(output_base, "models")
    log_dir = os.path.join(output_base, "logs")
    stats_path = os.path.join(output_base, "vecnormalize.pkl")
    os.makedirs(model_dir, exist_ok=True)
    os.makedirs(log_dir, exist_ok=True)

    print(f"\n{'=' * 60}\nStarting ACL training for env '{args.env}' with body '{args.body}'")
    print(f"Output directory: {output_base}\n{'=' * 60}")

    render_mode = "human" if args.render else None
    
    # --- PPO Hyperparameters ---
    ppo_kwargs = getattr(args, 'ppo_config', {})
    if 'learning_rate_schedule' in ppo_kwargs:
        ppo_kwargs['learning_rate'] = parse_schedule(ppo_kwargs.pop('learning_rate_schedule'))
    if 'clip_range_schedule' in ppo_kwargs:
        ppo_kwargs['clip_range'] = parse_schedule(ppo_kwargs.pop('clip_range_schedule'))
    print("Using PPO hyperparameters for student:", ppo_kwargs)
    
    # --- ACL Main Loop ---
    difficulty_ratio = 0.0
    student = None
    final_path = os.path.join(model_dir, "student_final.zip")

    try:
        for stage in range(1, args.total_stages + 1):
            start_time = time.time()
            task_params = sample_task_params(difficulty_ratio)
            print(f"\n--- Stage {stage}/{args.total_stages} | Difficulty: {difficulty_ratio:.3f} ---")
            print(f"Task parameters: {task_params}")

            # START FIX: Implement Clean Reset Logic
            # 1. Save current model and environment stats (if they exist)
            if student:
                temp_model_path = os.path.join(model_dir, "student_temp.zip")
                student.save(temp_model_path)
                student.get_env().save(stats_path)
                # Close the old environment completely
                student.get_env().close()
                del student # Free up memory
            else:
                temp_model_path = None

            # 2. Create a brand new vectorized environment with the new task parameters
            n_envs = 1 if args.render else args.n_envs
            vec_env = make_vec_env(
                lambda: build_and_setup_env(args.env, args.body, task_params, args=args),
                n_envs=n_envs,
                seed=getattr(args, 'seed', None)
            )
            
            # 3. Load old normalization stats if they exist, otherwise create new ones
            if os.path.exists(stats_path):
                print(f"Loading VecNormalize stats from: {stats_path}")
                vec_env = VecNormalize.load(stats_path, vec_env)
            else:
                print("Creating new VecNormalize stats.")
                vec_env = VecNormalize(vec_env, norm_obs=True, norm_reward=True, clip_obs=10.)

            # 4. Create a new PPO model and load the weights from the previous stage
            if temp_model_path and os.path.exists(temp_model_path):
                print(f"Loading model weights from previous stage: {temp_model_path}")
                student = PPO.load(temp_model_path, env=vec_env, tensorboard_log=os.path.join(log_dir, "student"), device="auto")
                # Reset timesteps to ensure tensorboard logs correctly for the new stage
                student.set_logger(student.logger) 
            else:
                print("Initializing new PPO model for the first stage.")
                student = PPO("MlpPolicy", vec_env, verbose=0, tensorboard_log=os.path.join(log_dir, "student"), device="auto", **ppo_kwargs)
            # END FIX

            student.learn(total_timesteps=args.student_steps_per_stage, reset_num_timesteps=False, progress_bar=True)
            
            # Save the normalization stats from the current training environment
            student.get_env().save(stats_path)
            
            print(f"Evaluating agent over {args.eval_episodes} episodes...")
            # During evaluation, we need a separate, non-training environment
            eval_model_path = os.path.join(model_dir, "student_eval_temp.zip")
            student.save(eval_model_path)
            eval_model = PPO.load(eval_model_path, device="auto")
            
            avg_reward = evaluate_student(eval_model, args.env, args.body, difficulty_ratio, args.eval_episodes, args, render_mode=render_mode, stats_path=stats_path)
            del eval_model # Clean up
            
            print(f"Average reward = {avg_reward:.2f}")
            if avg_reward > args.mastery_threshold:
                new_diff = min(1.0, difficulty_ratio + args.difficulty_increment)
                if new_diff > difficulty_ratio:
                    difficulty_ratio = new_diff
                    print(f"Mastery achieved! Increasing difficulty to {difficulty_ratio:.3f}")
            else:
                print(f"Below threshold ({args.mastery_threshold:.2f}). Keeping difficulty unchanged.")

            if stage % 25 == 0 or stage == args.total_stages:
                model_path = os.path.join(model_dir, f"student_{args.run_id}_stage_{stage}.zip")
                student.save(model_path)
                print(f"Model saved: {model_path}")

            print(f"Stage time: {time.time() - start_time:.2f}s")

    except KeyboardInterrupt:
        print("\nTraining interrupted by user.")
    finally:
        if student and student.get_env():
            student.get_env().save(stats_path)
            print(f"Final VecNormalize stats saved to: {stats_path}")
            student.save(final_path)
            student.get_env().close()

    print(f"\n{'=' * 60}\nACL training complete.")
    print(f"Final Student model saved at: {final_path}")
    return final_path

===== .\scripts\train_marl.py =====
# scripts/train_marl.py
import argparse
import os
import sys
import time
import ray
from collections.abc import Mapping
from typing import Optional
from ray import tune, air
from ray.rllib.algorithms.ppo import PPOConfig
from ray.rllib.policy.policy import PolicySpec
from ray.tune.registry import register_env
from gymnasium.wrappers import TransformObservation
import numpy as np
import gymnasium as gym
import TeachMyAgent.environments


from ray.rllib.utils.metrics import (
    ENV_RUNNER_RESULTS,
    EPISODE_RETURN_MEAN,
    LEARNER_RESULTS,
    ALL_MODULES,
)

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import TeachMyAgent.environments
from TeachMyAgent.environments.envs.multi_agent_parametric_parkour import MultiAgentParkour
from TeachMyAgent.environments.envs.interactive_multi_agent_parkour import InteractiveMultiAgentParkour

def add_marl_args(parser: argparse.ArgumentParser) -> argparse.ArgumentParser:
    parser.add_argument("--mode", type=str, default="interactive", choices=["cooperative", "interactive"], help="Environment mode.")
    parser.add_argument("--n-agents", type=int, default=2, help="Number of agents.")
    parser.add_argument("--body", type=str, default="classic_bipedal", help="Agent body type.")
    parser.add_argument("--iterations", type=int, default=100, help="Number of training iterations.")
    parser.add_argument("--num-workers", type=int, default=2, help="Number of Ray rollout workers.")
    parser.add_argument("--num-gpus", type=float, default=0, help="Number of GPUs to use for training.")
    parser.add_argument("--check-env", action="store_true", help="Run a random environment check.")
    parser.add_argument("--width", type=int, help="Render window width.")
    parser.add_argument("--height", type=int, help="Render window height.")
    parser.add_argument("--fullscreen", action="store_true", help="Render in fullscreen.")
    parser.add_argument("--run_id", type=str, default="marl_run1", help="Identifier for the training run.")
    parser.add_argument("--use-tune", action="store_true", help="Use Ray Tune for hyperparameter tuning.")
    parser.add_argument('--horizon', type=int, default=3000, help="Max steps per episode.")
    parser.add_argument("--reward-type", type=str, default="individual", choices=["individual", "shared"], help="MARL reward structure.")
    parser.add_argument("--shared-policy", action="store_true", help="Use a single shared policy for all agents.")
    parser.add_argument("--use-cc", action="store_true", help="Use a Centralized Critic.")
    return parser

def deep_update(original, new_dict):
    for key, value in new_dict.items():
        if key in original and isinstance(original[key], Mapping) and isinstance(value, Mapping):
            deep_update(original[key], value)
        else:
            original[key] = value
    return original

def _parse_search_space(search_space_config):
    if not search_space_config: return {}
    TUNE_SAMPLERS = {"grid_search": tune.grid_search, "choice": tune.choice, "uniform": tune.uniform, "loguniform": tune.loguniform}
    def recursive_parse(config_dict):
        parsed_dict = {}
        for key, value in config_dict.items():
            if isinstance(value, str):
                is_sampler = False
                for sampler_name, sampler_func in TUNE_SAMPLERS.items():
                    if value.startswith(f"tune.{sampler_name}"):
                        args_str = value[len(f"tune.{sampler_name}"):]
                        try:
                            args_val = eval(args_str)
                            parsed_dict[key] = sampler_func(*args_val) if isinstance(args_val, tuple) else sampler_func(args_val)
                            is_sampler = True
                            break
                        except Exception as e:
                            print(f"ERROR: Could not parse tune args '{args_str}'. Error: {e}"); sys.exit(1)
                if not is_sampler: parsed_dict[key] = value
            elif isinstance(value, dict): parsed_dict[key] = recursive_parse(value)
            else: parsed_dict[key] = value
        return parsed_dict
    return recursive_parse(search_space_config)

def get_env_creator(mode):
    if mode == "cooperative": base_env_creator_func = lambda config: MultiAgentParkour(config=config)
    elif mode == "interactive": base_env_creator_func = lambda config: InteractiveMultiAgentParkour(config=config)
    else: raise ValueError(f"Invalid mode: '{mode}'.")
    def wrapped_env_creator(config):
        base_env = base_env_creator_func(config)
        def clip_multi_agent_obs(obs_dict):
            return {agent_id: np.clip(agent_obs, -10.0, 10.0) for agent_id, agent_obs in obs_dict.items()}
        original_obs_space = base_env.observation_space
        clipped_sub_spaces = {}
        if isinstance(original_obs_space, gym.spaces.Dict):
             for agent_id, sub_space in original_obs_space.items():
                clipped_sub_spaces[agent_id] = gym.spaces.Box(low=-10.0, high=10.0, shape=sub_space.shape, dtype=sub_space.dtype)
        clipped_observation_space = gym.spaces.Dict(clipped_sub_spaces)
        return TransformObservation(base_env, clip_multi_agent_obs, clipped_observation_space)
    return wrapped_env_creator

def main(args: argparse.Namespace) -> Optional[str]:
    if hasattr(args, 'check_env') and args.check_env: return

    if not hasattr(args, 'horizon'): args.horizon = 3000

    env_name = f"marl-{args.mode}-v0"
    register_env(env_name, get_env_creator(args.mode))
    env_config = {"n_agents": args.n_agents, "agent_body_type": args.body, "horizon": args.horizon, "reward_type": args.reward_type}
    
    with get_env_creator(args.mode)(env_config) as temp_env:
        obs_space, act_space = temp_env.observation_space["agent_0"], temp_env.action_space["agent_0"]

    ppo_config_dict = getattr(args, 'ppo_config', {}); training_config = ppo_config_dict.get('training', {})
    model_config = ppo_config_dict.get('model', {}); env_runners_config = ppo_config_dict.get('env_runners', {})

    config = (PPOConfig().environment(env=env_name, env_config=env_config, normalize_actions=True)
        .env_runners(num_env_runners=args.num_workers, **env_runners_config).framework("torch").training(**training_config)
        .rl_module(model_config=model_config).resources(num_gpus=args.num_gpus))

    if hasattr(args, 'shared_policy') and args.shared_policy:
        print("Using Parameter Sharing.")
        config.multi_agent(policies={"shared_policy": PolicySpec(observation_space=obs_space, action_space=act_space)},
                           policy_mapping_fn=lambda agent_id, *a, **kw: "shared_policy")
    else:
        print("Using Independent Learning.")
        config.multi_agent(policies={f"agent_{i}": PolicySpec(observation_space=obs_space, action_space=act_space) for i in range(args.n_agents)},
                           policy_mapping_fn=lambda agent_id, *a, **kw: agent_id)

    if hasattr(args, 'use_cc') and args.use_cc:
        print("Activating Centralized Critic.")
        config.update_from_dict({"use_centralized_value_function": True})

    use_tune = getattr(args, 'use_tune', False)

    if use_tune:
        print("Starting MARL training with Ray Tune...")
        tune_config = getattr(args, 'tune_config', {}); search_space_config = tune_config.get('search_space', {})
        run_config_dict = tune_config.get('run_config', {})
        if 'stop' not in run_config_dict: raise ValueError("`stop` criteria must be defined in `tune_config.run_config` when `use_tune` is true.")
        
        param_space = config.to_dict(); deep_update(param_space, _parse_search_space(search_space_config))
        
        checkpoint_config_dict = run_config_dict.get('checkpoint_config', {}); checkpoint_config_dict.setdefault('num_to_keep', 1)
        checkpoint_config_dict.setdefault('checkpoint_score_attribute', f"{ENV_RUNNER_RESULTS}/{EPISODE_RETURN_MEAN}"); checkpoint_config_dict.setdefault('checkpoint_score_order', 'max')
        
        storage_path = os.path.abspath(os.path.join("output", "marl")); run_name = run_config_dict.get('name', args.run_id)
        print(f"Checkpoints will be saved to: {os.path.join(storage_path, run_name)}")

        run_config = air.RunConfig(name=run_name, stop=run_config_dict['stop'], verbose=run_config_dict.get('verbose', 2),
                                   checkpoint_config=air.CheckpointConfig(**checkpoint_config_dict), storage_path=storage_path)

        tuner = tune.Tuner("PPO", param_space=param_space, run_config=run_config, tune_config=tune.TuneConfig(trial_dirname_creator=lambda t: t.trial_id))
        results = tuner.fit()
        best_result = results.get_best_result(metric=f"{ENV_RUNNER_RESULTS}/{EPISODE_RETURN_MEAN}", mode="max")
        best_checkpoint_path = best_result.checkpoint.path if best_result and best_result.checkpoint else None
        
        print("\n" + "="*60 + "\nRay Tune finished!")
        if best_result:
            print(f"Best trial final reward: {best_result.metrics.get(ENV_RUNNER_RESULTS, {}).get(EPISODE_RETURN_MEAN, 'N/A')}")
            print(f"Best trial config: {best_result.config}\nBest checkpoint saved at: {best_checkpoint_path}")
        else: print("No trials completed successfully.")
        print("="*60)
        return best_checkpoint_path
    else:
        print(f"Starting a single MARL training run for {args.iterations} iterations...")
        algo = config.build()
        output_dir = os.path.abspath(os.path.join("output", "marl", args.run_id)); os.makedirs(output_dir, exist_ok=True)
        print(f"Checkpoints will be saved to: {output_dir}")
        print(f"TensorBoard logs will be saved under: {algo.logdir}")

        best_reward, checkpoint_path_to_return = -float('inf'), None
        for i in range(args.iterations):
            result = algo.train()
            env_runner_results, learner_results = result.get(ENV_RUNNER_RESULTS, {}), result.get(LEARNER_RESULTS, {})
            episode_reward_mean = env_runner_results.get(EPISODE_RETURN_MEAN, float("nan"))
            
            if episode_reward_mean > best_reward:
                best_reward = episode_reward_mean
                checkpoint_result = algo.save(checkpoint_dir=output_dir)
                checkpoint_path_to_return = checkpoint_result.checkpoint.path
                print(f"\nNew best average reward: {best_reward:.2f}. Checkpoint saved at: {checkpoint_path_to_return}")
            
            per_policy_rewards = env_runner_results.get("module_episode_returns_mean", {})
            total_loss_per_module = {mid: stats.get("total_loss", float("nan")) for mid, stats in learner_results.items() if mid != ALL_MODULES}
            
            print(f"Iter {i + 1}/{args.iterations}: Mean Reward: {episode_reward_mean:.2f}, Policy Rewards: {per_policy_rewards}, Module Loss: {total_loss_per_module}")
        
        print(f"\nTraining complete. Best checkpoint saved at: {checkpoint_path_to_return}")
        return checkpoint_path_to_return

===== .\scripts\train_ppo.py =====
# scripts/train_ppo.py
import os
import sys
import argparse
import time
from typing import Callable, Union

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from stable_baselines3 import PPO
from stable_baselines3.common.callbacks import CheckpointCallback
from stable_baselines3.common.env_util import make_vec_env
from stable_baselines3.common.vec_env import VecNormalize

import TeachMyAgent.environments
from utils.env_utils import build_and_setup_env, collect_env_params, setup_render_window
from utils.shared_args import add_common_args, add_environment_args, add_render_args

def add_ppo_args(parser: argparse.ArgumentParser) -> argparse.ArgumentParser:
    parser = add_common_args(parser)
    parser = add_environment_args(parser)
    parser = add_render_args(parser)
    train_group = parser.add_argument_group('PPO Training Parameters')
    train_group.add_argument('--total_timesteps', type=int, default=1_000_000)
    train_group.add_argument('--run_id', type=str, default='ppo_run1')
    train_group.add_argument('--save_freq', type=int, default=100_000)
    train_group.add_argument('--n_envs', type=int, default=16)
    train_group.add_argument('--render', action='store_true')
    parser.add_argument('--horizon', type=int, default=5000)
    return parser

def get_linear_schedule(initial_value: float) -> Callable[[float], float]:
    """Returns a linear schedule function for learning rate."""
    def func(progress_remaining: float) -> float:
        return progress_remaining * initial_value
    return func

def parse_schedule(config_value: Union[dict, float, str]):
    """Safely parses a schedule configuration from a dictionary."""
    if isinstance(config_value, dict):
        schedule_type = config_value.get("type")
        if schedule_type == "linear":
            initial_val = float(config_value["initial_value"])
            return get_linear_schedule(initial_val)
        else:
            raise ValueError(f"Unknown schedule type: {schedule_type}")
    return float(config_value)

def main(args: argparse.Namespace) -> str:
    output_base_dir = f"output/ppo/{args.run_id}"
    model_dir = os.path.join(output_base_dir, "models")
    os.makedirs(model_dir, exist_ok=True)

    print("=" * 50 + f"\nTraining PPO: {args.env} with body {args.body}\nSaving to: {output_base_dir}\n" + "=" * 50)

    train_render_mode = "human" if args.render else None
    if args.render:
        args.n_envs = 1

    user_params = collect_env_params(args.env, args)
    env_lambda = lambda: build_and_setup_env(args.env, args.body, user_params, render_mode=train_render_mode, args=args)
    
    print("Creating vectorized and normalized environment...")
    env = make_vec_env(env_lambda, n_envs=args.n_envs, seed=getattr(args, 'seed', None))
    env = VecNormalize(env, norm_obs=True, norm_reward=True, clip_obs=10.)
    print("Environment created successfully.")

    if args.render:
        setup_render_window(env.envs[0], args)
    
    ppo_kwargs = getattr(args, 'ppo_config', {})
    
    if 'learning_rate_schedule' in ppo_kwargs:
        ppo_kwargs['learning_rate'] = parse_schedule(ppo_kwargs.pop('learning_rate_schedule'))
    if 'clip_range_schedule' in ppo_kwargs:
        ppo_kwargs['clip_range'] = parse_schedule(ppo_kwargs.pop('clip_range_schedule'))

    print("Using PPO hyperparameters:", ppo_kwargs)

    # START FIX: Add device="auto" to resolve GPU warnings and improve performance
    model = PPO("MlpPolicy", env, verbose=1, tensorboard_log=os.path.join(output_base_dir, "logs"), device="auto", **ppo_kwargs)
    # END FIX
    
    checkpoint_callback = CheckpointCallback(
        save_freq=max(args.save_freq // args.n_envs, 1),
        save_path=model_dir,
        name_prefix="ppo_model"
    )

    try:
        model.learn(total_timesteps=args.total_timesteps, callback=checkpoint_callback, progress_bar=True)
    except KeyboardInterrupt:
        print("\nTraining interrupted by user.")

    final_model_path = os.path.join(model_dir, "ppo_model_final.zip")
    model.save(final_model_path)
    print(f"Final model saved to: {final_model_path}")
    
    stats_path = os.path.join(output_base_dir, "vecnormalize.pkl")
    env.save(stats_path)
    print(f"VecNormalize stats saved to: {stats_path}")

    env.close()

    return final_model_path

===== .\scripts\watch.py =====
# scripts/watch.py
import argparse
import time
import os
import sys
import numpy as np
import gymnasium as gym
import ray
from ray.rllib.algorithms.algorithm import Algorithm
from ray.tune.registry import register_env
import TeachMyAgent.environments
import torch

from stable_baselines3 import PPO
from stable_baselines3.common.vec_env import VecNormalize, DummyVecEnv

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from utils.env_utils import build_and_setup_env, collect_env_params, setup_render_window
from utils.shared_args import add_common_args, add_environment_args, add_render_args
from scripts.train_marl import get_env_creator

class UserInterrupt(Exception):
    pass

def add_watch_args(parser: argparse.ArgumentParser) -> argparse.ArgumentParser:
    """Adds arguments for watching both SB3 and RLlib models."""
    parser.add_argument('--model_path', type=str, required=True,
                        help="Path to the trained model (.zip for SB3, checkpoint directory for RLlib).")

    watch_group = parser.add_argument_group('Playback Parameters')
    watch_group.add_argument('--framework', type=str, default='auto', choices=['auto', 'sb3', 'rllib'],
                             help="Model's framework. 'auto' will attempt to autodetect.")
    watch_group.add_argument('--num-episodes', type=int, default=10, help="Number of episodes to watch.")
    watch_group.add_argument('--timeout', type=int, default=5000, help="Maximum number of steps per episode.")
    watch_group.add_argument('--fast-forward', '-ff', action='store_true', help="Skip the delay between frames.")

    parser = add_common_args(parser)
    parser = add_environment_args(parser)
    parser = add_render_args(parser)

    rllib_group = parser.add_argument_group('RLlib/MARL Parameters')
    rllib_group.add_argument('--mode', type=str, default='interactive', choices=['cooperative', 'interactive'],
                             help="[RLlib] Environment mode (cooperative or interactive).")
    rllib_group.add_argument('--n-agents', type=int, default=2, help="[RLlib] Number of agents.")

    return parser

def _watch_sb3(args):
    """Handles watching a Stable Baselines 3 model."""
    print("--- Stable Baselines 3 Watch Mode (PPO/ACL) ---")
    if not os.path.exists(args.model_path):
        print(f"ERROR: Model file not found at '{args.model_path}'")
        sys.exit(1)

    model_dir = os.path.dirname(args.model_path)
    # The stats file should be in the parent directory of the 'models' folder
    stats_path = os.path.join(os.path.dirname(model_dir), "vecnormalize.pkl")
    if not os.path.exists(stats_path):
        # Fallback for older structures
        stats_path = os.path.join(model_dir, "vecnormalize.pkl")
        if not os.path.exists(stats_path):
            print(f"ERROR: VecNormalize stats file ('vecnormalize.pkl') not found in the output directory.")
            print("Please ensure the model was trained with VecNormalize and the stats file is present.")
            sys.exit(1)

    print(f"Found VecNormalize stats at: {stats_path}")

    # Create the environment first to check for mismatches
    venv_unnormalized = DummyVecEnv([lambda: build_and_setup_env(
        args.env, args.body,
        collect_env_params(args.env, args),
        render_mode="human", args=args
    )])
    
    # Load the model without an environment to inspect its properties
    try:
        temp_model = PPO.load(args.model_path, env=None)
    except Exception as e:
        print(f"Error loading model from '{args.model_path}': {e}")
        sys.exit(1)

    # --- Start: User-friendly Error Check ---
    env_obs_space = venv_unnormalized.observation_space
    model_obs_space = temp_model.observation_space

    if env_obs_space.shape != model_obs_space.shape:
        print("\n" + "!"*80)
        print("!! MISMATCH ERROR: Observation space shape mismatch detected !!")
        print(f"The loaded model was trained with an observation shape of {model_obs_space.shape},")
        print(f"but the environment you are trying to run has a shape of {env_obs_space.shape}.")
        print("\nThis usually happens when the wrong '--body' is specified for the 'watch' command.")
        print(f"The current body is '{args.body}'. Please provide the correct body type used during training.")
        print("Example: --body climbing_profile_chimpanzee")
        print("!"*80 + "\n")
        venv_unnormalized.close()
        sys.exit(1)
    # --- End: User-friendly Error Check ---

    # If shapes match, proceed to load VecNormalize and the model properly
    print("Observation spaces match. Loading environment with normalization stats...")
    venv = VecNormalize.load(stats_path, venv_unnormalized)
    venv.training = False
    venv.norm_reward = False
    print("Successfully loaded and applied VecNormalize stats.")

    setup_render_window(venv.envs[0], args)

    print("Loading model for playback...")
    model = PPO.load(args.model_path, env=venv)
    print("Model loaded successfully.")

    for i in range(args.num_episodes):
        obs = venv.reset()
        done = False
        ep_len = 0
        total_reward = 0.0
        print(f"\n--- Starting episode {i + 1}/{args.num_episodes} ---")

        while not done:
            action, _ = model.predict(obs, deterministic=True)
            obs, reward, done_vec, infos = venv.step(action)
            venv.render()

            viewer = venv.envs[0].unwrapped.viewer
            if viewer and viewer.window and viewer.window.has_exit:
                raise UserInterrupt("Render window was closed.")

            total_reward += infos[0].get('reward', reward[0])
            is_done = done_vec[0]
            ep_len += 1

            if not args.fast_forward:
                time.sleep(1.0 / 60.0)

            if not is_done and ep_len >= args.timeout:
                 print(f"  -> Timeout reached ({args.timeout} steps).")
                 is_done = True

            done = is_done

        final_reward = infos[0].get('episode', {}).get('r', total_reward)
        print(f"Episode finished. Reward: {final_reward:.2f}, Length: {ep_len}")

    venv.close()


def _watch_rllib(args):
    """Handles watching a Ray RLlib model."""
    print("--- Ray RLlib Watch Mode (MARL) ---")
    if not os.path.isdir(args.model_path):
        print(f"ERROR: Checkpoint path '{args.model_path}' is not a directory.")
        sys.exit(1)

    env_name = f"marl-{args.mode}-v0"
    env_creator = get_env_creator(args.mode)
    register_env(env_name, env_creator)
    print(f"Registered custom environment: '{env_name}'")

    if not ray.is_initialized():
        ray.init(ignore_reinit_error=True)

    try:
        print("Loading agent from checkpoint...")
        algo = Algorithm.from_checkpoint(args.model_path)
        print("Agent loaded successfully.")
    except Exception as e:
        print(f"Error loading checkpoint: {e}")
        if ray.is_initialized():
            ray.shutdown()
        sys.exit(1)

    env_config = {
        "n_agents": args.n_agents,
        "agent_body_type": args.body,
        "horizon": args.timeout,
        "render_mode": "human"
    }

    env = env_creator(env_config)
    setup_render_window(env.unwrapped, args)

    for i in range(args.num_episodes):
        print(f"\n--- Starting episode {i + 1}/{args.num_episodes} ---")

        obs, info = env.reset()
        terminated = {"__all__": False}
        truncated = {"__all__": False}
        ep_len = 0
        total_rewards = {agent_id: 0 for agent_id in env.unwrapped.possible_agents}
        
        if not hasattr(algo.config, "policy_mapping_fn"):
            raise AttributeError("Could not find 'policy_mapping_fn' in the algorithm's config. "
                                 "Please check train_marl.py.")
        policy_map_fn = algo.config.policy_mapping_fn

        while not terminated["__all__"] and not truncated["__all__"]:
            env.render()
            
            viewer = env.unwrapped.viewer
            if viewer and viewer.window and viewer.window.has_exit:
                raise UserInterrupt("Render window was closed.")
            
            actions = {}
            active_agents = obs.keys()

            for agent_id in active_agents:
                policy_id = policy_map_fn(agent_id, episode=None)
                module = algo.get_module(policy_id)
                obs_tensor = torch.from_numpy(obs[agent_id]).unsqueeze(0)
                with torch.no_grad():
                    action_dist_inputs = module.forward_inference({"obs": obs_tensor})['action_dist_inputs']
                mean, _ = torch.chunk(action_dist_inputs, 2, dim=-1)
                actions[agent_id] = mean.squeeze(0).cpu().numpy()

            obs, reward, terminated, truncated, info = env.step(actions)

            for agent_id, r in reward.items():
                if agent_id in total_rewards:
                    total_rewards[agent_id] += r

            ep_len += 1
            if not args.fast_forward:
                time.sleep(1.0 / 60.0)

        print(f"Episode finished. Rewards: {total_rewards}, Length: {ep_len}")

    env.close()

def main(args: argparse.Namespace):
    """Unified main function, autodetects the framework and calls the corresponding handler."""
    print(f"--- Starting model playback ---\nPath: {args.model_path}\n--------------------")

    framework = args.framework
    if framework == 'auto':
        if os.path.isdir(args.model_path):
            framework = 'rllib'
        elif os.path.isfile(args.model_path) and args.model_path.lower().endswith('.zip'):
            framework = 'sb3'
        else:
            print(f"ERROR: Could not autodetect framework from path '{args.model_path}'.")
            sys.exit(1)

    try:
        if framework == 'sb3':
            _watch_sb3(args)
        elif framework == 'rllib':
            _watch_rllib(args)
    except (KeyboardInterrupt, UserInterrupt) as e:
        print(f"\nPlayback stopped by user: {e}")
    except Exception as e:
        print(f"\nAn unexpected error occurred: {e}")
        import traceback
        traceback.print_exc()
    finally:
        if __name__ == "__main__" and ray.is_initialized():
            ray.shutdown()
        print("Environment closed and resources cleaned up.")

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Watch a trained agent (supports SB3 and RLlib).")
    parser = add_watch_args(parser)
    args = parser.parse_args()
    main(args)

===== .\scripts\__init__.py =====


===== .\TeachMyAgent\__init__.py =====


===== .\TeachMyAgent\environments\__init__.py =====
from gymnasium.envs.registration import register

register(
    id='parametric-continuous-stump-tracks-v0',
    entry_point='TeachMyAgent.environments.envs.parametric_continuous_stump_tracks:ParametricContinuousStumpTracks'
)

register(
    id='parametric-continuous-parkour-v0',
    entry_point='TeachMyAgent.environments.envs.parametric_continuous_parkour:ParametricContinuousParkour'
)
register(
    id='multi-agent-parkour-v0',
    entry_point='TeachMyAgent.environments.envs.multi_agent_parametric_parkour:MultiAgentParkour'
)

===== .\TeachMyAgent\environments\envs\interactive_multi_agent_parkour.py =====
# TeachMyAgent/environments/envs/interactive_multi_agent_parkour.py

import math
import numpy as np
import gymnasium as gym
import Box2D
from Box2D.b2 import circleShape, polygonShape, fixtureDef, revoluteJointDef, prismaticJointDef
from ray.rllib.env.multi_agent_env import MultiAgentEnv

from .parametric_continuous_parkour import (
    ParametricContinuousParkour, LidarCallback,
    SCALE, FPS, VIEWPORT_W, VIEWPORT_H, NB_LIDAR, LIDAR_RANGE,
    TERRAIN_STEP, TERRAIN_LENGTH, TERRAIN_END, INITIAL_RANDOM,
    TERRAIN_HEIGHT, WATER_DENSITY
)
from .utils.custom_user_data import CustomUserDataObjectTypes, CustomBodyUserData, CustomUserData

from TeachMyAgent.environments.envs.bodies.BodiesEnum import BodiesEnum
from TeachMyAgent.environments.envs.bodies.BodyTypesEnum import BodyTypesEnum

DOOR_BUTTON_X_POS = TERRAIN_STEP * (TERRAIN_LENGTH / 4)
DOOR_WIDTH = TERRAIN_STEP * 2
DOOR_HEIGHT = TERRAIN_HEIGHT / 2
BUTTON_WIDTH = TERRAIN_STEP
BUTTON_HEIGHT = 0.5

class InteractiveMultiAgentParkour(ParametricContinuousParkour, MultiAgentEnv):
    """Interactive multi-agent parkour environment."""
    def __init__(self, config: dict):
        self.n_agents = config.get("n_agents", 2)
        self.agent_body_type = config.get("agent_body_type", "classic_bipedal")
        self.horizon = config.get("horizon", 1500)
        self.reward_type = config.get("reward_type", "individual")
        self.ts = 0

        parent_config = config.copy()
        parent_config.pop("n_agents", None)
        
        temp_env_config = parent_config.copy()
        temp_env_config.pop("render_mode", None)
        temp_env_config.pop("reward_type", None) 
        
        temp_env = ParametricContinuousParkour(**temp_env_config)
        single_action_space = temp_env.action_space
        single_observation_space_original = temp_env.observation_space
        temp_env.close()

        parent_config.pop("reward_type", None)

        ParametricContinuousParkour.__init__(self, **parent_config)
        MultiAgentEnv.__init__(self)
        
        self.agent_bodies = {}
        self.prev_shapings = {}
        self.possible_agents = [f"agent_{i}" for i in range(self.n_agents)]
        self._agent_ids = set(self.possible_agents)
        self.agents = []
        
        self.button = None; self.door = None; self.door_joint = None
        self.button_pressed = False

        self.action_space = gym.spaces.Dict({i: single_action_space for i in self.possible_agents})

        original_obs_size = single_observation_space_original.shape[0]
        other_agents_obs_size = (self.n_agents - 1) * 2 + 4
        single_obs_shape = (original_obs_size + other_agents_obs_size,)
        high = np.array([np.inf] * single_obs_shape[0], dtype=np.float32)
        single_observation_space = gym.spaces.Box(-high, high, dtype=np.float32)
        self.observation_space = gym.spaces.Dict({i: single_observation_space for i in self.possible_agents})
        
        self._obs_space_in_preferred_format = True
        self._action_space_in_preferred_format = True

    def _destroy(self):
        if not self.world: return
        self.world.contactListener = None
        if self.terrain:
            for t in self.terrain:
                if t: self.world.DestroyBody(t)
        self.terrain = []
        if self.button: self.world.DestroyBody(self.button); self.button = None
        if self.door: self.world.DestroyBody(self.door); self.door = None
        self.door_joint = None
        self._destroy_agents()
    
    def _generate_coop_mechanism(self):
        button_y = self.terrain_ground_y[int(DOOR_BUTTON_X_POS / TERRAIN_STEP)] + BUTTON_HEIGHT/2
        self.button = self.world.CreateStaticBody(position=(DOOR_BUTTON_X_POS - 5, button_y),
                                                  shapes=polygonShape(box=(BUTTON_WIDTH/2, BUTTON_HEIGHT/2)),
                                                  userData=CustomUserData("button", CustomUserDataObjectTypes.TERRAIN))
        self.button.color1, self.button.color2 = (0.9, 0.1, 0.1), (0.7, 0.1, 0.1)

        door_anchor = self.world.CreateStaticBody(position=(DOOR_BUTTON_X_POS, TERRAIN_HEIGHT + DOOR_HEIGHT))
        self.door = self.world.CreateDynamicBody(position=(DOOR_BUTTON_X_POS, TERRAIN_HEIGHT + DOOR_HEIGHT / 2),
                                                 fixtures=fixtureDef(shape=polygonShape(box=(DOOR_WIDTH/2, DOOR_HEIGHT/2)), density=5.0, friction=0.5),
                                                 userData=CustomUserData("door", CustomUserDataObjectTypes.TERRAIN))
        self.door.color1, self.door.color2 = (0.2, 0.2, 0.8), (0.1, 0.1, 0.6)

        self.door_joint = self.world.CreatePrismaticJoint(bodyA=door_anchor, bodyB=self.door, anchor=(DOOR_BUTTON_X_POS, TERRAIN_HEIGHT + DOOR_HEIGHT),
                                                          axis=(0, 1), lowerTranslation=0, upperTranslation=DOOR_HEIGHT * 1.5,
                                                          enableLimit=True, maxMotorForce=2000.0, motorSpeed=0.0, enableMotor=True)

    def _generate_agent(self): pass

    def _destroy_agents(self):
        if not self.agent_bodies: return
        for agent_id, body in self.agent_bodies.items():
            if body: body.destroy(self.world)
        self.agent_bodies = {}

    # START FIX: Add a safe method to destroy specific agent bodies during simulation
    def _destroy_agents_in_simulation(self, agent_ids_to_destroy):
        """Safely destroys the bodies of terminated agents."""
        if not agent_ids_to_destroy:
            return
        for agent_id in agent_ids_to_destroy:
            if agent_id in self.agent_bodies and self.agent_bodies[agent_id]:
                self.agent_bodies[agent_id].destroy(self.world)
                self.agent_bodies[agent_id] = None # Mark as destroyed
    # END FIX

    def _generate_agents(self):
        self._destroy_agents()
        self.agent_bodies = {}
        body_params = {'scale': SCALE}
        body_type = BodiesEnum.get_body_type(self.agent_body_type)
        if body_type in [BodyTypesEnum.SWIMMER, BodyTypesEnum.AMPHIBIAN]:
            body_params['density'] = WATER_DENSITY
        for i in range(self.n_agents):
            agent_id = f"agent_{i}"
            body = BodiesEnum[self.agent_body_type].value(**body_params)
            self.agent_bodies[agent_id] = body
            init_x = (TERRAIN_STEP * self.TERRAIN_STARTPAD / 2) + i * 2.5
            init_y = self.terrain_ground_y[int(self.TERRAIN_STARTPAD / 2)] + body.AGENT_CENTER_HEIGHT
            body.draw(self.world, init_x, init_y, self.np_random.uniform(-INITIAL_RANDOM, INITIAL_RANDOM))

    def reset(self, *, seed=None, options=None):
        super(ParametricContinuousParkour, self).reset(seed=seed)
        self._destroy()
        
        self.ts = 0; self.world = Box2D.b2World(contactListener=self.contact_listener); self.world.contactListener = self.contact_listener
        if self.contact_listener: self.contact_listener.Reset()
        self.critical_contact = False; self.prev_shapings = {agent_id: None for agent_id in self.possible_agents}
        self.scroll = [0.0, 0.0]; self.water_y = self.GROUND_LIMIT; self.lidar = [LidarCallback(None) for _ in range(NB_LIDAR)] 

        self._generate_terrain(); self._generate_coop_mechanism(); self._generate_agents()
        
        self.agents = list(self.possible_agents); self.drawlist = self.terrain.copy()
        if self.button: self.drawlist.append(self.button)
        if self.door: self.drawlist.append(self.door)
        for body in self.agent_bodies.values(): self.drawlist += body.get_elements_to_render()
        self.terminateds = {agent_id: False for agent_id in self.possible_agents}; self.truncateds = {agent_id: False for agent_id in self.possible_agents}
        self.terminateds["__all__"] = False; self.truncateds["__all__"] = False
        
        return self._get_obs(), {}

    def step(self, action_dict):
        self.ts += 1

        # Handle button/door mechanism
        self.button_pressed = False
        if self.button:
            for agent_id in self.agents:
                body = self.agent_bodies[agent_id]
                if body: # Check if body exists
                    for part in body.body_parts:
                        for contact in part.contacts:
                            if contact.other == self.button: self.button_pressed = True; break
                        if self.button_pressed: break
                if self.button_pressed: break
        
        if self.door_joint: self.door_joint.motorSpeed = 5.0 if self.button_pressed else -5.0

        # Apply actions
        for agent_id, action in action_dict.items():
            if agent_id in self.agents and self.agent_bodies.get(agent_id) and action is not None and len(action) > 0:
                self.agent_bodies[agent_id].activate_motors(action)

        # Step physics world
        self.world.Step(1.0 / FPS, 6 * 30, 2 * 30)
        
        rewards = {}
        positions = {aid: self.agent_bodies[aid].reference_head_object.position for aid in self.agents if self.agent_bodies.get(aid)}
        if positions:
            leading_agent_pos_x = max(p[0] for p in positions.values()); avg_agent_pos_y = sum(p[1] for p in positions.values()) / len(positions)
            self.scroll = [leading_agent_pos_x - self.rendering_viewer_w / SCALE / 5, avg_agent_pos_y - self.rendering_viewer_h / SCALE / 2.5]
            
        # START FIX: Improved termination logic for stability
        agents_terminated_this_step = []
        active_agents_before_step = list(self.agents)

        # Calculate rewards and check for termination conditions
        for agent_id in active_agents_before_step:
            body = self.agent_bodies.get(agent_id)
            if not body:
                continue

            # Calculate rewards (individual or shared)
            if self.reward_type == "individual":
                pos = body.reference_head_object.position
                shaping = 130 * pos[0] / SCALE
                reward = 0
                if self.prev_shapings.get(agent_id) is not None:
                    reward = shaping - self.prev_shapings[agent_id]
                self.prev_shapings[agent_id] = shaping
                reward += 0.01
                if agent_id in action_dict and action_dict[agent_id] is not None:
                    for a in action_dict[agent_id]:
                        reward -= body.TORQUE_PENALTY * 20 * np.clip(np.abs(a), 0, 1)
                rewards[agent_id] = reward
            
            # Check for individual agent termination
            pos = body.reference_head_object.position
            agent_critical_contact = False
            for part in body.body_parts:
                 if isinstance(part.userData, CustomBodyUserData) and part.userData.is_contact_critical and part.userData.has_contact:
                     is_door_contact = False
                     if self.door:
                        for contact in part.contacts:
                            if contact.other == self.door: is_door_contact = True; break
                     if not is_door_contact: agent_critical_contact = True; break
            
            if agent_critical_contact or pos[0] < 0:
                rewards[agent_id] = -100
                self.terminateds[agent_id] = True
            if pos[0] > (TERRAIN_LENGTH + self.TERRAIN_STARTPAD - TERRAIN_END) * TERRAIN_STEP:
                self.terminateds[agent_id] = True
            
            if self.terminateds.get(agent_id, False):
                agents_terminated_this_step.append(agent_id)

        if self.reward_type == "shared":
            agent_progress = []
            for agent_id in active_agents_before_step:
                body = self.agent_bodies.get(agent_id)
                if body:
                    pos = body.reference_head_object.position
                    shaping = 130 * pos[0] / SCALE
                    progress = 0
                    if self.prev_shapings.get(agent_id) is not None:
                        progress = shaping - self.prev_shapings[agent_id]
                    self.prev_shapings[agent_id] = shaping
                    agent_progress.append(progress)
            
            shared_reward = min(agent_progress) if agent_progress else 0
            total_torque_penalty = 0
            for agent_id in active_agents_before_step:
                 body = self.agent_bodies.get(agent_id)
                 if body and agent_id in action_dict and action_dict[agent_id] is not None:
                    for a in action_dict[agent_id]:
                        total_torque_penalty += body.TORQUE_PENALTY * 20 * np.clip(np.abs(a), 0, 1)

            num_active = len(active_agents_before_step)
            avg_torque_penalty = total_torque_penalty / num_active if num_active > 0 else 0
            final_reward = shared_reward - avg_torque_penalty + 0.01
            for agent_id in active_agents_before_step:
                rewards[agent_id] = final_reward
        
        # Safely remove terminated agents from simulation and active list
        if agents_terminated_this_step:
            self._destroy_agents_in_simulation(agents_terminated_this_step)
            for agent_id in agents_terminated_this_step:
                if agent_id in self.agents:
                    self.agents.remove(agent_id)
        
        is_truncated = self.ts >= self.horizon
        all_done = not self.agents or is_truncated
        self.terminateds["__all__"] = all_done and not is_truncated
        self.truncateds["__all__"] = is_truncated
        # END FIX

        obs = self._get_obs()
        return obs, rewards, self.terminateds, self.truncateds, {}

    def _get_obs(self):
        all_obs = {}
        agent_positions = {aid: body.reference_head_object.position for aid, body in self.agent_bodies.items() if body}
        
        for agent_id in self.agents:
            body = self.agent_bodies.get(agent_id)
            if not body: continue # Skip terminated agents

            head = body.reference_head_object
            vel = head.linearVelocity
            my_pos = agent_positions[agent_id]

            for lidar_callback in self.lidar:
                lidar_callback.agent_mask_filter = head.fixtures[0].filterData.maskBits

            for i in range(NB_LIDAR):
                self.lidar[i].fraction = 1.0
                self.lidar[i].p1 = head.position
                self.lidar[i].p2 = (head.position[0] + math.sin((self.lidar_angle * i / NB_LIDAR) + self.lidar_y_offset) * LIDAR_RANGE,
                                   head.position[1] - math.cos((self.lidar_angle * i / NB_LIDAR) + self.lidar_y_offset) * LIDAR_RANGE)
                self.world.RayCast(self.lidar[i], self.lidar[i].p1, self.lidar[i].p2)

            is_under_water = head.position.y <= self.water_y
            state = [head.angle, 2.0 * head.angularVelocity / FPS, 0.3 * vel.x * (VIEWPORT_W / SCALE) / FPS,
                     0.3 * vel.y * (VIEWPORT_H / SCALE) / FPS, 1.0 if is_under_water else 0.0, 0.0]
            state.extend(body.get_motors_state())
            if body.body_type == BodyTypesEnum.CLIMBER: state.extend(body.get_sensors_state())
            
            for lidar in self.lidar: state.append(lidar.fraction)
            for lidar in self.lidar:
                if lidar.is_water_detected: state.append(-1)
                elif lidar.is_creeper_detected: state.append(1)
                else: state.append(0)
            
            original_obs = np.array(state)
            
            other_agents_pos = []
            for other_id in self.possible_agents:
                if other_id != agent_id:
                    if other_id in agent_positions: # Check if other agent is still active
                        other_pos = agent_positions[other_id]
                        relative_pos = (np.array(other_pos) - np.array(my_pos)) / (LIDAR_RANGE * 2)
                        other_agents_pos.extend(relative_pos.tolist())
                    else:
                        other_agents_pos.extend([0.0, 0.0])

            coop_mechanism_obs = []
            if self.door: coop_mechanism_obs.extend(((np.array(self.door.position) - np.array(my_pos)) / (LIDAR_RANGE*2)).tolist())
            else: coop_mechanism_obs.extend([0.0, 0.0])
            if self.button: coop_mechanism_obs.extend(((np.array(self.button.position) - np.array(my_pos)) / (LIDAR_RANGE*2)).tolist())
            else: coop_mechanism_obs.extend([0.0, 0.0])

            final_obs = np.concatenate([original_obs, np.array(other_agents_pos), np.array(coop_mechanism_obs)])
            all_obs[agent_id] = final_obs.astype(np.float32)
            
        return all_obs
    
    def render(self, draw_lidars=True):
        from TeachMyAgent.environments.envs.utils import rendering
        if self.viewer is None and self.render_mode is not None:
            self.viewer = rendering.Viewer(self.rendering_viewer_w, self.rendering_viewer_h, visible=(self.render_mode == 'human'))
        
        if self.viewer is None or self.viewer.window is None or self.viewer.window.has_exit:
            if self.render_mode == 'rgb_array':
                return np.zeros((self.rendering_viewer_h, self.rendering_viewer_w, 3), dtype=np.uint8)
            return None

        self.viewer.set_bounds(self.scroll[0], self.rendering_viewer_w / SCALE + self.scroll[0],
                               self.scroll[1], self.rendering_viewer_h / SCALE + self.scroll[1])
        
        self.viewer.draw_polygon([
            (self.scroll[0], self.scroll[1]),
            (self.scroll[0] + self.rendering_viewer_w / SCALE, self.scroll[1]),
            (self.scroll[0] + self.rendering_viewer_w / SCALE, self.scroll[1] + self.rendering_viewer_h / SCALE),
            (self.scroll[0], self.scroll[1] + self.rendering_viewer_h / SCALE),
        ], color=(0.9, 0.9, 1.0))

        for poly, x1, x2 in self.cloud_poly:
            if x2 < self.scroll[0] / 2 or x1 > self.scroll[0] / 2 + self.rendering_viewer_w / SCALE:
                continue
            self.viewer.draw_polygon([(p[0] + self.scroll[0] / 2, p[1]) for p in poly], color=(1, 1, 1))

        for obj in self.drawlist:
            # Check if object still exists in the physics world before rendering
            if not obj or not obj.valid:
                continue

            is_an_agent_head = False
            for agent_id, body in self.agent_bodies.items():
                if body and obj == body.reference_head_object:
                    is_an_agent_head = True
                    break
            
            color1, color2 = obj.color1, obj.color2
            if hasattr(obj.userData, 'object_type') and obj.userData.object_type == CustomUserDataObjectTypes.BODY_SENSOR and hasattr(obj.userData, 'has_joint') and obj.userData.has_joint:
                color1, color2 = (1.0, 1.0, 0.0), (1.0, 1.0, 0.0)
            elif is_an_agent_head:
                pass

            for f in obj.fixtures:
                trans = f.body.transform
                if type(f.shape) is circleShape:
                    t = rendering.Transform(translation=trans * f.shape.pos)
                    self.viewer.draw_circle(f.shape.radius, 30, color=color1).add_attr(t)
                    self.viewer.draw_circle(f.shape.radius, 30, color=color2, filled=False, linewidth=2).add_attr(t)
                else:
                    path = [trans * v for v in f.shape.vertices]
                    self.viewer.draw_polygon(path, color=color1)
                    path.append(path[0])
                    self.viewer.draw_polyline(path, color=color2, linewidth=2)

        for poly, color in self.terrain_poly:
            if len(poly) < 2 or poly[1][0] < self.scroll[0] or poly[0][0] > self.scroll[0] + self.rendering_viewer_w / SCALE:
                continue
            self.viewer.draw_polygon(poly, color=color)

        if draw_lidars and hasattr(self, 'lidar'):
            for i in range(len(self.lidar)):
                l = self.lidar[i]
                self.viewer.draw_polyline([l.p1, l.p2], color=(1, 0, 0), linewidth=1)

        flagy1 = TERRAIN_HEIGHT
        flagy2 = flagy1 + 50 / SCALE
        x = TERRAIN_STEP * 3
        self.viewer.draw_polyline([(x, flagy1), (x, flagy2)], color=(0, 0, 0), linewidth=2)
        f = [(x, flagy2), (x, flagy2 - 10 / SCALE), (x + 25 / SCALE, flagy2 - 5 / SCALE)]
        self.viewer.draw_polygon(f, color=(0.9, 0.2, 0))
        self.viewer.draw_polyline(f + [f[0]], color=(0, 0, 0), linewidth=2)

        return self.viewer.render(return_rgb_array=self.render_mode == 'rgb_array')

===== .\TeachMyAgent\environments\envs\LidarCallback_class.py =====
# TeachMyAgent/environments/envs/LidarCallback_class.py
import Box2D
from .utils.custom_user_data import CustomUserDataObjectTypes

class LidarCallback(Box2D.b2.rayCastCallback):
    '''
        Callback function triggered when lidar detects an object.
    '''
    def __init__(self, agent_mask_filter):
        Box2D.b2.rayCastCallback.__init__(self)
        self.agent_mask_filter = agent_mask_filter
        self.fixture = None
        self.is_water_detected = False
        self.is_creeper_detected = False
    def ReportFixture(self, fixture, point, normal, fraction):
        if (fixture.filterData.categoryBits & self.agent_mask_filter) == 0:
            return -1
        self.p2 = point
        self.fraction = fraction
        self.is_water_detected = True if fixture.body.userData.object_type == CustomUserDataObjectTypes.WATER else False
        self.is_creeper_detected = True if fixture.body.userData.object_type == CustomUserDataObjectTypes.SENSOR_GRIP_TERRAIN else False
        return fraction

===== .\TeachMyAgent\environments\envs\multi_agent_parametric_parkour.py =====
import numpy as np
import gymnasium as gym
from gymnasium import spaces
from ray.rllib.env.multi_agent_env import MultiAgentEnv

from .parametric_continuous_parkour import ParametricContinuousParkour
from .bodies.BodiesEnum import BodiesEnum
from .bodies.BodyTypesEnum import BodyTypesEnum
from .parametric_continuous_parkour import WATER_DENSITY

class MultiAgentParkour(MultiAgentEnv):
    _single_observation_space: gym.Space
    _single_action_space: gym.Space

    def __init__(self, config: dict):
        super().__init__()
        self.n_agents = config.get("n_agents", 2)
        self.render_mode = config.get("render_mode", None)

        sub_env_config = config.copy()
        sub_env_config.pop("n_agents", None)
        sub_env_config.pop("render_mode", None)

        body_type = BodiesEnum.get_body_type(sub_env_config.get("agent_body_type", "classic_bipedal"))
        if body_type in [BodyTypesEnum.SWIMMER, BodyTypesEnum.AMPHIBIAN]:
            sub_env_config['density'] = WATER_DENSITY

        tmp_env = ParametricContinuousParkour(**sub_env_config)
        self._single_observation_space = tmp_env.observation_space
        self._single_action_space = tmp_env.action_space
        tmp_env.close()

        self._agent_ids = {f"agent_{i}" for i in range(self.n_agents)}
        self.possible_agents = list(self._agent_ids)
        
        self.observation_space = gym.spaces.Dict({i: self._single_observation_space for i in self.possible_agents})
        self.action_space = gym.spaces.Dict({i: self._single_action_space for i in self.possible_agents})
        self.envs = [ParametricContinuousParkour(**sub_env_config) for _ in range(self.n_agents)]

        self._terminateds = set()
        self._truncateds = set()

        if self.render_mode == "human":
            self.envs[0].render_mode = "human"
            for i in range(1, self.n_agents):
                self.envs[i].render_mode = None

    def reset(self, *, seed=None, options=None):
        self._terminateds.clear()
        self._truncateds.clear()
        obs, infos = {}, {}
        for i, agent_id in enumerate(self.possible_agents):
            agent_seed = seed + i if seed is not None else None
            obs[agent_id], infos[agent_id] = self.envs[i].reset(seed=agent_seed, options=options)
        return obs, infos

    def step(self, action_dict):
        obs, rewards, terminateds, truncateds, infos = {}, {}, {}, {}, {}
        for agent_id, action in action_dict.items():
            idx = int(agent_id.split("_")[1])
            o, r, term, trunc, info = self.envs[idx].step(action)
            obs[agent_id] = o
            rewards[agent_id] = r
            terminateds[agent_id] = term
            truncateds[agent_id] = trunc
            infos[agent_id] = info
            if term: self._terminateds.add(agent_id)
            if trunc: self._truncateds.add(agent_id)

        all_done = len(self._terminateds) + len(self._truncateds) == self.n_agents
        terminateds["__all__"] = all_done
        truncateds["__all__"] = all_done
        return obs, rewards, terminateds, truncateds, infos

    def render(self):
        if self.render_mode == "human":
            return self.envs[0].render()

    def close(self):
        for env in self.envs:
            env.close()


===== .\TeachMyAgent\environments\envs\parametric_continuous_parkour.py =====
# TeachMyAgent/environments/envs/parametric_continuous_parkour.py
import math
import os

import Box2D
import gymnasium as gym
import numpy as np
from Box2D.b2 import (edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef)
from gymnasium import spaces
from gymnasium.utils import seeding, EzPickle

from TeachMyAgent.environments.envs.Box2D_dynamics.water_dynamics import WaterDynamics, WaterContactDetector
from TeachMyAgent.environments.envs.Box2D_dynamics.climbing_dynamics import ClimbingDynamics, ClimbingContactDetector
from TeachMyAgent.environments.envs.PCGAgents.CPPN.cppn_pytorch import CPPN_Pytorch
from TeachMyAgent.environments.envs.bodies.BodiesEnum import BodiesEnum
from TeachMyAgent.environments.envs.bodies.BodyTypesEnum import BodyTypesEnum
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomUserDataObjectTypes, CustomUserData

class ContactDetector(WaterContactDetector, ClimbingContactDetector):
    def __init__(self, env):
        super(ContactDetector, self).__init__()
        self.env = env

    def BeginContact(self, contact):
        bodies = [contact.fixtureA.body, contact.fixtureB.body]

        if any([hasattr(body.userData, 'object_type') and body.userData.object_type == CustomUserDataObjectTypes.WATER for body in bodies]):
            WaterContactDetector.BeginContact(self, contact)
        elif any([hasattr(body.userData, 'object_type') and body.userData.object_type == CustomUserDataObjectTypes.BODY_SENSOR for body in bodies]):
            ClimbingContactDetector.BeginContact(self, contact)
        else:
            if contact.fixtureA.sensor or contact.fixtureB.sensor:
                return
            for idx, body in enumerate(bodies):
                if (hasattr(body.userData, 'object_type') and
                    body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT and
                    body.userData.check_contact):
                    body.userData.has_contact = True
                    other_body = bodies[(idx + 1) % 2]
                    if body.userData.is_contact_critical and \
                            not (hasattr(other_body.userData, 'object_type') and
                                 other_body.userData.object_type in [CustomUserDataObjectTypes.GRIP_TERRAIN, CustomUserDataObjectTypes.SENSOR_GRIP_TERRAIN] and
                                 self.env.agent_body.body_type == BodyTypesEnum.CLIMBER):
                        self.env.critical_contact = True

    def EndContact(self, contact):
        fA, fB = contact.fixtureA, contact.fixtureB
        if (not hasattr(fA, 'body') or not hasattr(fB, 'body') or
                fA.body is None or fB.body is None or
                not hasattr(fA.body, 'userData') or not hasattr(fB.body, 'userData') or
                fA.body.userData is None or fB.body.userData is None):
            return

        bodies = [fA.body, fB.body]

        if any([body.userData.object_type == CustomUserDataObjectTypes.WATER for body in bodies]):
            WaterContactDetector.EndContact(self, contact)
        elif any([body.userData.object_type == CustomUserDataObjectTypes.BODY_SENSOR for body in bodies]):
            ClimbingContactDetector.EndContact(self, contact)
        else:
            for body in bodies:
                if (hasattr(body.userData, 'object_type') and
                        body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT and
                        body.userData.check_contact):
                    body.userData.has_contact = False

    def Reset(self):
        WaterContactDetector.Reset(self)
        ClimbingContactDetector.Reset(self)

class LidarCallback(Box2D.b2.rayCastCallback):
    def __init__(self, agent_mask_filter):
        Box2D.b2.rayCastCallback.__init__(self)
        self.agent_mask_filter = agent_mask_filter
        self.fixture = None
        self.is_water_detected = False
        self.is_creeper_detected = False

    def ReportFixture(self, fixture, point, normal, fraction):
        if (fixture.filterData.categoryBits & self.agent_mask_filter) == 0:
            return -1
        self.p2 = point
        self.fraction = fraction
        if hasattr(fixture.body.userData, 'object_type'):
            self.is_water_detected = fixture.body.userData.object_type == CustomUserDataObjectTypes.WATER
            self.is_creeper_detected = fixture.body.userData.object_type == CustomUserDataObjectTypes.SENSOR_GRIP_TERRAIN
        return fraction

FPS    = 50
SCALE  = 30.0
VIEWPORT_W = 600
VIEWPORT_H = 400
NB_LIDAR = 10
LIDAR_RANGE   = 160/SCALE
INITIAL_RANDOM = 5
TERRAIN_STEP   = 14/SCALE
TERRAIN_LENGTH = 200
TERRAIN_HEIGHT = VIEWPORT_H/SCALE/4
TERRAIN_END    = 5
INITIAL_TERRAIN_STARTPAD = 20
FRICTION = 2.5
WATER_DENSITY = 1.0
HULL_CONTACT_PENALTY = 0.1

class ParametricContinuousParkour(gym.Env, EzPickle):
    metadata = {'render_modes': ['human', 'rgb_array'], 'render_fps': FPS}

    def __init__(self, agent_body_type: str, CPPN_weights_path: str = None, input_CPPN_dim: int = 3,
                 terrain_cppn_scale: int = 10, ceiling_offset: int = 200, ceiling_clip_offset: int = 0,
                 lidars_type: str = 'full', water_clip: int = 20, movable_creepers: bool = False,
                 render_mode: str = None, horizon: int = 3000, flip_termination_steps: int = 50, **walker_args):

        super().__init__()
        self.rendering_viewer_w = VIEWPORT_W
        self.rendering_viewer_h = VIEWPORT_H
        self.render_mode = render_mode
        self.horizon = horizon
        self.ts = 0
        self.flip_termination_steps = flip_termination_steps

        self.np_random = None
        if lidars_type == "down":
            self.lidar_angle = 1.5; self.lidar_y_offset = 0
        elif lidars_type == "up":
            self.lidar_angle = 2.3; self.lidar_y_offset = 1.5
        else:
            self.lidar_angle = np.pi; self.lidar_y_offset = 0

        self.seed()
        self.viewer = None
        self.contact_listener = ContactDetector(self)
        self.world = Box2D.b2World(contactListener=self.contact_listener)
        self.movable_creepers = movable_creepers

        body_type = BodiesEnum.get_body_type(agent_body_type)
        if body_type in [BodyTypesEnum.SWIMMER, BodyTypesEnum.AMPHIBIAN]:
            self.agent_body = BodiesEnum[agent_body_type].value(SCALE, **walker_args)
        elif body_type == BodyTypesEnum.WALKER:
            self.agent_body = BodiesEnum[agent_body_type].value(SCALE, **walker_args, reset_on_hull_critical_contact=True)
        else:
            self.agent_body = BodiesEnum[agent_body_type].value(SCALE, **walker_args)

        self.terrain = []
        self.water_dynamics = WaterDynamics(self.world.gravity, max_push=water_clip)
        self.climbing_dynamics = ClimbingDynamics()
        self.prev_shaping = None
        self.episodic_reward = 0

        self.TERRAIN_STARTPAD = max(INITIAL_TERRAIN_STARTPAD, self.agent_body.AGENT_WIDTH / TERRAIN_STEP + 5)
        self._create_terrain_fixtures()

        self.input_CPPN_dim = input_CPPN_dim
        self.terrain_CPPN = CPPN_Pytorch(x_dim=TERRAIN_LENGTH, input_dim=input_CPPN_dim, output_dim=2)
        weights_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "PCGAgents/CPPN/weights/same_ground_ceiling_cppn_pytorch.pt")
        self.terrain_CPPN.load_tf_weights(weights_path)

        self.set_terrain_cppn_scale(terrain_cppn_scale, ceiling_offset, ceiling_clip_offset)

        default_params = {"input_vector": np.array([-0.25, 0.8, 0.0]), "water_level": 0.1,
                          "creepers_width": 0.25, "creepers_height": 2.0, "creepers_spacing": 1.5}
        self.set_environment(**default_params)

        self._generate_agent()

        agent_action_size = self.agent_body.get_action_size()
        self.action_space = spaces.Box(np.array([-1]*agent_action_size), np.array([1]*agent_action_size), dtype=np.float32)

        total_obs_size = 6 + NB_LIDAR*2 + len(self.agent_body.get_motors_state())
        if self.agent_body.body_type == BodyTypesEnum.CLIMBER:
            total_obs_size += len(self.agent_body.get_sensors_state())
        high = np.array([np.inf]*total_obs_size)
        self.observation_space = spaces.Box(-high, high, dtype=np.float32)

    def _create_terrain_fixtures(self):
        self.fd_polygon = fixtureDef(shape=polygonShape(vertices=[(0,0),(1,0),(1,-1),(0,-1)]), friction=FRICTION)
        self.fd_edge = fixtureDef(shape=edgeShape(vertices=[(0,0),(1,1)]), friction=FRICTION)
        self.fd_water = fixtureDef(shape=polygonShape(vertices=[(0,0),(1,0),(1,-1),(0,-1)]), density=WATER_DENSITY, isSensor=True)
        self.fd_creeper = fixtureDef(shape=polygonShape(vertices=[(0,0),(1,0),(1,-1),(0,-1)]), density=5.0, isSensor=True)

    def _generate_agent(self):
        init_x = TERRAIN_STEP*self.TERRAIN_STARTPAD/2

        if self.agent_body.body_type == BodyTypesEnum.CLIMBER:
            spawn_margin = 0.5
            init_y = TERRAIN_HEIGHT + self.ceiling_offset - (self.agent_body.AGENT_HEIGHT / 2) - spawn_margin
        else:
            spawn_buffer = 0.5
            if hasattr(self, 'terrain_ground_y') and len(self.terrain_ground_y) > int(self.TERRAIN_STARTPAD / 2):
                ground_y = self.terrain_ground_y[int(self.TERRAIN_STARTPAD / 2)]
            else:
                ground_y = TERRAIN_HEIGHT
            init_y = ground_y + self.agent_body.AGENT_CENTER_HEIGHT + spawn_buffer

        self.agent_body.draw(
            self.world,
            init_x,
            init_y,
            self.np_random.uniform(-INITIAL_RANDOM, INITIAL_RANDOM)
        )

    def seed(self, seed=None):
        self.np_random, seed = seeding.np_random(seed)
        return [seed]

    def set_terrain_cppn_scale(self, terrain_cppn_scale, ceiling_offset, ceiling_clip_offset):
        assert terrain_cppn_scale > 1
        self.TERRAIN_CPPN_SCALE = terrain_cppn_scale
        self.CEILING_LIMIT = 1000 / self.TERRAIN_CPPN_SCALE
        self.GROUND_LIMIT = -1000 / self.TERRAIN_CPPN_SCALE
        self.ceiling_offset = ceiling_offset / self.TERRAIN_CPPN_SCALE
        self.ceiling_clip_offset = ceiling_clip_offset / self.TERRAIN_CPPN_SCALE

    def set_environment(self, input_vector, water_level, creepers_width=None, creepers_height=None, creepers_spacing=0.1, terrain_cppn_scale=10):
        self.CPPN_input_vector = input_vector
        self.water_level = water_level.item() if isinstance(water_level, np.float32) else water_level
        self.water_level = max(0.01, self.water_level)
        self.creepers_width = creepers_width if creepers_width is not None else creepers_width
        self.creepers_height = creepers_height if creepers_height is not None else creepers_height
        self.creepers_spacing = max(0.01, creepers_spacing)
        self.set_terrain_cppn_scale(terrain_cppn_scale, self.ceiling_offset*self.TERRAIN_CPPN_SCALE, self.ceiling_clip_offset*self.TERRAIN_CPPN_SCALE)

    def _destroy(self):
        if not self.world: return
        self.world.contactListener = None
        for t in self.terrain:
            if t: self.world.DestroyBody(t)
        self.terrain = []
        if self.agent_body: self.agent_body.destroy(self.world)

    def _get_state(self):
        head = self.agent_body.reference_head_object; vel = head.linearVelocity; pos = head.position
        for i in range(NB_LIDAR):
            self.lidar[i].fraction = 1.0; self.lidar[i].p1 = pos
            self.lidar[i].p2 = (pos[0] + math.sin((self.lidar_angle * i / NB_LIDAR + self.lidar_y_offset)) * LIDAR_RANGE,
                               pos[1] - math.cos((self.lidar_angle * i / NB_LIDAR) + self.lidar_y_offset) * LIDAR_RANGE)
            self.world.RayCast(self.lidar[i], self.lidar[i].p1, self.lidar[i].p2)
        is_under_water = pos.y <= self.water_y; is_agent_dead = False
        state = [head.angle, 2.0 * head.angularVelocity / FPS, 0.3 * vel.x * (VIEWPORT_W / SCALE) / FPS, 0.3 * vel.y * (VIEWPORT_H / SCALE) / FPS,
                 1.0 if is_under_water else 0.0, 1.0 if is_agent_dead else 0.0]
        state.extend(self.agent_body.get_motors_state())
        if self.agent_body.body_type == BodyTypesEnum.CLIMBER: state.extend(self.agent_body.get_sensors_state())
        surface_dectected = []
        for lidar in self.lidar:
            state.append(lidar.fraction)
            if lidar.is_water_detected: surface_dectected.append(-1)
            elif lidar.is_creeper_detected: surface_dectected.append(1)
            else: surface_dectected.append(0)
        state.extend(surface_dectected)
        return np.array(state, dtype=np.float32)

    def reset(self, seed=None, options=None):
        super().reset(seed=seed)
        self._destroy()
        self.world = Box2D.b2World(contactListener=self.contact_listener)
        self.world.contactListener = self.contact_listener
        if self.contact_listener: self.contact_listener.Reset()

        self.ts = 0; self.critical_contact = False; self.prev_shaping = None
        self.episodic_reward = 0; self.scroll = [0.0, 0.0]; self.lidar_render = 0
        self.water_y = self.GROUND_LIMIT; self.nb_steps_outside_water = 0
        self.nb_steps_under_water = 0; self.flipped_counter = 0

        self.stagnation_counter = 0
        self.last_progress_x = 0

        self._generate_terrain(); self._generate_agent()
        self.drawlist = self.terrain + self.agent_body.get_elements_to_render()
        self.lidar = [LidarCallback(self.agent_body.reference_head_object.fixtures[0].filterData.maskBits) for _ in range(NB_LIDAR)]
        
        if self.agent_body.body_type == BodyTypesEnum.CLIMBER:
            grasp_action = np.ones(self.action_space.shape[0])
            for _ in range(50):
                self.agent_body.activate_motors(grasp_action)
                self.climbing_dynamics.before_step_climbing_dynamics(grasp_action, self.agent_body, self.world)
                self.world.Step(1.0 / FPS, 6 * 30, 2 * 30)
                self.climbing_dynamics.after_step_climbing_dynamics(self.world.contactListener, self.world)
        else:
            WARM_UP_STEPS = 10
            for _ in range(WARM_UP_STEPS):
                self.world.Step(1.0 / FPS, 6 * 30, 2 * 30)

        self.critical_contact = False
        if self.contact_listener: self.contact_listener.Reset()
        for part in self.agent_body.body_parts:
            if hasattr(part.userData, 'has_contact'):
                part.userData.has_contact = False
                
        self.prev_pos_x = self.agent_body.reference_head_object.position.x
        self.last_progress_x = self.prev_pos_x
        
        return self._get_state(), {}

    def step(self, action):
        self.ts += 1
        is_agent_dead = False
        if hasattr(self.agent_body, "nb_steps_can_survive_outside_water") and self.nb_steps_outside_water > self.agent_body.nb_steps_can_survive_outside_water:
            is_agent_dead = True
        if hasattr(self.agent_body, "nb_steps_can_survive_under_water") and self.nb_steps_under_water > self.agent_body.nb_steps_can_survive_under_water:
            is_agent_dead = True
        
        if is_agent_dead: action = np.array([0] * self.action_space.shape[0])

        self.agent_body.activate_motors(action)
        if self.agent_body.body_type == BodyTypesEnum.CLIMBER:
            self.climbing_dynamics.before_step_climbing_dynamics(action, self.agent_body, self.world)
        
        self.world.Step(1.0 / FPS, 6 * 30, 2 * 30)
        
        if self.agent_body.body_type == BodyTypesEnum.CLIMBER:
            self.climbing_dynamics.after_step_climbing_dynamics(self.world.contactListener, self.world)
        
        self.water_dynamics.calculate_forces(self.world.contactListener.fixture_pairs)
        
        state = self._get_state()
        pos = self.agent_body.reference_head_object.position
        vel = self.agent_body.reference_head_object.linearVelocity
        self.scroll = [pos[0] - self.rendering_viewer_w / SCALE / 5, pos[1] - self.rendering_viewer_h / SCALE / 2.5]
        
        # --- REWARD SHAPING REVISION V2 ---
        reward = 0
        
        # 1. Primary Reward: Progress
        shaping = 130 * pos[0] / SCALE 
        if self.prev_shaping is not None:
            reward += shaping - self.prev_shaping
        self.prev_shaping = shaping
        
        # START CHANGE: Heavily incentivize forward velocity
        reward += 0.3 * vel.x
        # END CHANGE

        # 3. Grasping Bonus for climbers
        if self.agent_body.body_type == BodyTypesEnum.CLIMBER:
            num_sensors_touching = 0
            for sensor in self.agent_body.sensors:
                if sensor.userData.has_contact:
                    num_sensors_touching += 1
            reward += 0.02 * num_sensors_touching 

        # 4. Stagnation Penalty
        if abs(pos.x - self.last_progress_x) < 0.01:
            self.stagnation_counter += 1
        else:
            self.stagnation_counter = 0
            self.last_progress_x = pos.x
        
        if self.stagnation_counter > 100:
            reward -= 0.1
        # --- END REWARD SHAPING REVISION V2 ---

        # Penalties
        # START CHANGE: Reduce torque penalty to encourage more powerful movements
        for a in action:
            reward -= self.agent_body.TORQUE_PENALTY * 40 * np.clip(np.abs(a), 0, 1)
        # END CHANGE
        
        hull = self.agent_body.body_parts[0]
        if hasattr(hull.userData, 'has_contact') and hull.userData.has_contact and self.agent_body.body_type == BodyTypesEnum.WALKER:
            reward -= HULL_CONTACT_PENALTY
        
        # Termination conditions
        if abs(state[0]) > 1.5: self.flipped_counter += 1
        else: self.flipped_counter = 0
        
        terminated = False
        if self.flipped_counter > self.flip_termination_steps: reward = -100; terminated = True
        if self.critical_contact or pos[0] < 0 or is_agent_dead: reward = -100; terminated = True
        if pos[0] > (TERRAIN_LENGTH + self.TERRAIN_STARTPAD - TERRAIN_END) * TERRAIN_STEP: terminated = True
        
        self.episodic_reward += reward
        truncated = self.ts >= self.horizon
        
        if self.render_mode == "human": self.render()
        
        info = {"success": self.episodic_reward > 230}
        return state, reward, terminated, truncated, info

    def _generate_terrain(self):
        self.cloud_poly, self.terrain_x, self.terrain_ground_y, self.terrain_ceiling_y, self.terrain_poly, self.terrain = [], [], [], [], [], []
        y = self.terrain_CPPN.generate(self.CPPN_input_vector) / self.TERRAIN_CPPN_SCALE
        ground_y, ceiling_y = y[:, 0], y[:, 1]
        offset = TERRAIN_HEIGHT - ground_y[0]
        ground_y = np.add(ground_y, offset)
        offset = TERRAIN_HEIGHT + self.ceiling_offset - ceiling_y[0]
        ceiling_y = np.add(ceiling_y, offset)
        terrain_creepers = []; water_body = None; x = 0; max_x = TERRAIN_LENGTH * TERRAIN_STEP + self.TERRAIN_STARTPAD * TERRAIN_STEP
        i = 0
        while x < max_x:
            self.terrain_x.append(x)
            if i < self.TERRAIN_STARTPAD:
                self.terrain_ground_y.append(TERRAIN_HEIGHT); self.terrain_ceiling_y.append(TERRAIN_HEIGHT + self.ceiling_offset)
            else:
                self.terrain_ground_y.append(ground_y[i - self.TERRAIN_STARTPAD].item())
                ceiling_val = ceiling_y[i - self.TERRAIN_STARTPAD] if ceiling_y[i - self.TERRAIN_STARTPAD] >= ground_y[i - self.TERRAIN_STARTPAD] + self.ceiling_clip_offset else ground_y[i - self.TERRAIN_STARTPAD] + self.ceiling_clip_offset
                self.terrain_ceiling_y.append(ceiling_val.item())
            x += TERRAIN_STEP; i += 1
        space_from_precedent_creeper = self.creepers_spacing
        for i in range(len(self.terrain_x) - 1):
            poly = [(self.terrain_x[i], self.terrain_ground_y[i]), (self.terrain_x[i + 1], self.terrain_ground_y[i + 1])]
            self.fd_edge.shape.vertices = poly; t = self.world.CreateStaticBody(fixtures=self.fd_edge, userData=CustomUserData("grass", CustomUserDataObjectTypes.TERRAIN))
            color = (0.3, 1.0 if (i % 2) == 0 else 0.8, 0.3); t.color1 = color; t.color2 = color; self.terrain.append(t)
            poly += [(poly[1][0], self.GROUND_LIMIT), (poly[0][0], self.GROUND_LIMIT)]; self.terrain_poly.append((poly, (0.4, 0.6, 0.3)))
            
            poly = [(self.terrain_x[i], self.terrain_ceiling_y[i]), (self.terrain_x[i + 1], self.terrain_ceiling_y[i + 1])]
            self.fd_edge.shape.vertices = poly; t = self.world.CreateStaticBody(fixtures=self.fd_edge, userData=CustomUserData("rock", CustomUserDataObjectTypes.GRIP_TERRAIN))
            color = (0, 0.25, 0.25); t.color1 = color; t.color2 = color; self.terrain.append(t)
            poly += [(poly[1][0], self.CEILING_LIMIT), (poly[0][0], self.CEILING_LIMIT)]; self.terrain_poly.append((poly, (0.5, 0.5, 0.5)))
            
            if self.creepers_width is not None and self.creepers_height is not None and self.creepers_height > 0:
                if space_from_precedent_creeper >= self.creepers_spacing:
                    creeper_height = max(0.2, self.np_random.normal(self.creepers_height, 0.1)); creeper_x = self.terrain_x[i] + TERRAIN_STEP / 2
                    creeper_y = self.terrain_ceiling_y[i]; poly = [(creeper_x - self.creepers_width / 2, creeper_y), (creeper_x + self.creepers_width / 2, creeper_y),
                                                                 (creeper_x + self.creepers_width / 2, creeper_y - creeper_height), (creeper_x - self.creepers_width / 2, creeper_y - creeper_height)]
                    self.fd_creeper.shape.vertices = poly
                    t = self.world.CreateDynamicBody(position=(0, 0), fixtures=self.fd_creeper, userData=CustomUserData("creeper", CustomUserDataObjectTypes.SENSOR_GRIP_TERRAIN)) if self.movable_creepers else self.world.CreateStaticBody(fixtures=self.fd_creeper, userData=CustomUserData("creeper", CustomUserDataObjectTypes.SENSOR_GRIP_TERRAIN))
                    t.color1, t.color2 = (1, 1, 0), (0.8, 0.8, 0); terrain_creepers.append(t); space_from_precedent_creeper = 0
                else: space_from_precedent_creeper += TERRAIN_STEP
        air_max_distance = max(self.terrain_ceiling_y) - self.GROUND_LIMIT; self.water_y = self.GROUND_LIMIT + self.water_level * air_max_distance
        water_poly = [(self.terrain_x[0], self.GROUND_LIMIT), (self.terrain_x[0], self.water_y), (self.terrain_x[len(self.terrain_x) - 1], self.water_y), (self.terrain_x[len(self.terrain_x) - 1], self.GROUND_LIMIT)]
        self.fd_water.shape.vertices = water_poly; t = self.world.CreateStaticBody(fixtures=self.fd_water, userData=CustomUserData("water", CustomUserDataObjectTypes.WATER))
        c = (0.465, 0.676, 0.898); t.color1 = c; t.color2 = c; water_body = t
        self.terrain.extend(terrain_creepers); self.terrain.append(water_body); self.terrain.reverse()
        
    def _SET_RENDERING_VIEWPORT_SIZE(self, width, height, keep_ratio=True):
        self.rendering_viewer_w = width
        if keep_ratio or height is None: self.rendering_viewer_h = int(self.rendering_viewer_w / (VIEWPORT_W / VIEWPORT_H))
        else: self.rendering_viewer_h = height
        
    def close(self):
        if self.viewer: self.viewer.close(); self.viewer = None
        self._destroy()

    def color_agent_head(self, c1, c2):
        ratio = 0
        if hasattr(self.agent_body, "nb_steps_can_survive_outside_water"): ratio = self.nb_steps_outside_water / self.agent_body.nb_steps_can_survive_outside_water
        elif hasattr(self.agent_body, "nb_steps_can_survive_under_water"): ratio = self.nb_steps_under_water / self.agent_body.nb_steps_can_survive_under_water
        return (c1[0] + ratio*(1.0 - c1[0]), c1[1] + ratio*(0.0 - c1[1]), c1[2] + ratio*(0.0 - c1[2])), c2

    def render(self, draw_lidars=True):
        from TeachMyAgent.environments.envs.utils import rendering
        if self.viewer is None and self.render_mode is not None: self.viewer = rendering.Viewer(self.rendering_viewer_w, self.rendering_viewer_h, visible=(self.render_mode == 'human'))
        if self.viewer is None or self.viewer.window is None or self.viewer.window.has_exit:
            if self.render_mode == 'rgb_array': return np.zeros((self.rendering_viewer_h, self.rendering_viewer_w, 3), dtype=np.uint8)
            return None
        self.viewer.set_bounds(self.scroll[0], self.rendering_viewer_w/SCALE + self.scroll[0], self.scroll[1], self.rendering_viewer_h/SCALE + self.scroll[1])
        self.viewer.draw_polygon([(self.scroll[0], self.scroll[1]), (self.scroll[0]+self.rendering_viewer_w/SCALE, self.scroll[1]),
                                  (self.scroll[0]+self.rendering_viewer_w/SCALE, self.scroll[1]+self.rendering_viewer_h/SCALE),
                                  (self.scroll[0], self.scroll[1]+self.rendering_viewer_h/SCALE)], color=(0.9, 0.9, 1.0))
        for poly,x1,x2 in self.cloud_poly:
            if x2 < self.scroll[0]/2 or x1 > self.scroll[0]/2 + self.rendering_viewer_w/SCALE: continue
            self.viewer.draw_polygon([(p[0]+self.scroll[0]/2, p[1]) for p in poly], color=(1,1,1))
        for obj in self.drawlist:
            color1, color2 = obj.color1, obj.color2
            if hasattr(obj.userData, 'object_type') and obj.userData.object_type == CustomUserDataObjectTypes.BODY_SENSOR and hasattr(obj.userData, 'has_joint') and obj.userData.has_joint:
                color1, color2 = (1.0, 1.0, 0.0), (1.0, 1.0, 0.0)
            elif obj == self.agent_body.reference_head_object: color1, color2 = self.color_agent_head(color1, color2)
            for f in obj.fixtures:
                trans = f.body.transform
                if type(f.shape) is circleShape:
                    t = rendering.Transform(translation=trans*f.shape.pos)
                    self.viewer.draw_circle(f.shape.radius, 30, color=color1).add_attr(t)
                    self.viewer.draw_circle(f.shape.radius, 30, color=color2, filled=False, linewidth=2).add_attr(t)
                else:
                    path = [trans*v for v in f.shape.vertices]
                    self.viewer.draw_polygon(path, color=color1); path.append(path[0]); self.viewer.draw_polyline(path, color=obj.color2, linewidth=2)
        for poly, color in self.terrain_poly:
            if len(poly) < 2 or poly[1][0] < self.scroll[0] or poly[0][0] > self.scroll[0] + self.rendering_viewer_w / SCALE: continue
            self.viewer.draw_polygon(poly, color=color)
        if draw_lidars and hasattr(self, 'lidar'):
            for i in range(len(self.lidar)):
                l = self.lidar[i]; self.viewer.draw_polyline([l.p1, l.p2], color=(1, 0, 0), linewidth=1)
        flagy1 = TERRAIN_HEIGHT; flagy2 = flagy1 + 50/SCALE; x = TERRAIN_STEP*3
        self.viewer.draw_polyline([(x, flagy1), (x, flagy2)], color=(0,0,0), linewidth=2)
        f = [(x, flagy2), (x, flagy2-10/SCALE), (x+25/SCALE, flagy2-5/SCALE)]
        self.viewer.draw_polygon(f, color=(0.9,0.2,0)); self.viewer.draw_polyline(f + [f[0]], color=(0,0,0), linewidth=2)
        return self.viewer.render(return_rgb_array = self.render_mode=='rgb_array')

===== .\TeachMyAgent\environments\envs\parametric_continuous_stump_tracks.py =====
# Parametric Walker continuous environment
#
# Reward is given for moving forward, total 300+ points up to the far end. If the robot falls,
# it gets -100. Applying motor torque costs a small amount of points, more optimal agent
# will get better score.
#
# State consists of hull angle speed, angular velocity, horizontal speed, vertical speed,
# position of joints and joints angular speed, legs contact with ground, and 10 lidar
# rangefinder measurements. There's no coordinates
# in the state vector.
#
# Initially Created by Oleg Klimov. Licensed on the same terms as the rest of OpenAI Gym.
# Modified by R√©my Portelas and licensed under TeachMyAgent/teachers/LICENSES/ALP-GMM
# Modified Cl√©ment Romac

#region Imports

import numpy as np
import Box2D
from Box2D.b2 import (edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener)
import gymnasium as gym
from gymnasium import spaces
from gymnasium.utils import colorize, seeding, EzPickle
import math


from TeachMyAgent.environments.envs.bodies.BodiesEnum import BodiesEnum
from TeachMyAgent.environments.envs.bodies.BodyTypesEnum import BodyTypesEnum
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomUserDataObjectTypes, CustomUserData

#endregion

#region Utils


class ContactDetector(contactListener):
    '''
        Custom contact detector.
    '''
    def __init__(self, env):
        contactListener.__init__(self)
        self.env = env
    def BeginContact(self, contact):
        '''
            Triggered when contact is detected.

            Checks userData of each of the two fixtures colliding.
            Sets `userData.has_contact` to True on the body if `body.userData.check_contact == True`.
            If `userData.is_contact_critical == True`, `env.critical_contact` is set to True, stopping the episode.
        '''
        for body in [contact.fixtureA.body, contact.fixtureB.body]:
            if body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT and body.userData.check_contact:
                body.userData.has_contact = True
                if body.userData.is_contact_critical:
                    self.env.head_contact = True

    def EndContact(self, contact):
        '''
            Triggered when contact ends.

            Sets `userData.has_contact` to False on the body if `body.userData.check_contact == True`.
        '''
        for body in [contact.fixtureA.body, contact.fixtureB.body]:
            if body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT and body.userData.check_contact:
                body.userData.has_contact = False

def Rotate2D(pts,cnt,ang=np.pi/4):
    '''pts = {} Rotates points(nx2) about center cnt(2) by angle ang(1) in radian'''
    m1 = pts-cnt
    m2 = np.array([[np.cos(ang),np.sin(ang)],[-np.sin(ang),np.cos(ang)]])
    return np.dot(m1,m2)+cnt


class LidarCallback(Box2D.b2.rayCastCallback):
    '''
        Callback function triggered when lidar detects an object.
    '''
    def __init__(self, agent_mask_filter):
        '''
            Args:
                agent_mask_filter: Mask filter used to avoid detecting collisions with the agent's body
        '''
        Box2D.b2.rayCastCallback.__init__(self)
        self.agent_mask_filter = agent_mask_filter
        self.fixture = None
    def ReportFixture(self, fixture, point, normal, fraction):
        '''
            Triggered when a body is detected by the lidar.

            Returns:
                Distance to object detected.
        '''
        if (fixture.filterData.categoryBits & self.agent_mask_filter) == 0:
            return -1
        self.p2 = point
        self.fraction = fraction
        return fraction

#endregion

#region Constants

FPS    = 50
SCALE  = 30.0   # affects how fast-paced the game is, forces should be adjusted as well
VIEWPORT_W = 600 # Careful, this affects training
VIEWPORT_H = 400 # Careful, this affects training

RENDERING_VIEWER_W = VIEWPORT_W # Only affects rendering, not the policy
RENDERING_VIEWER_H = VIEWPORT_H # Only affects rendering, not the policy

NB_LIDAR = 10 # Number of lidars used by the agent
LIDAR_RANGE   = 160/SCALE

INITIAL_RANDOM = 5

TERRAIN_STEP   = 14/SCALE
TERRAIN_LENGTH = 200     # in steps
TERRAIN_HEIGHT = VIEWPORT_H/SCALE/4
TERRAIN_END    = 10    # in steps
INITIAL_TERRAIN_STARTPAD = 20 # in steps
FRICTION = 2.5

#endregion

class ParametricContinuousStumpTracks(gym.Env, EzPickle):
    '''
        The Stump Tracks: a procedurally generated Gym environment.
    '''
    metadata = {
        'render_modes': ['human', 'rgb_array'],
        'video.frames_per_second' : FPS
    }

    def __init__(self, walker_type,render_mode, **walker_args):
        '''
            Creates a Stump Tracks environment with an embodiment.

                walker_type: Embodiment
            :type walker_type: BodiesEnum
                walker_args: kwargs controlling the agent (e.g. number of body for a millipede)
        '''

        super(ParametricContinuousStumpTracks, self).__init__()
        self.render_mode = render_mode

        # Seed env and init Box2D
        self.seed()
        self.viewer = None

        self.world = Box2D.b2World()
        self.terrain = []

        self.prev_shaping = None

        # Create agent
        body_type = BodiesEnum.get_body_type(walker_type)
        if body_type == BodyTypesEnum.SWIMMER or body_type == BodyTypesEnum.AMPHIBIAN:
            self.walker_body = BodiesEnum[walker_type].value(SCALE, density=1.0, **walker_args)
        elif body_type == BodyTypesEnum.WALKER:
            self.walker_body = BodiesEnum[walker_type].value(SCALE, **walker_args,
                                                                reset_on_hull_critical_contact=True)
        else:
            self.walker_body = BodiesEnum[walker_type].value(SCALE, **walker_args)

        # Adapt startpad to walker's width
        self.TERRAIN_STARTPAD = INITIAL_TERRAIN_STARTPAD if \
            self.walker_body.AGENT_WIDTH / TERRAIN_STEP + 5 <= INITIAL_TERRAIN_STARTPAD else \
            self.walker_body.AGENT_WIDTH / TERRAIN_STEP + 5  # in steps
        self.create_terrain_fixtures()

        # Set observation / action spaces
        self._generate_walker()  # To get state / action sizes
        agent_action_size = self.walker_body.get_action_size()
        self.action_space = spaces.Box(np.array([-1] * agent_action_size),
                                       np.array([1] * agent_action_size), dtype=np.float32)

        agent_state_size = self.walker_body.get_state_size()
        high = np.array([np.inf] * (agent_state_size +
                                    4 +  # head infos
                                    NB_LIDAR))  # lidars infos
        self.observation_space = spaces.Box(-high, high, dtype=np.float32)

    def seed(self, seed=None):
        self.np_random, seed = seeding.np_random(seed)
        return [seed]

    def set_environment(self, roughness=None, stump_height=None, stump_width=None, stump_rot=None,
                        obstacle_spacing=None, poly_shape=None, stump_seq=None):
        '''
            Set the parameters controlling the PCG algorithm to generate a task.
            Call this method before `reset()`.

            Args:
                roughness: Input vector controlling the CPPN
                stump_height: Tuple specifying mean and std of a normal distribution from which the height of each stump is sampled
                stump_width: Tuple specifying mean and std of a normal distribution from which the width of each stump is sampled
                stump_rot: Tuple specifying mean and std of a normal distribution from which the rotation degree of each stump is sampled
                obstacle_spacing: Spacing between stumps
                poly_shape: Shape of polygon stumps
        '''
        self.roughness = roughness if roughness else 0
        self.obstacle_spacing = max(0.01, obstacle_spacing) if obstacle_spacing is not None else 8.0
        self.stump_height = stump_height
        self.stump_width = stump_width
        self.stump_rot = stump_rot
        self.hexa_shape = poly_shape
        self.stump_seq = stump_seq
        if poly_shape is not None:
            self.hexa_shape = np.interp(poly_shape,[0,4],[0,4]).tolist()
            assert(len(poly_shape) == 12)
            self.hexa_shape = self.hexa_shape[0:12]

    def _destroy(self):
        # if not self.terrain: return
        self.world.contactListener = None
        for t in self.terrain:
            self.world.DestroyBody(t)
        self.terrain = []

        self.walker_body.destroy(self.world)

    def reset(self, *, seed=None, options=None):
        super().reset(seed=seed)
        self._destroy()
        self.world.contactListener_bug_workaround = ContactDetector(self)
        self.world.contactListener = self.world.contactListener_bug_workaround
        self.head_contact = False
        self.prev_shaping = None
        self.scroll = 0.0
        self.lidar_render = 0

        self.generate_game()

        self.drawlist = self.terrain + self.walker_body.get_elements_to_render()

        self.lidar = [LidarCallback(self.walker_body.reference_head_object.fixtures[0].filterData.maskBits)
                      for _ in range(NB_LIDAR)]
        self.episodic_reward = 0

        obs, _, _, _, _ = self.step(np.array([0] * self.action_space.shape[0]))
        return np.array(obs, dtype=np.float32), {}

    def step(self, action):
        self.walker_body.activate_motors(action)

        self.world.Step(1.0/FPS, 6*30, 2*30)

        head = self.walker_body.reference_head_object
        pos = head.position
        vel = head.linearVelocity

        for i in range(NB_LIDAR):
            self.lidar[i].fraction = 1.0
            self.lidar[i].p1 = pos
            self.lidar[i].p2 = (
                pos[0] + math.sin(1.5*i/NB_LIDAR)*LIDAR_RANGE,
                pos[1] - math.cos(1.5*i/NB_LIDAR)*LIDAR_RANGE)
            self.world.RayCast(self.lidar[i], self.lidar[i].p1, self.lidar[i].p2)
        state = [
            head.angle,        # Normal angles up to 0.5 here, but sure more is possible.
            2.0*head.angularVelocity/FPS,
            0.3*vel.x*(VIEWPORT_W/SCALE)/FPS,  # Normalized to get -1..1 range
            0.3*vel.y*(VIEWPORT_H/SCALE)/FPS]

        # add leg-related state
        state.extend(self.walker_body.get_motors_state())

        if self.walker_body.body_type == BodyTypesEnum.CLIMBER:
            state.extend(self.walker_body.get_sensors_state())

        state += [l.fraction for l in self.lidar]

        self.scroll = pos.x - RENDERING_VIEWER_W/SCALE/5

        shaping  = 130*pos[0]/SCALE  # moving forward is a way to receive reward (normalized to get 300 on completion)
        if not (hasattr(self.walker_body, "remove_reward_on_head_angle") and self.walker_body.remove_reward_on_head_angle):
            shaping -= 5.0*abs(state[0])  # keep head straight, other than that and falling, any behavior is unpunished

        reward = 0
        if self.prev_shaping is not None:
            reward = shaping - self.prev_shaping
        self.prev_shaping = shaping

        for a in action:
            reward -= self.walker_body.TORQUE_PENALTY * 80 * np.clip(np.abs(a), 0, 1) # 80 => Original torque
            # normalized to about -50.0 using heuristic, more optimal agent should spend less

        done = False
        if self.head_contact or pos[0] < 0:
            reward = -100
            done   = True
        if pos[0] > (TERRAIN_LENGTH-TERRAIN_END)*TERRAIN_STEP:
            done   = True
        self.episodic_reward += reward
        terminated = done
        truncated = self.episodic_reward > 230
        return np.array(state, dtype=np.float32), reward, terminated, truncated, {"success": self.episodic_reward > 230}


    def render(self, mode='human', draw_lidars=True):
        #self.scroll = 1
        from TeachMyAgent.environments.envs.utils import rendering
        if self.viewer is None:
            self.viewer = rendering.Viewer(RENDERING_VIEWER_W, RENDERING_VIEWER_H)
        self.viewer.set_bounds(self.scroll, RENDERING_VIEWER_W/SCALE + self.scroll, 0, RENDERING_VIEWER_H/SCALE)

        self.viewer.draw_polygon( [
            (self.scroll,                  0),
            (self.scroll+RENDERING_VIEWER_W/SCALE, 0),
            (self.scroll+RENDERING_VIEWER_W/SCALE, RENDERING_VIEWER_H/SCALE),
            (self.scroll,                  RENDERING_VIEWER_H/SCALE),
            ], color=(0.9, 0.9, 1.0) )
        for poly,x1,x2 in self.cloud_poly:
            if x2 < self.scroll/2: continue
            if x1 > self.scroll/2 + RENDERING_VIEWER_W/SCALE: continue
            self.viewer.draw_polygon( [(p[0]+self.scroll/2, p[1]) for p in poly], color=(1,1,1))
        for poly, color in self.terrain_poly:
            if poly[1][0] < self.scroll: continue
            if poly[0][0] > self.scroll + RENDERING_VIEWER_W/SCALE: continue
            self.viewer.draw_polygon(poly, color=color)

        for obj in self.drawlist:
            for f in obj.fixtures:
                trans = f.body.transform
                if type(f.shape) is circleShape:
                    t = rendering.Transform(translation=trans*f.shape.pos)
                    self.viewer.draw_circle(f.shape.radius, 30, color=obj.color1).add_attr(t)
                    self.viewer.draw_circle(f.shape.radius, 30, color=obj.color2, filled=False, linewidth=2).add_attr(t)
                else:
                    path = [trans*v for v in f.shape.vertices]
                    self.viewer.draw_polygon(path, color=obj.color1)
                    path.append(path[0])
                    self.viewer.draw_polyline(path, color=obj.color2, linewidth=2)

        # Draw lidars
        if draw_lidars:
            for i in range(len(self.lidar)):
                l = self.lidar[i]
                self.viewer.draw_polyline([l.p1, l.p2], color=(1, 0, 0), linewidth=1)

        flagy1 = TERRAIN_HEIGHT
        flagy2 = flagy1 + 50/SCALE
        x = TERRAIN_STEP*3
        self.viewer.draw_polyline( [(x, flagy1), (x, flagy2)], color=(0,0,0), linewidth=2 )
        f = [(x, flagy2), (x, flagy2-10/SCALE), (x+25/SCALE, flagy2-5/SCALE)]
        self.viewer.draw_polygon(f, color=(0.9,0.2,0) )
        self.viewer.draw_polyline(f + [f[0]], color=(0,0,0), linewidth=2 )

        return self.viewer.render(return_rgb_array = mode=='rgb_array')

    def _SET_RENDERING_VIEWPORT_SIZE(self, width, height=None, keep_ratio=True):
        '''
            Set rendering viewport's size (i.e. image size).

            Args:
                width: viewport's width
                height: viewport's height
                keep_ratio: Whether height must be automatically calculated to keep the same ratio as the environment's viewport size.
        '''
        global RENDERING_VIEWER_W, RENDERING_VIEWER_H
        RENDERING_VIEWER_W = width
        if keep_ratio or height is None:
            RENDERING_VIEWER_H = int(RENDERING_VIEWER_W / (VIEWPORT_W / VIEWPORT_H))
        else:
            RENDERING_VIEWER_H = height

    def close(self):
        self._destroy()
        if self.viewer is not None:
            self.viewer.close()
            self.viewer = None

    #region Fixtures Initialization
    # ------------------------------------------ FIXTURES INITIALIZATION ------------------------------------------

    def create_terrain_fixtures(self):
        '''
            Create fixtures used to generate terrain.
        '''
        self.fd_polygon = fixtureDef(
            shape=polygonShape(vertices=
                               [(0, 0),
                                (1, 0),
                                (1, -1),
                                (0, -1)]),
            friction=FRICTION,
            categoryBits=0x1,
            maskBits=0xFFFF
        )

        self.fd_edge = fixtureDef(
            shape=edgeShape(vertices=
                            [(0, 0),
                             (1, 1)]),
            friction=FRICTION,
            categoryBits=0x1,
            maskBits=0xFFFF
        )

        # Init default hexagon fixture and shape, used only for Hexagon Tracks
        self.fd_default_hexagon = fixtureDef(
            shape=polygonShape(vertices=
                               [(0, 0),
                                (1, 0),
                                (1, -1),
                                (0, -1)]),
            friction=FRICTION,
            categoryBits=0x1,
            maskBits=0xFFFF
        )
        self.default_hexagon = [(-0.5, 0), (-0.5, 0.25), (-0.25, 0.5), (0.25, 0.5), (0.5, 0.25), (0.5, 0)]

    #endregion

    # region Game Generation
    # ------------------------------------------ GAME GENERATION ------------------------------------------

    def generate_game(self):
        '''
            Generate the task (i.e. terrain + embodiment).
        '''
        self._generate_terrain()
        self._generate_clouds()
        self._generate_walker()

    def _generate_terrain(self):
        GRASS, STUMP, HEXA = 0, None, None
        cpt=1
        if self.stump_height:
            STUMP = cpt
            cpt += 1
        if self.hexa_shape:
            HEXA = cpt
            cpt += 1
        if self.stump_seq is not None:
            SEQ = cpt
            cpt += 1
        _STATES_ = cpt

        state = self.np_random.integers(1, _STATES_)

        velocity = 0.0
        y = TERRAIN_HEIGHT
        self.terrain = []
        self.terrain_x = []
        self.terrain_y = []
        x = 0
        max_x = TERRAIN_LENGTH * TERRAIN_STEP

        # Add startpad
        max_startpad_x = self.TERRAIN_STARTPAD * TERRAIN_STEP
        self.terrain_x.append(x)
        self.terrain_y.append(y)
        x += max_startpad_x
        self.terrain_x.append(x)
        self.terrain_y.append(y)
        oneshot = True

        # Generation of terrain
        while x < max_x:
            self.terrain_x.append(x)

            if state==GRASS and not oneshot:
                velocity = 0.8*velocity + 0.01*np.sign(TERRAIN_HEIGHT - y)
                if x > max_startpad_x: velocity += self.np_random.uniform(-self.roughness, self.roughness)/SCALE

                y += velocity
                x += self.obstacle_spacing

            elif state==STUMP and oneshot:
                stump_height = max(0.05, self.np_random.normal(self.stump_height[0], self.stump_height[1]))
                stump_width = TERRAIN_STEP
                if self.stump_width is not None:
                    stump_width *= max(0.05, np.random.normal(self.stump_width[0], self.stump_width[1]))
                poly = [
                    (x, y),
                    (x+stump_width, y),
                    (x+stump_width, y+stump_height * TERRAIN_STEP),
                    (x,y+stump_height * TERRAIN_STEP),
                    ]
                x += stump_width
                if self.stump_rot is not None:
                    anchor = (np.array(poly[0]) + np.array(poly[1]))/2
                    rotation = np.clip(self.np_random.normal(self.stump_rot[0], self.stump_rot[1]),0,2*np.pi)
                    poly = Rotate2D(np.array(poly), anchor, rotation).tolist()
                self.fd_polygon.shape.vertices=poly
                t = self.world.CreateStaticBody(
                    fixtures = self.fd_polygon,
                    userData=CustomUserData("grass", CustomUserDataObjectTypes.TERRAIN))
                t.color1, t.color2 = (1,1,1), (0.6,0.6,0.6)
                self.terrain.append(t)
            elif state==HEXA and oneshot:
                # first point do not move
                poly = []
                delta_pos = []
                for i in range(0,len(self.hexa_shape),2):
                    delta_pos.append(tuple(np.random.normal(self.hexa_shape[i:i+2],0.1)))
                for i,(b,d) in enumerate(zip(self.default_hexagon, delta_pos)):
                    if i != 0 and i != (len(self.default_hexagon)-1):
                        poly.append((x + (b[0]*TERRAIN_STEP) + (d[0]*TERRAIN_STEP),
                                     y + (b[1]*TERRAIN_STEP) + (d[1]*TERRAIN_STEP)))
                    else:
                        poly.append((x + (b[0]*TERRAIN_STEP) + (d[0]*TERRAIN_STEP),
                                     y + (b[1]*TERRAIN_STEP)))
                x += 1
                self.fd_default_hexagon.shape.vertices = poly
                t = self.world.CreateStaticBody(
                    fixtures=self.fd_default_hexagon)
                t.color1, t.color2 = (1.0, np.clip(delta_pos[0][1]/3,0,1), np.clip(delta_pos[-1][1]/3,0,1)), (0.6, 0.6, 0.6)
                self.terrain.append(t)

            elif state==SEQ and oneshot:
                for height, width in zip(self.stump_seq[0::2], self.stump_seq[1::2]):
                    stump_height = max(0.05, self.np_random.normal(height, 0.1))
                    stump_width = max(0.05, self.np_random.normal(width, 0.1))
                    poly = [
                        (x, y),
                        (x + stump_width, y),
                        (x + stump_width, y + stump_height * TERRAIN_STEP),
                        (x, y + stump_height * TERRAIN_STEP),
                    ]
                    x += stump_width
                    self.fd_polygon.shape.vertices = poly
                    t = self.world.CreateStaticBody(
                        fixtures=self.fd_polygon,
                        userData=CustomUserData("grass", CustomUserDataObjectTypes.TERRAIN))
                    t.color1, t.color2 = (1, 1, 1), (0.6, 0.6, 0.6)
                    self.terrain.append(t)

            oneshot = False
            self.terrain_y.append(y)
            if state==GRASS:
                state = self.np_random.integers(1, _STATES_)
                oneshot = True
            else:
                state = GRASS
                oneshot = False

        # Draw terrain
        self.terrain_poly = []
        assert len(self.terrain_x) == len(self.terrain_y)
        for i in range(len(self.terrain_x)-1):
            poly = [
                (self.terrain_x[i],   self.terrain_y[i]),
                (self.terrain_x[i+1], self.terrain_y[i+1])
                ]
            self.fd_edge.shape.vertices=poly
            t = self.world.CreateStaticBody(
                fixtures = self.fd_edge,
                userData=CustomUserData("grass", CustomUserDataObjectTypes.TERRAIN))
            color = (0.3, 1.0 if (i % 2) == 0 else 0.8, 0.3)
            t.color1 = color
            t.color2 = color
            self.terrain.append(t)
            color = (0.4, 0.6, 0.3)
            poly += [ (poly[1][0], 0), (poly[0][0], 0) ]
            self.terrain_poly.append( (poly, color) )
        self.terrain.reverse()

    def _generate_clouds(self):
        # Sorry for the clouds, couldn't resist
        self.cloud_poly   = []
        for i in range(TERRAIN_LENGTH//20):
            x = self.np_random.uniform(0, TERRAIN_LENGTH)*TERRAIN_STEP
            y = VIEWPORT_H/SCALE*3/4
            poly = [
                (x+15*TERRAIN_STEP*math.sin(3.14*2*a/5)+self.np_random.uniform(0,5*TERRAIN_STEP),
                 y+ 5*TERRAIN_STEP*math.cos(3.14*2*a/5)+self.np_random.uniform(0,5*TERRAIN_STEP) )
                for a in range(5) ]
            x1 = min( [p[0] for p in poly] )
            x2 = max( [p[0] for p in poly] )
            self.cloud_poly.append( (poly,x1,x2) )

    def _generate_walker(self):
        init_x = TERRAIN_STEP*self.TERRAIN_STARTPAD/2
        if hasattr(self.walker_body, "old_morphology") and self.walker_body.old_morphology:
            init_y = TERRAIN_HEIGHT + 2 * self.walker_body.LEG_H
        else:
            init_y = TERRAIN_HEIGHT + self.walker_body.AGENT_CENTER_HEIGHT

        self.walker_body.draw(
            self.world,
            init_x,
            init_y,
            self.np_random.uniform(-INITIAL_RANDOM, INITIAL_RANDOM)
        )

    #endregion

===== .\TeachMyAgent\environments\envs\__init__.py =====


===== .\TeachMyAgent\environments\envs\bodies\AbstractBody.py =====
import numpy as np

class AbstractBody(object):
    '''
        Base class for all embodiments.
    '''
    def __init__(self, scale, motors_torque):
        '''
            Creates an embodiment.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
        '''
        self.SCALE = scale
        self.MOTORS_TORQUE = motors_torque

        self.body_parts = [] # list of objects constituting the body
        self.motors = [] # list of motors

    # States
    def get_state_size(self):
        '''
            Returns the size of the embodiment's state vector
        '''
        return len(self.get_motors_state())

    def get_motors_state(self):
        '''
            Returns state vector of motors.

            For each motor returns:
            - its angle
            - its speed
            - if `motor.userData` has `check_contact` to True, returns whether the associated body checking contact has contact
        '''
        state = []
        for motor in self.motors:
            motor_info = motor.userData
            if motor_info.check_contact:
                state.extend([
                    motor.angle + motor_info.angle_correction,
                    motor.speed / motor_info.speed_control,
                    1.0 if motor_info.contact_body.userData.has_contact else 0.0 # If motor has check_contact=True, check the contact of the associated contact_body
                ])
            else:
                state.extend([
                    motor.angle + motor_info.angle_correction,
                    motor.speed / motor_info.speed_control
                ])
        return state

    # Actions
    def get_action_size(self):
        '''
            Returns the size of the action space.
        '''
        return len(self.motors)

    def activate_motors(self, action):
        '''
            Activate motors given a vector of actions (between -1 and 1).

            Sets `motorSpeed` to `speed_control * sign(action)`.
            Sets `maxMotorTorque` to `MOTORS_TORQUE * abs(action)` (with `MOTORS_TORQUE` the torque set in the constructor).
        '''
        for i in range(len(self.motors)):
            self.motors[i].motorSpeed  = float(self.motors[i].userData.speed_control * np.sign(action[i]))
            self.motors[i].maxMotorTorque = float(self.MOTORS_TORQUE * np.clip(np.abs(action[i]), 0, 1))

    # Draw
    def draw(self, world, init_x, init_y, force_to_center):
        '''
            Creates fixtures and bodies in the Box2D world.
        '''
        pass

    def get_elements_to_render(self):
        '''
            Returns bodies that must be rendered in the `env.render` function.
        '''
        return self.body_parts

    # Destroy
    def destroy(self, world):
        for body_part in self.body_parts:
            world.DestroyBody(body_part)
        self.body_parts = []
        self.motors = []







===== .\TeachMyAgent\environments\envs\bodies\BodiesEnum.py =====
from enum import Enum
from TeachMyAgent.environments.envs.bodies.BodyTypesEnum import BodyTypesEnum

from TeachMyAgent.environments.envs.bodies.climbers.ClimbingChestProfileChimpanzee import ClimbingChestProfileChimpanzee
from TeachMyAgent.environments.envs.bodies.climbers.ClimbingProfileChimpanzee import ClimbingProfileChimpanzee

from TeachMyAgent.environments.envs.bodies.swimmers.FishBody import FishBody

from TeachMyAgent.environments.envs.bodies.amphibians.AmphibiousBipedalBody import AmphibiousBipedalBody

from TeachMyAgent.environments.envs.bodies.walkers.old.OldBigQuadruBody import OldBigQuadruBody
from TeachMyAgent.environments.envs.bodies.walkers.old.OldClassicBipedalBody import OldClassicBipedalBody
from TeachMyAgent.environments.envs.bodies.walkers.SmallBipedalBody import SmallBipedalBody
from TeachMyAgent.environments.envs.bodies.walkers.BigQuadruBody import BigQuadruBody
from TeachMyAgent.environments.envs.bodies.walkers.ClassicBipedalBody import ClassicBipedalBody
from TeachMyAgent.environments.envs.bodies.walkers.MillipedeBody import MillipedeBody
from TeachMyAgent.environments.envs.bodies.walkers.ProfileChimpanzee import ProfileChimpanzee
from TeachMyAgent.environments.envs.bodies.walkers.SpiderBody import SpiderBody
from TeachMyAgent.environments.envs.bodies.walkers.WheelBody import WheelBody


class BodiesEnum(Enum):
    '''
        Possible embodiments to use.

        Associates a string name to a class.
    '''
    small_bipedal = SmallBipedalBody
    classic_bipedal = ClassicBipedalBody
    big_quadru = BigQuadruBody
    spider = SpiderBody
    millipede = MillipedeBody
    wheel = WheelBody
    old_classic_bipedal = OldClassicBipedalBody
    profile_chimpanzee = ProfileChimpanzee
    old_big_quadru = OldBigQuadruBody
    fish = FishBody
    climbing_profile_chimpanzee = ClimbingProfileChimpanzee
    climbing_chest_profile_chimpanzee = ClimbingChestProfileChimpanzee
    amphibious_bipedal = AmphibiousBipedalBody

    @classmethod
    def get_body_type(self, body_name):
        '''
            Return embodiment's type given its name.
        '''
        if body_name in ['climbing_chest_profile_chimpanzee', 'climbing_profile_chimpanzee']:
            return BodyTypesEnum.CLIMBER
        elif body_name == 'fish':
            return BodyTypesEnum.SWIMMER
        elif body_name == 'amphibious_bipedal':
            return BodyTypesEnum.AMPHIBIAN
        else:
            return BodyTypesEnum.WALKER

===== .\TeachMyAgent\environments\envs\bodies\BodyTypesEnum.py =====
from enum import Enum

class BodyTypesEnum(Enum):
    '''
        Types of pembodiments
    '''
    WALKER = 0
    SWIMMER = 1
    CLIMBER = 2
    AMPHIBIAN = 3

===== .\TeachMyAgent\environments\envs\bodies\__init__.py =====


===== .\TeachMyAgent\environments\envs\bodies\amphibians\AmphibianAbstractBody.py =====
from TeachMyAgent.environments.envs.bodies.AbstractBody import AbstractBody
from TeachMyAgent.environments.envs.bodies.BodyTypesEnum import BodyTypesEnum

class AmphibianAbstractBody(AbstractBody):
    '''
        Base class for amphibians.
    '''
    def __init__(self, scale, motors_torque, density):
        '''
            Creates an amphibious embodiment allowed to go both under and outside water

            :param scale: Scale value used in the environment (to adapt the embodiment to its environment)
            :param motors_torque: Maximum torque the embodiment can use on its motors
            :param density: Water density (in order to make the agent in a zero-gravity-like setup)
        '''
        super(AmphibianAbstractBody, self).__init__(scale, motors_torque)

        self.body_type = BodyTypesEnum.AMPHIBIAN
        self.DENSITY = density # set the embodiment's density to the same value as water so that it will be in a zero-gravity setup

===== .\TeachMyAgent\environments\envs\bodies\amphibians\AmphibiousBipedalBody.py =====
import numpy as np
from Box2D.b2 import edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener

from TeachMyAgent.environments.envs.bodies.amphibians.AmphibianAbstractBody import AmphibianAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData

HULL_POLYGONS = [
    [(-30, +9), (+6, +9), (+34, +1),
    (+34, -8), (-30, -8)]
]
HULL_BOTTOM_WIDTH = 64
SPEED_HIP     = 4
SPEED_KNEE    = 6

class AmphibiousBipedalBody(AmphibianAbstractBody):
    '''
        Amphibious Bipedal walker embodiment.
    '''
    def __init__(self, scale, density, motors_torque=80):
        '''
            Creates an amphibious bipedal embodiment allowed to go both under and outside water

            :param scale: Scale value used in the environment (to adapt the embodiment to its environment)
            :param motors_torque: Maximum torque the embodiment can use on its motors
            :param density: Water density (in order to make the agent in a zero-gravity-like setup)
        '''
        super(AmphibiousBipedalBody, self).__init__(scale, motors_torque, density)
        self.LEG_DOWN = 3 / self.SCALE # 0 = center of hull
        self.LEG_W, self.LEG_H = 8 / self.SCALE, 34 / self.SCALE
        self.TORQUE_PENALTY = 0.00035

        self.AGENT_WIDTH = HULL_BOTTOM_WIDTH / self.SCALE
        self.AGENT_HEIGHT = 17 / self.SCALE + \
                            self.LEG_H * 2 - self.LEG_DOWN
        self.AGENT_CENTER_HEIGHT = self.LEG_H * 2 + self.LEG_DOWN

    def draw(self, world, init_x, init_y, force_to_center):
        HULL_FIXTURES = [
            fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in polygon]),
                density=self.DENSITY * 1.25,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x000F)  # 0.99 bouncy
            for polygon in HULL_POLYGONS
        ]

        LEG_FD = fixtureDef(
            shape=polygonShape(box=(self.LEG_W / 2, self.LEG_H / 2)),
            density=self.DENSITY * 0.25,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        LOWER_FD = fixtureDef(
            shape=polygonShape(box=(0.8 * self.LEG_W / 2, self.LEG_H / 2)),
            density=self.DENSITY * 0.25,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        hull = world.CreateDynamicBody(
            position=(init_x, init_y),
            fixtures=HULL_FIXTURES
        )
        hull.color1 = (0.44, 0.81, 0.14)
        hull.color2 = (0.36, 0.66, 0.11)
        hull.ApplyForceToCenter((force_to_center, 0), True)

        hull.userData = CustomBodyUserData(True, is_contact_critical=False, name="hull")
        self.body_parts.append(hull)
        self.reference_head_object = hull

        for i in [-1, +1]:
            leg = world.CreateDynamicBody(
                position=(init_x, init_y - self.LEG_H / 2 - self.LEG_DOWN),
                #angle=(i * 0.05),#2¬∞
                fixtures=LEG_FD
            )
            leg.color1 = (0.44, 0.81, 0.14)
            leg.color2 = (0.36, 0.66, 0.11)
            rjd = revoluteJointDef(
                bodyA=hull,
                bodyB=leg,
                anchor=(init_x, init_y - self.LEG_DOWN),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=i,
                lowerAngle=-0.8,
                upperAngle=1.1,
            )

            leg.userData = CustomBodyUserData(False, name="leg")
            self.body_parts.append(leg)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            lower = world.CreateDynamicBody(
                position=(init_x, init_y - self.LEG_H * 3 / 2 - self.LEG_DOWN),
                #angle=(i * 0.05), #2¬∞
                fixtures=LOWER_FD
            )
            lower.color1 = (1.0, 0.25, 0.04)
            lower.color2 = (0.86, 0.29, 0.12)
            rjd = revoluteJointDef(
                bodyA=leg,
                bodyB=lower,
                anchor=(init_x, init_y - self.LEG_DOWN - self.LEG_H),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=-1.6,
                upperAngle=-0.1,
            )

            lower.userData = CustomBodyUserData(True, name="lower")
            self.body_parts.append(lower)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(
                SPEED_KNEE,
                True,
                contact_body=lower,
                angle_correction=1.0)
            self.motors.append(joint_motor)

===== .\TeachMyAgent\environments\envs\bodies\amphibians\__init__.py =====


===== .\TeachMyAgent\environments\envs\bodies\climbers\ClimberAbstractBody.py =====
from TeachMyAgent.environments.envs.bodies.walkers.WalkerAbstractBody import WalkerAbstractBody
from TeachMyAgent.environments.envs.bodies.BodyTypesEnum import BodyTypesEnum
import Box2D
from Box2D.b2 import circleShape, fixtureDef

class ClimberAbstractBody(WalkerAbstractBody):
    '''
        Base class for climbers.
    '''
    def __init__(self, scale, motors_torque, nb_steps_under_water):
        '''
            Creates a climber, which cannot survive under water and cannot touch ground.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                nb_steps_under_water: How many consecutive steps the embodiment can survive under water
        '''
        super(ClimberAbstractBody, self).__init__(scale, motors_torque, nb_steps_under_water)

        self.body_type = BodyTypesEnum.CLIMBER
        self.sensors = []
        self.SENSOR_FD = fixtureDef(
            shape=circleShape(radius=0.05),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x1,
            isSensor=True
        )

    # # States
    # def get_state_size(self):
    #     '''
    #         Returns the size of the embodiment's state vector (classic state + sensors)
    #     '''
    #     return super(ClimberAbstractBody, self).get_state_size() + len(self.get_sensors_state())

    def get_sensors_state(self):
        '''
            Returns state vector sensors.

            For each sensor returns:
            - if it a collision is detected
            - if it is already grasping (i.e. it is attached to a joint)
        '''
        state = []
        for sensor in self.sensors:
            state.extend([1.0 if sensor.userData.has_contact else 0.0,
                          1.0 if sensor.userData.has_joint else 0.0])
        return state

    # Actions
    def get_action_size(self):
        '''
            Returns the size of the action space (classic action space + number of sensors).
        '''
        return super(ClimberAbstractBody, self).get_action_size() + len(self.sensors)

    # Draw
    def get_elements_to_render(self):
        '''
            Returns bodies that must be rendered in the `env.render` function (including sensors).
        '''
        return super(ClimberAbstractBody, self).get_elements_to_render() + self.sensors

    # Destroy
    def destroy(self, world):
        super(ClimberAbstractBody, self).destroy(world)  # Destroy the rest of the body as any other agent
        for sensor in self.sensors:
            world.DestroyBody(sensor) # Destroy sensor
        self.sensors = []






===== .\TeachMyAgent\environments\envs\bodies\climbers\ClimbingChestProfileChimpanzee.py =====
import numpy as np
from Box2D.b2 import edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener, weldJointDef

from TeachMyAgent.environments.envs.bodies.climbers.ClimberAbstractBody import ClimberAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData, CustomBodySensorUserData

SPEED_HIP     = 4
SPEED_KNEE    = 6
SPEED_HAND    = 8

class ClimbingChestProfileChimpanzee(ClimberAbstractBody):
    '''
        Climbing 'chimpanzee' embodiment without legs.
    '''
    def __init__(self, scale, motors_torque=100, nb_steps_under_water=600):
        '''
            Creates a legless chimpanzee with:
            - a head
            - a chest
            - two arms (constituted of two limbs each)
            - two hands (constituted of one limbs each)
            - two sensors (each at the extremity of a hand) to detect collisions with graspable areas and grasp them.

            No contact with ground is allowed.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                nb_steps_under_water: How many consecutive steps the embodiment can survive under water
        '''
        super(ClimbingChestProfileChimpanzee, self).__init__(scale, motors_torque, nb_steps_under_water)
        self.LEG_DOWN = 12 / self.SCALE
        self.ARM_UP = 22 / self.SCALE
        self.LIMB_W, self.LIMB_H = 8 / self.SCALE, 28 / self.SCALE
        self.HAND_PART_W, self.HAND_PART_H = 4 / self.SCALE, 8 / self.SCALE
        self.LEG_H = self.LIMB_H
        self.TORQUE_PENALTY = 0.00035 / 5 # Legs + arms + hands
        self.BODY_HEIGHT = 45
        self.HEAD_HEIGHT = 20

        self.AGENT_WIDTH = 24 / self.SCALE
        self.AGENT_HEIGHT = self.BODY_HEIGHT / self.SCALE + \
                            self.HEAD_HEIGHT / self.SCALE + 0.2 + \
                            self.LEG_H * 2 - self.LEG_DOWN
        self.AGENT_CENTER_HEIGHT = self.LEG_H * 2 + self.LEG_DOWN

        self.remove_reward_on_head_angle = True

    def draw(self, world, init_x, init_y, force_to_center):
        head = world.CreateDynamicBody(
            position=(init_x, init_y + self.BODY_HEIGHT / self.SCALE / 2 + self.HEAD_HEIGHT / self.SCALE / 2 + 0.2),
            fixtures=fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in [
                    (-5, +10), (+5, +10),
                    (+5, -10), (-5, -10)]]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x1
            )
        )
        head.color1 = (0.5, 0.4, 0.9)
        head.color2 = (0.3, 0.3, 0.5)
        head.ApplyForceToCenter((force_to_center, 0), True)

        head.userData = CustomBodyUserData(True, is_contact_critical=True, name="head")
        self.body_parts.append(head)
        self.reference_head_object = head

        body = world.CreateDynamicBody(
            position=(init_x, init_y),
            fixtures=fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in [
                    (-12, +25), (+12, +25),
                    (+8, --15), (-8, --15)]]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x1  # collide only with ground
            )
        )
        body.color1 = (0.5, 0.4, 0.9)
        body.color2 = (0.3, 0.3, 0.5)

        body.userData = CustomBodyUserData(True, is_contact_critical=True, name="body")
        self.body_parts.append(body)
        
        rjd = revoluteJointDef(
            bodyA=head,
            bodyB=body,
            anchor=(init_x, init_y + self.BODY_HEIGHT / self.SCALE / 2),
            enableMotor=False,
            enableLimit=True,
            lowerAngle=-0.1 * np.pi,
            upperAngle=0.1 * np.pi,
        )

        world.CreateJoint(rjd)

        UPPER_LIMB_FD = fixtureDef(
            shape=polygonShape(box=(self.LIMB_W / 2, self.LIMB_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x1
        )

        LOWER_LIMB_FD = fixtureDef(
            shape=polygonShape(box=(0.8 * self.LIMB_W / 2, self.LIMB_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x1
        )

        HAND_PART_FD = fixtureDef(
            shape=polygonShape(box=(self.HAND_PART_W / 2, self.HAND_PART_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x1
        )

        # ARMS
        for j in [-1, -1]:
            upper = world.CreateDynamicBody(
                position=(init_x, init_y + self.LIMB_H / 2 + self.ARM_UP),
                # angle=(i * 0.05),
                fixtures=UPPER_LIMB_FD
            )
            upper.color1 = (0.6 - j / 10., 0.3 - j / 10., 0.5 - j / 10.)
            upper.color2 = (0.4 - j / 10., 0.2 - j / 10., 0.3 - j / 10.)
            rjd = revoluteJointDef(
                bodyA=body,
                bodyB=upper,
                anchor=(init_x, init_y + self.ARM_UP),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=-0.75 * 2 * np.pi,
                upperAngle=0,
            )

            upper.userData = CustomBodyUserData(False, name="upper_arm")
            self.body_parts.append(upper)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            lower = world.CreateDynamicBody(
                position=(init_x, init_y + self.LIMB_H * 3 / 2 + self.ARM_UP),
                # angle=(i * 0.05),
                fixtures=LOWER_LIMB_FD
            )
            lower.color1 = (0.6 - j / 10., 0.3 - j / 10., 0.5 - j / 10.)
            lower.color2 = (0.4 - j / 10., 0.2 - j / 10., 0.3 - j / 10.)
            rjd = revoluteJointDef(
                bodyA=upper,
                bodyB=lower,
                anchor=(init_x, init_y + self.LIMB_H + self.ARM_UP),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=0,
                upperAngle=0.75 * np.pi,
            )

            lower.userData = CustomBodyUserData(False, name="lower_arm")
            self.body_parts.append(lower)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            # hand
            prev_part = lower
            initial_y = init_y + self.LIMB_H * 2 + self.ARM_UP
            angle_boundaries = [[-0.5, 0.5]]
            nb_hand_parts = 1
            for u in range(nb_hand_parts):
                hand_part = world.CreateDynamicBody(
                    position=(init_x, initial_y + self.HAND_PART_H / 2 + self.HAND_PART_H * u),
                    fixtures=HAND_PART_FD
                )

                hand_part.color1 = (0.6 - j / 10., 0.3 - j / 10., 0.5 - j / 10.)
                hand_part.color2 = (0.4 - j / 10., 0.2 - j / 10., 0.3 - j / 10.)
                rjd = revoluteJointDef(
                    bodyA=prev_part,
                    bodyB=hand_part,
                    anchor=(init_x, initial_y + self.HAND_PART_H * u),
                    enableMotor=True,
                    enableLimit=True,
                    maxMotorTorque=self.MOTORS_TORQUE,
                    motorSpeed=1,
                    lowerAngle=angle_boundaries[u][0] * np.pi,
                    upperAngle=angle_boundaries[u][1] * np.pi,
                )

                hand_part.userData = CustomBodyUserData(True, name="hand")
                self.body_parts.append(hand_part)

                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(SPEED_HAND,
                                                           True,
                                                           contact_body=hand_part)
                self.motors.append(joint_motor)

                prev_part = hand_part

            hand_sensor_position = (init_x, initial_y + self.HAND_PART_H * nb_hand_parts)
            hand_sensor_part = world.CreateDynamicBody(
                position=hand_sensor_position,
                fixtures=self.SENSOR_FD,
                userData = CustomBodySensorUserData(True, False, "hand_sensor")
            )
            hand_sensor_part.color1 = (1, 0, 0)#(0.6 - j / 10., 0.3 - j / 10., 0.5 - j / 10.)
            hand_sensor_part.color2 = (1, 0, 0)#(0.4 - j / 10., 0.2 - j / 10., 0.3 - j / 10.)

            self.sensors.append(hand_sensor_part)
            world.CreateJoint(weldJointDef(
                bodyA = prev_part,
                bodyB = hand_sensor_part,
                anchor = hand_sensor_position
            ))



===== .\TeachMyAgent\environments\envs\bodies\climbers\ClimbingProfileChimpanzee.py =====
import numpy as np
from Box2D.b2 import edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener, weldJointDef

from TeachMyAgent.environments.envs.bodies.climbers.ClimberAbstractBody import ClimberAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData, CustomBodySensorUserData

SPEED_HIP     = 4
SPEED_KNEE    = 6
SPEED_HAND    = 8

class ClimbingProfileChimpanzee(ClimberAbstractBody):
    '''
        Climbing 'chimpanzee' embodiment.
    '''
    def __init__(self, scale, motors_torque=100, nb_steps_under_water=600):
        '''
            Creates a chimpanzee with:
            - a head
            - a chest
            - two arms (constituted of two limbs each)
            - two hands (constituted of one limbs each)
            - two sensors (each at the extremity of a hand) to detect collisions with graspable areas and grasp them.
            - two legs (constituted of two limbs each)

            No contact with ground is allowed.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                nb_steps_under_water: How many consecutive steps the embodiment can survive under water
        '''
        super(ClimbingProfileChimpanzee, self).__init__(scale, motors_torque, nb_steps_under_water)
        self.LEG_DOWN = 12 / self.SCALE
        self.ARM_UP = 22 / self.SCALE
        self.LIMB_W, self.LIMB_H = 8 / self.SCALE, 28 / self.SCALE
        self.HAND_PART_W, self.HAND_PART_H = 4 / self.SCALE, 8 / self.SCALE
        self.LEG_H = self.LIMB_H
        self.TORQUE_PENALTY = 0.00035 / 5 # Legs + arms + hands
        self.BODY_HEIGHT = 45
        self.HEAD_HEIGHT = 20

        self.AGENT_WIDTH = 24 / self.SCALE
        self.AGENT_HEIGHT = self.BODY_HEIGHT / self.SCALE + \
                            self.HEAD_HEIGHT / self.SCALE + 0.2 + \
                            self.LEG_H * 2 - self.LEG_DOWN
        self.AGENT_CENTER_HEIGHT = self.LEG_H * 2 + self.LEG_DOWN

        self.remove_reward_on_head_angle = True

    def draw(self, world, init_x, init_y, force_to_center):
        head = world.CreateDynamicBody(
            position=(init_x, init_y + self.BODY_HEIGHT / self.SCALE / 2 + self.HEAD_HEIGHT / self.SCALE / 2 + 0.2),
            fixtures=fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in [
                    (-5, +10), (+5, +10),
                    (+5, -10), (-5, -10)]]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x1
            )
        )
        head.color1 = (0.5, 0.4, 0.9)
        head.color2 = (0.3, 0.3, 0.5)
        head.ApplyForceToCenter((force_to_center, 0), True)

        head.userData = CustomBodyUserData(True, is_contact_critical=True, name="head")
        self.body_parts.append(head)
        self.reference_head_object = head

        body = world.CreateDynamicBody(
            position=(init_x, init_y),
            fixtures=fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in [
                    (-12, +25), (+12, +25),
                    (+8, -20), (-8, -20)]]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x1  # collide only with ground
            )
        )
        body.color1 = (0.5, 0.4, 0.9)
        body.color2 = (0.3, 0.3, 0.5)

        body.userData = CustomBodyUserData(True, is_contact_critical=True, name="body")
        self.body_parts.append(body)
        
        rjd = revoluteJointDef(
            bodyA=head,
            bodyB=body,
            anchor=(init_x, init_y + self.BODY_HEIGHT / self.SCALE / 2),
            enableMotor=False,
            enableLimit=True,
            lowerAngle=-0.1 * np.pi,
            upperAngle=0.1 * np.pi,
        )

        world.CreateJoint(rjd)

        UPPER_LIMB_FD = fixtureDef(
            shape=polygonShape(box=(self.LIMB_W / 2, self.LIMB_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x1
        )

        LOWER_LIMB_FD = fixtureDef(
            shape=polygonShape(box=(0.8 * self.LIMB_W / 2, self.LIMB_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x1
        )

        HAND_PART_FD = fixtureDef(
            shape=polygonShape(box=(self.HAND_PART_W / 2, self.HAND_PART_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x1
        )

        # LEGS
        for i in [+1, +1]:
                upper = world.CreateDynamicBody(
                    position=(init_x, init_y - self.LIMB_H / 2 - self.LEG_DOWN),
                    # angle=(i * 0.05),
                    fixtures=UPPER_LIMB_FD
                )
                upper.color1 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.)
                upper.color2 = (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
                rjd = revoluteJointDef(
                    bodyA=body,
                    bodyB=upper,
                    anchor=(init_x, init_y - self.LEG_DOWN),
                    enableMotor=True,
                    enableLimit=True,
                    maxMotorTorque=self.MOTORS_TORQUE,
                    motorSpeed=1,
                    lowerAngle=-0.3 * np.pi,
                    upperAngle=0.6 * np.pi,
                )

                upper.userData = CustomBodyUserData(False, name="upper_leg")
                self.body_parts.append(upper)

                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
                self.motors.append(joint_motor)

                lower = world.CreateDynamicBody(
                    position=(init_x, init_y - self.LIMB_H * 3 / 2 - self.LEG_DOWN),
                    # angle=(i * 0.05),
                    fixtures=LOWER_LIMB_FD
                )
                lower.color1 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.)
                lower.color2 = (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
                rjd = revoluteJointDef(
                    bodyA=upper,
                    bodyB=lower,
                    anchor=(init_x, init_y - self.LIMB_H - self.LEG_DOWN),
                    enableMotor=True,
                    enableLimit=True,
                    maxMotorTorque=self.MOTORS_TORQUE,
                    motorSpeed=1,
                    lowerAngle=-0.75 * np.pi,
                    upperAngle=-0.1,
                )

                lower.userData = CustomBodyUserData(True, name="lower_leg", is_contact_critical=True)
                self.body_parts.append(lower)

                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(SPEED_KNEE,
                                                           True,
                                                           contact_body=lower,
                                                           angle_correction=1.0)
                self.motors.append(joint_motor)

        # ARMS
        for j in [-1, -1]:
            upper = world.CreateDynamicBody(
                position=(init_x, init_y + self.LIMB_H / 2 + self.ARM_UP),
                # angle=(i * 0.05),
                fixtures=UPPER_LIMB_FD
            )
            upper.color1 = (0.6 - j / 10., 0.3 - j / 10., 0.5 - j / 10.)
            upper.color2 = (0.4 - j / 10., 0.2 - j / 10., 0.3 - j / 10.)
            rjd = revoluteJointDef(
                bodyA=body,
                bodyB=upper,
                anchor=(init_x, init_y + self.ARM_UP),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=-0.75 * 2 * np.pi,
                upperAngle=0,
            )

            upper.userData = CustomBodyUserData(False, name="upper_arm")
            self.body_parts.append(upper)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            lower = world.CreateDynamicBody(
                position=(init_x, init_y + self.LIMB_H * 3 / 2 + self.ARM_UP),
                # angle=(i * 0.05),
                fixtures=LOWER_LIMB_FD
            )
            lower.color1 = (0.6 - j / 10., 0.3 - j / 10., 0.5 - j / 10.)
            lower.color2 = (0.4 - j / 10., 0.2 - j / 10., 0.3 - j / 10.)
            rjd = revoluteJointDef(
                bodyA=upper,
                bodyB=lower,
                anchor=(init_x, init_y + self.LIMB_H + self.ARM_UP),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=0,
                upperAngle=0.75 * np.pi,
            )

            lower.userData = CustomBodyUserData(False, name="lower_arm")
            self.body_parts.append(lower)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            # hand
            prev_part = lower
            initial_y = init_y + self.LIMB_H * 2 + self.ARM_UP
            angle_boundaries = [[-0.5, 0.5]]
            nb_hand_parts = 1
            for u in range(nb_hand_parts):
                hand_part = world.CreateDynamicBody(
                    position=(init_x, initial_y + self.HAND_PART_H / 2 + self.HAND_PART_H * u),
                    fixtures=HAND_PART_FD
                )

                hand_part.color1 = (0.6 - j / 10., 0.3 - j / 10., 0.5 - j / 10.)
                hand_part.color2 = (0.4 - j / 10., 0.2 - j / 10., 0.3 - j / 10.)
                rjd = revoluteJointDef(
                    bodyA=prev_part,
                    bodyB=hand_part,
                    anchor=(init_x, initial_y + self.HAND_PART_H * u),
                    enableMotor=True,
                    enableLimit=True,
                    maxMotorTorque=self.MOTORS_TORQUE,
                    motorSpeed=1,
                    lowerAngle=angle_boundaries[u][0] * np.pi,
                    upperAngle=angle_boundaries[u][1] * np.pi,
                )

                hand_part.userData = CustomBodyUserData(True, name="hand")
                self.body_parts.append(hand_part)

                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(SPEED_HAND,
                                                           True,
                                                           contact_body=hand_part)
                self.motors.append(joint_motor)

                prev_part = hand_part

            hand_sensor_position = (init_x, initial_y + self.HAND_PART_H * nb_hand_parts)
            hand_sensor_part = world.CreateDynamicBody(
                position=hand_sensor_position,
                fixtures=self.SENSOR_FD,
                userData = CustomBodySensorUserData(True, False, "hand_sensor")
            )
            hand_sensor_part.color1 = (1, 0, 0)#(0.6 - j / 10., 0.3 - j / 10., 0.5 - j / 10.)
            hand_sensor_part.color2 = (1, 0, 0)#(0.4 - j / 10., 0.2 - j / 10., 0.3 - j / 10.)

            self.sensors.append(hand_sensor_part)
            world.CreateJoint(weldJointDef(
                bodyA = prev_part,
                bodyB = hand_sensor_part,
                anchor = hand_sensor_position
            ))



===== .\TeachMyAgent\environments\envs\bodies\climbers\__init__.py =====


===== .\TeachMyAgent\environments\envs\bodies\swimmers\FishBody.py =====
import numpy as np
from Box2D.b2 import edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener

from TeachMyAgent.environments.envs.bodies.swimmers.SwimmerAbstractBody import SwimmerAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData

# Head
HULL_POLYGONS = [
    (-20, +12), (+6, +12),
     (+15, +4), (+15, -4),
     (+6, -12), (-20, -12)
]

BODY_P1 = [
    (-8, +9), (+8, +12),
     (+8, -12), (-8, -9)
]

BODY_P2 = [
    (-8, +4), (+8, +9),
     (+8, -9), (-8, -4)
]

# Tail
BODY_P3 = [
    (-4, +2), (+4, +4),
     (+4, -4), (-4, -2)
]

FIN = [
    (-1, -10), (-1, +10),
     (+1, +10), (+1, -10)
]

HULL_BOTTOM_WIDTH = 35
SPEED_HIP     = 4
SPEED_KNEE    = 6

class FishBody(SwimmerAbstractBody):
    '''
        Swimming 'fish' embodiment.
    '''
    def __init__(self, scale, density, motors_torque=80, nb_steps_outside_water=600):
        '''
            Creates a fish with three body parts, a fin and a tale.

            Head contact is allowed for the fish.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                density: Water density (in order to make the agent in a zero-gravity-like setup)
                nb_steps_outside_water: How many consecutive steps the embodiment can survive outside water
        '''
        super(FishBody, self).__init__(scale, motors_torque, density, nb_steps_outside_water)
        self.TORQUE_PENALTY = 0.00035

        self.AGENT_WIDTH = HULL_BOTTOM_WIDTH / self.SCALE
        self.AGENT_HEIGHT = 18 /self.SCALE
        self.AGENT_CENTER_HEIGHT = 9 / self.SCALE

        self.remove_reward_on_head_angle = True

        self.fins = []
        self.tail = None

    def draw(self, world, init_x, init_y, force_to_center):
        init_y = init_y + 1
        #### HULL ####
        HULL_FD = fixtureDef(
            shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in HULL_POLYGONS]),
            density=self.DENSITY,
            friction=0.1,
            categoryBits=0x20,
            maskBits=0x000F)  # 0.99 bouncy

        hull = world.CreateDynamicBody(
            position=(init_x, init_y),
            fixtures=HULL_FD
        )
        hull.color1 = (0.5, 0.4, 0.9)
        hull.color2 = (0.3, 0.3, 0.5)
        # hull.ApplyForceToCenter((force_to_center, 0), True)

        hull.userData = CustomBodyUserData(True, is_contact_critical=False, name="head")
        self.body_parts.append(hull)
        self.reference_head_object = hull

        #### P1 ####
        body_p1_x = init_x - 35 / 2 / self.SCALE - 16 / 2 / self.SCALE
        BODY_P1_FD = fixtureDef(
            shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in BODY_P1]),
            density=self.DENSITY,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        body_p1 = world.CreateDynamicBody(
            position=(body_p1_x, init_y),
            fixtures=BODY_P1_FD
        )
        body_p1.color1 = (0.5, 0.4, 0.9)
        body_p1.color2 = (0.3, 0.3, 0.5)

        rjd = revoluteJointDef(
            bodyA=hull,
            bodyB=body_p1,
            anchor=(init_x - 35 / 2 / self.SCALE, init_y),
            enableMotor=True,
            enableLimit=True,
            maxMotorTorque=self.MOTORS_TORQUE,
            motorSpeed=1,
            lowerAngle=-0.1 * np.pi,
            upperAngle=0.2 * np.pi,
        )

        body_p1.userData = CustomBodyUserData(True, name="body")
        self.body_parts.append(body_p1)

        joint_motor = world.CreateJoint(rjd)
        joint_motor.userData = CustomMotorUserData(SPEED_KNEE, True, contact_body=body_p1)
        self.motors.append(joint_motor)

        #### P2 ####
        body_p2_x = body_p1_x - 16 / 2 / self.SCALE - 16 / 2 / self.SCALE
        BODY_P2_FD = fixtureDef(
            shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in BODY_P2]),
            density=self.DENSITY,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        body_p2 = world.CreateDynamicBody(
            position=(body_p2_x, init_y),
            fixtures=BODY_P2_FD
        )
        body_p2.color1 = (0.5, 0.4, 0.9)
        body_p2.color2 = (0.3, 0.3, 0.5)

        rjd = revoluteJointDef(
            bodyA=body_p1,
            bodyB=body_p2,
            anchor=(body_p1_x - 16 / 2 / self.SCALE, init_y),
            enableMotor=True,
            enableLimit=True,
            maxMotorTorque=self.MOTORS_TORQUE,
            motorSpeed=1,
            lowerAngle=-0.15 * np.pi,
            upperAngle=0.15 * np.pi,
        )

        body_p2.userData = CustomBodyUserData(True, name="body")
        self.body_parts.append(body_p2)

        joint_motor = world.CreateJoint(rjd)
        joint_motor.userData = CustomMotorUserData(SPEED_KNEE, True, contact_body=body_p2)
        self.motors.append(joint_motor)

        #### P3 ####
        body_p3_x = body_p2_x - 16 / 2 / self.SCALE - 8 / 2 / self.SCALE
        BODY_P3_FD = fixtureDef(
            shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in BODY_P3]),
            density=self.DENSITY,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        body_p3 = world.CreateDynamicBody(
            position=(body_p3_x, init_y),
            fixtures=BODY_P3_FD
        )
        body_p3.color1 = (0.5, 0.4, 0.9)
        body_p3.color2 = (0.3, 0.3, 0.5)

        rjd = revoluteJointDef(
            bodyA=body_p2,
            bodyB=body_p3,
            anchor=(body_p2_x - 16 / 2 / self.SCALE, init_y),
            enableMotor=True,
            enableLimit=True,
            maxMotorTorque=self.MOTORS_TORQUE,
            motorSpeed=1,
            lowerAngle=-0.3 * np.pi,
            upperAngle=0.3 * np.pi,
        )

        body_p3.userData = CustomBodyUserData(True, name="body")
        self.body_parts.append(body_p3)
        self.tail = body_p3

        joint_motor = world.CreateJoint(rjd)
        joint_motor.userData = CustomMotorUserData(SPEED_KNEE, True, contact_body=body_p3)
        self.motors.append(joint_motor)

        #### FIN ####
        FIN_FD = fixtureDef(
            shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in FIN]),
            density=self.DENSITY,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        fin_positions = [
            # [init_x + 35 / 2 / self.SCALE / 2, init_y],
            # [init_x - 35 / 2 / self.SCALE / 2, init_y],
            [init_x, init_y - 22 / 2 / self.SCALE + 0.2],
            # [init_x - 35 / 2 / self.SCALE / 2, init_y - 22 / 2 / self.SCALE + 0.1],
        ]

        fin_angle = -0.2 * np.pi
        middle_fin_x_distance = np.sin(fin_angle) * 20 / 2 / self.SCALE
        middle_fin_y_distance = np.cos(fin_angle) * 20 / 2 / self.SCALE

        for fin_pos in fin_positions:
            current_fin_x = fin_pos[0] + middle_fin_x_distance
            current_fin_y = fin_pos[1] - middle_fin_y_distance

            fin = world.CreateDynamicBody(
                position=(current_fin_x, current_fin_y),
                fixtures=FIN_FD,
                angle=fin_angle
            )
            fin.color1 = (0.5, 0.4, 0.9)
            fin.color2 = (0.3, 0.3, 0.5)

            rjd = revoluteJointDef(
                bodyA=hull,
                bodyB=fin,
                anchor=(fin_pos[0], fin_pos[1]),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=-0.3 * np.pi,
                upperAngle=0.2 * np.pi,
            )

            fin.userData = CustomBodyUserData(True, name="fin")
            self.body_parts.append(fin)
            self.fins.append(fin)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_KNEE, True, contact_body=fin)
            self.motors.append(joint_motor)

===== .\TeachMyAgent\environments\envs\bodies\swimmers\SwimmerAbstractBody.py =====
from TeachMyAgent.environments.envs.bodies.AbstractBody import AbstractBody
from TeachMyAgent.environments.envs.bodies.BodyTypesEnum import BodyTypesEnum

class SwimmerAbstractBody(AbstractBody):
    '''
        Base class for swimmers.
    '''
    def __init__(self, scale, motors_torque, density, nb_steps_outside_water):
        '''
            Creates a swimmer, which cannot survive outside water.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                density: Water density (in order to make the agent in a zero-gravity-like setup)
                nb_steps_outside_water: How many consecutive steps the embodiment can survive outside water
        '''
        super(SwimmerAbstractBody, self).__init__(scale, motors_torque)

        self.body_type = BodyTypesEnum.SWIMMER
        self.nb_steps_can_survive_outside_water = nb_steps_outside_water
        # set the embodiment's density to the same value as water so that it will be in a zero-gravity setup
        self.DENSITY = density - 0.01 # Make it a little lighter such that it slowly goes up when no action is done

===== .\TeachMyAgent\environments\envs\bodies\swimmers\__init__.py =====


===== .\TeachMyAgent\environments\envs\bodies\walkers\BigQuadruBody.py =====
import numpy as np
from Box2D.b2 import edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener

from TeachMyAgent.environments.envs.bodies.walkers.WalkerAbstractBody import WalkerAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData

HULL_POLYGONS = [
        [(-46, +13), (+6, +13), (+50, +5),
        (+50, -12), (-46, -12)]
    ]
HULL_BOTTOM_WIDTH = 96
SPEED_HIP     = 4
SPEED_KNEE    = 6

class BigQuadruBody(WalkerAbstractBody):
    '''
        New version of the Quadrupedal walker implemented in https://gym.openai.com/envs/BipedalWalker-v2/.

        In the initial version, the embodiment is created with an angle on legs, but position are not set according to this.
        This results in bodies with wrong positions that Box2D's solver has to reposition at the first step of the environment.
        This new version uses straight legs and fixed bad positions.
    '''
    def __init__(self, scale, motors_torque=300, nb_steps_under_water=600, reset_on_hull_critical_contact=False):
        '''
            Creates a bipedal walker

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                 nb_steps_under_water: How many consecutive steps the embodiment can survive under water
                reset_on_hull_critical_contact: Whether a contact detected with the head should stop the episode
        '''
        super(BigQuadruBody, self).__init__(scale, motors_torque, nb_steps_under_water)
        self.LEG_DOWN = 3 / self.SCALE  # 0 = center of hull
        self.LEG_W, self.LEG_H = 10 / self.SCALE, 51 / self.SCALE
        self.TORQUE_PENALTY = 0.00035 / 2 # 2 paris of legs
        self.reset_on_hull_critical_contact = reset_on_hull_critical_contact

        self.AGENT_WIDTH = HULL_BOTTOM_WIDTH / self.SCALE
        self.AGENT_HEIGHT = 25 / self.SCALE + \
                            self.LEG_H * 2 - self.LEG_DOWN
        self.AGENT_CENTER_HEIGHT = self.LEG_H * 2 + self.LEG_DOWN

    def draw(self, world, init_x, init_y, force_to_center):
        HULL_FIXTURES = [
            fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in polygon]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x000F)
            for polygon in HULL_POLYGONS
        ]

        LEG_FD = fixtureDef(
            shape=polygonShape(box=(self.LEG_W / 2, self.LEG_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        LOWER_FD = fixtureDef(
            shape=polygonShape(box=(0.8 * self.LEG_W / 2, self.LEG_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        hull = world.CreateDynamicBody(
            position=(init_x, init_y),
            fixtures=HULL_FIXTURES
        )

        hull.color1 = (0.5, 0.4, 0.9)
        hull.color2 = (0.3, 0.3, 0.5)
        hull.ApplyForceToCenter((force_to_center, 0), True)

        hull.userData = CustomBodyUserData(True, is_contact_critical=self.reset_on_hull_critical_contact, name="hull")
        self.body_parts.append(hull)
        self.reference_head_object = hull

        for x_anchor in [-0.7, 0.5]:
            absolute_x = init_x + np.interp(x_anchor, [-1,1], [-HULL_BOTTOM_WIDTH / 2 / self.SCALE, HULL_BOTTOM_WIDTH / 2 / self.SCALE])
            for i in [-1, +1]:
                leg = world.CreateDynamicBody(
                    position=(absolute_x, init_y - self.LEG_H / 2 - self.LEG_DOWN),
                    #angle=(i * 0.05),
                    fixtures=LEG_FD
                )
                leg.color1 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.)
                leg.color2 = (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
                rjd = revoluteJointDef(
                    bodyA=hull,
                    bodyB=leg,
                    anchor=(absolute_x, init_y - self.LEG_DOWN),
                    enableMotor=True,
                    enableLimit=True,
                    maxMotorTorque=self.MOTORS_TORQUE,
                    motorSpeed=i,
                    lowerAngle=-0.8,
                    upperAngle=1.1,
                )

                leg.userData = CustomBodyUserData(False, name="leg")
                self.body_parts.append(leg)

                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
                self.motors.append(joint_motor)

                lower = world.CreateDynamicBody(
                    position=(absolute_x, init_y - self.LEG_H * 3 / 2 - self.LEG_DOWN),
                    #angle=(i * 0.05),
                    fixtures=LOWER_FD
                )
                lower.color1 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.)
                lower.color2 = (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
                rjd = revoluteJointDef(
                    bodyA=leg,
                    bodyB=lower,
                    anchor=(absolute_x, init_y - self.LEG_DOWN - self.LEG_H),
                    enableMotor=True,
                    enableLimit=True,
                    maxMotorTorque=self.MOTORS_TORQUE,
                    motorSpeed=1,
                    lowerAngle=-1.6,
                    upperAngle=-0.1,
                )

                lower.userData = CustomBodyUserData(True, name="lower")
                self.body_parts.append(lower)

                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(
                    SPEED_KNEE,
                    True,
                    contact_body=lower,
                    angle_correction=1.0)
                self.motors.append(joint_motor)

===== .\TeachMyAgent\environments\envs\bodies\walkers\ClassicBipedalBody.py =====
import numpy as np
from Box2D.b2 import edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener

from TeachMyAgent.environments.envs.bodies.walkers.WalkerAbstractBody import WalkerAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData

HULL_POLYGONS = [
    [(-30, +9), (+6, +9), (+34, +1),
    (+34, -8), (-30, -8)]
]
HULL_BOTTOM_WIDTH = 64
SPEED_HIP     = 4
SPEED_KNEE    = 6

class ClassicBipedalBody(WalkerAbstractBody):
    '''
        New version of the Bipedal walker implemented in https://gym.openai.com/envs/BipedalWalker-v2/.

        In the initial version, the embodiment is created with an angle on legs, but position are not set according to this.
        This results in bodies with wrong positions that Box2D's solver has to reposition at the first step of the environment.
        This new version uses straight legs and fixed bad positions.
    '''
    def __init__(self, scale, motors_torque=120, nb_steps_under_water=600, reset_on_hull_critical_contact=False):
        '''
            Creates a bipedal walker.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                nb_steps_under_water: How many consecutive steps the embodiment can survive under water
                reset_on_hull_critical_contact: Whether a contact detected with the head should stop the episode
        '''
        super(ClassicBipedalBody, self).__init__(scale, motors_torque, nb_steps_under_water)
        self.LEG_DOWN = 3 / self.SCALE # 0 = center of hull
        self.LEG_W, self.LEG_H = 8 / self.SCALE, 34 / self.SCALE
        self.TORQUE_PENALTY = 0.00035
        self.reset_on_hull_critical_contact = reset_on_hull_critical_contact

        self.AGENT_WIDTH = HULL_BOTTOM_WIDTH / self.SCALE
        self.AGENT_HEIGHT = 17 / self.SCALE + \
                            self.LEG_H * 2 - self.LEG_DOWN
        self.AGENT_CENTER_HEIGHT = self.LEG_H * 2 + self.LEG_DOWN

    def draw(self, world, init_x, init_y, force_to_center):
        HULL_FIXTURES = [
            fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in polygon]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x000F)  # 0.99 bouncy
            for polygon in HULL_POLYGONS
        ]

        LEG_FD = fixtureDef(
            shape=polygonShape(box=(self.LEG_W / 2, self.LEG_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        LOWER_FD = fixtureDef(
            shape=polygonShape(box=(0.8 * self.LEG_W / 2, self.LEG_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        hull = world.CreateDynamicBody(
            position=(init_x, init_y),
            fixtures=HULL_FIXTURES
        )
        hull.color1 = (0.5, 0.4, 0.9)
        hull.color2 = (0.3, 0.3, 0.5)
        hull.ApplyForceToCenter((force_to_center, 0), True)

        hull.userData = CustomBodyUserData(True, is_contact_critical=self.reset_on_hull_critical_contact, name="hull")
        self.body_parts.append(hull)
        self.reference_head_object = hull

        for i in [-1, +1]:
            leg = world.CreateDynamicBody(
                position=(init_x, init_y - self.LEG_H / 2 - self.LEG_DOWN),
                #angle=(i * 0.05),#2¬∞
                fixtures=LEG_FD
            )
            leg.color1 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.)
            leg.color2 = (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
            rjd = revoluteJointDef(
                bodyA=hull,
                bodyB=leg,
                anchor=(init_x, init_y - self.LEG_DOWN),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=i,
                lowerAngle=-0.8,
                upperAngle=1.1,
            )

            leg.userData = CustomBodyUserData(False, name="leg")
            self.body_parts.append(leg)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            lower = world.CreateDynamicBody(
                position=(init_x, init_y - self.LEG_H * 3 / 2 - self.LEG_DOWN),
                #angle=(i * 0.05), #2¬∞
                fixtures=LOWER_FD
            )
            lower.color1 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.)
            lower.color2 = (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
            rjd = revoluteJointDef(
                bodyA=leg,
                bodyB=lower,
                anchor=(init_x, init_y - self.LEG_DOWN - self.LEG_H),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=-1.6,
                upperAngle=-0.1,
            )

            lower.userData = CustomBodyUserData(True, name="lower")
            self.body_parts.append(lower)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(
                SPEED_KNEE,
                True,
                contact_body=lower,
                angle_correction=1.0)
            self.motors.append(joint_motor)

===== .\TeachMyAgent\environments\envs\bodies\walkers\MillipedeBody.py =====
# TeachMyAgent/environments/envs/bodies/walkers/MillipedeBody.py
import numpy as np
from Box2D.b2 import edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener

from TeachMyAgent.environments.envs.bodies.walkers.WalkerAbstractBody import WalkerAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData

MAIN_BODY_POLYGONS = [
    [(-10, +10), (+10, +10),
     (+10, -10), (-10, -10)]
]
MAIN_BODY_BOTTOM_WIDTH = 20
SPEED_HIP     = 4
SPEED_KNEE    = 6

class MillipedeBody(WalkerAbstractBody):
    '''
        Millipede embodiment with controllable number of bodies.
    '''
    def __init__(self, scale, motors_torque=200, nb_of_bodies=4, nb_steps_under_water=600,
                 reset_on_hull_critical_contact=False):
        '''
            Creates a millipede walker.

            Each of its body has two legs. The head is considered as the rightmost body.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                nb_of_bodies: Number of square bodies the agent has
                 nb_steps_under_water: How many consecutive steps the embodiment can survive under water
                reset_on_hull_critical_contact: Whether a contact detected with the head should stop the episode
        '''
        super(MillipedeBody, self).__init__(scale, motors_torque, nb_steps_under_water)
        self.LEG_DOWN = 3 / self.SCALE  # 0 = center of hull
        self.LEG_W, self.LEG_H = 4 / self.SCALE, 10 / self.SCALE
        self.TORQUE_PENALTY = 0.00035
        self.reset_on_hull_critical_contact = reset_on_hull_critical_contact

        self.nb_of_bodies = nb_of_bodies
        self.TORQUE_PENALTY = 0.00035 / self.nb_of_bodies # 1 body = 1 pair of legs

        self.AGENT_WIDTH = MAIN_BODY_BOTTOM_WIDTH / self.SCALE * self.nb_of_bodies
        self.AGENT_HEIGHT = 20 / self.SCALE + \
                            self.LEG_H * 2 - self.LEG_DOWN
        self.AGENT_CENTER_HEIGHT = self.LEG_H * 2 + self.LEG_DOWN

    def draw(self, world, init_x, init_y, force_to_center):
        MAIN_BODY_FIXTURES = [
            fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in polygon]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x000F)
            for polygon in MAIN_BODY_POLYGONS
        ]
        LEG_FD = fixtureDef(shape=polygonShape(box=(self.LEG_W / 2, self.LEG_H / 2)), density=1.0, restitution=0.0, categoryBits=0x20, maskBits=0x000F)
        LOWER_FD = fixtureDef(shape=polygonShape(box=(0.8 * self.LEG_W / 2, self.LEG_H / 2)), density=1.0, restitution=0.0, categoryBits=0x20, maskBits=0x000F)

        # START FIX: Slightly raise the agent to prevent initial ground clipping
        init_y = init_y + 2 / self.SCALE
        # END FIX
        
        init_x = init_x - MAIN_BODY_BOTTOM_WIDTH / self.SCALE * self.nb_of_bodies / 2
        previous_main_body = None
        for j in range(self.nb_of_bodies):
            main_body_x = init_x + j * (MAIN_BODY_BOTTOM_WIDTH / self.SCALE)
            main_body = world.CreateDynamicBody(position=(main_body_x, init_y), fixtures=MAIN_BODY_FIXTURES)
            main_body.color1, main_body.color2 = (0.5, 0.4, 0.9), (0.3, 0.3, 0.5)
            main_body.ApplyForceToCenter((force_to_center, 0), True)
            main_body.userData = CustomBodyUserData(True, is_contact_critical=False, name="body")
            self.body_parts.append(main_body)

            for i in [-1, +1]:
                leg = world.CreateDynamicBody(position=(main_body_x, init_y - self.LEG_H / 2 - self.LEG_DOWN), fixtures=LEG_FD)
                leg.color1, leg.color2 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.), (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
                rjd = revoluteJointDef(bodyA=main_body, bodyB=leg, anchor=(main_body_x, init_y - self.LEG_DOWN), enableMotor=True, enableLimit=True, maxMotorTorque=self.MOTORS_TORQUE, motorSpeed=i, lowerAngle=-0.8, upperAngle=1.1)
                leg.userData = CustomBodyUserData(False, name="leg")
                self.body_parts.append(leg)
                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
                self.motors.append(joint_motor)
                lower = world.CreateDynamicBody(position=(main_body_x, init_y - self.LEG_H * 3 / 2 - self.LEG_DOWN), fixtures=LOWER_FD)
                lower.color1, lower.color2 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.), (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
                rjd = revoluteJointDef(bodyA=leg, bodyB=lower, anchor=(main_body_x, init_y - self.LEG_DOWN - self.LEG_H), enableMotor=True, enableLimit=True, maxMotorTorque=self.MOTORS_TORQUE, motorSpeed=1, lowerAngle=-1.6, upperAngle=-0.1)
                lower.userData = CustomBodyUserData(True, name="lower")
                self.body_parts.append(lower)
                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(SPEED_KNEE, True, contact_body=lower, angle_correction=1.0)
                self.motors.append(joint_motor)

            # START FIX: Add a flexible joint between body segments to prevent solver instability
            if previous_main_body is not None:
                rjd = revoluteJointDef(
                    bodyA=previous_main_body,
                    bodyB=main_body,
                    anchor=(main_body_x - MAIN_BODY_BOTTOM_WIDTH / self.SCALE / 2, init_y),
                    enableMotor=False,
                    enableLimit=True,
                    lowerAngle=-0.2 * np.pi,
                    upperAngle=0.2 * np.pi,
                )
                world.CreateJoint(rjd)
            # END FIX
            previous_main_body = main_body

        self.reference_head_object = previous_main_body
        self.reference_head_object.userData.is_contact_critical = self.reset_on_hull_critical_contact

===== .\TeachMyAgent\environments\envs\bodies\walkers\ProfileChimpanzee.py =====
import numpy as np
from Box2D.b2 import edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener, weldJointDef

from TeachMyAgent.environments.envs.bodies.walkers.WalkerAbstractBody import WalkerAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData, CustomBodySensorUserData

SPEED_HIP     = 4
SPEED_KNEE    = 6
SPEED_HAND    = 8

class ProfileChimpanzee(WalkerAbstractBody):
    '''
        Walking chimpanzee embodiment.
    '''
    def __init__(self, scale, motors_torque=100, nb_steps_under_water=600, reset_on_hull_critical_contact=False):
        '''
            Creates a chimpanzee walker.

            The morphology has:
            - a head
            - a chest
            - two legs
            - two arms
            - two hands (with 3 limbs)

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                nb_of_bodies: Number of square bodies the agent has
                 nb_steps_under_water: How many consecutive steps the embodiment can survive under water
                reset_on_hull_critical_contact: Whether a contact detected with the head should stop the episode
        '''
        super(ProfileChimpanzee, self).__init__(scale, motors_torque, nb_steps_under_water)
        self.LEG_DOWN = 12 / self.SCALE
        self.ARM_UP = 22 / self.SCALE
        self.LIMB_W, self.LIMB_H = 8 / self.SCALE, 28 / self.SCALE
        self.HAND_PART_W, self.HAND_PART_H = 4 / self.SCALE, 8 / self.SCALE
        self.LEG_H = self.LIMB_H
        self.TORQUE_PENALTY = 0.00035 / 5 # Legs + arms + hands
        self.BODY_HEIGHT = 45
        self.HEAD_HEIGHT = 20
        self.reset_on_hull_critical_contact = reset_on_hull_critical_contact

        self.AGENT_WIDTH = 24 / self.SCALE
        self.AGENT_HEIGHT = self.BODY_HEIGHT / self.SCALE + \
                            self.HEAD_HEIGHT / self.SCALE + 0.2 + \
                            self.LEG_H * 2 - self.LEG_DOWN
        self.AGENT_CENTER_HEIGHT = self.LEG_H * 2 + self.LEG_DOWN

        self.remove_reward_on_head_angle = True

    def draw(self, world, init_x, init_y, force_to_center):
        head = world.CreateDynamicBody(
            position=(init_x, init_y + self.BODY_HEIGHT / self.SCALE / 2 + self.HEAD_HEIGHT / self.SCALE / 2 + 0.2),
            fixtures=fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in [
                    (-5, +10), (+5, +10),
                    (+5, -10), (-5, -10)]]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x1
            )
        )
        head.color1 = (0.5, 0.4, 0.9)
        head.color2 = (0.3, 0.3, 0.5)
        head.ApplyForceToCenter((force_to_center, 0), True)

        head.userData = CustomBodyUserData(True, is_contact_critical=True, name="head")
        self.body_parts.append(head)
        self.reference_head_object = head

        body = world.CreateDynamicBody(
            position=(init_x, init_y),
            fixtures=fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in [
                    (-12, +25), (+12, +25),
                    (+8, -15), (-8, --15)]]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x1  # collide only with ground
            )
        )
        body.color1 = (0.5, 0.4, 0.9)
        body.color2 = (0.3, 0.3, 0.5)

        body.userData = CustomBodyUserData(True, is_contact_critical=self.reference_head_object, name="body")
        self.body_parts.append(body)
        
        rjd = revoluteJointDef(
            bodyA=head,
            bodyB=body,
            anchor=(init_x, init_y + self.BODY_HEIGHT / self.SCALE / 2),
            enableMotor=False,
            enableLimit=True,
            lowerAngle=-0.1 * np.pi,
            upperAngle=0.1 * np.pi,
        )

        world.CreateJoint(rjd)

        UPPER_LIMB_FD = fixtureDef(
            shape=polygonShape(box=(self.LIMB_W / 2, self.LIMB_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x1
        )

        LOWER_LIMB_FD = fixtureDef(
            shape=polygonShape(box=(0.8 * self.LIMB_W / 2, self.LIMB_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x1
        )

        HAND_PART_FD = fixtureDef(
            shape=polygonShape(box=(self.HAND_PART_W / 2, self.HAND_PART_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x1
        )

        # LEGS
        for i in [+1, +1]:
                upper = world.CreateDynamicBody(
                    position=(init_x, init_y - self.LIMB_H / 2 - self.LEG_DOWN),
                    # angle=(i * 0.05),
                    fixtures=UPPER_LIMB_FD
                )
                upper.color1 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.)
                upper.color2 = (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
                rjd = revoluteJointDef(
                    bodyA=body,
                    bodyB=upper,
                    anchor=(init_x, init_y - self.LEG_DOWN),
                    enableMotor=True,
                    enableLimit=True,
                    maxMotorTorque=self.MOTORS_TORQUE,
                    motorSpeed=1,
                    lowerAngle=-0.3 * np.pi,
                    upperAngle=0.6 * np.pi,
                )

                upper.userData = CustomBodyUserData(False, name="upper_leg")
                self.body_parts.append(upper)

                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
                self.motors.append(joint_motor)

                lower = world.CreateDynamicBody(
                    position=(init_x, init_y - self.LIMB_H * 3 / 2 - self.LEG_DOWN),
                    # angle=(i * 0.05),
                    fixtures=LOWER_LIMB_FD
                )
                lower.color1 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.)
                lower.color2 = (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
                rjd = revoluteJointDef(
                    bodyA=upper,
                    bodyB=lower,
                    anchor=(init_x, init_y - self.LIMB_H - self.LEG_DOWN),
                    enableMotor=True,
                    enableLimit=True,
                    maxMotorTorque=self.MOTORS_TORQUE,
                    motorSpeed=1,
                    lowerAngle=-0.75 * np.pi,
                    upperAngle=-0.1,
                )

                lower.userData = CustomBodyUserData(True, name="lower_leg")
                self.body_parts.append(lower)

                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(SPEED_KNEE,
                                                           True,
                                                           contact_body=lower,
                                                           angle_correction=1.0)
                self.motors.append(joint_motor)

        # ARMS
        for j in [-1, -1]:
            upper = world.CreateDynamicBody(
                position=(init_x, init_y - self.LIMB_H / 2 + self.ARM_UP),
                # angle=(i * 0.05),
                fixtures=UPPER_LIMB_FD
            )
            upper.color1 = (0.6 - j / 10., 0.3 - j / 10., 0.5 - j / 10.)
            upper.color2 = (0.4 - j / 10., 0.2 - j / 10., 0.3 - j / 10.)
            rjd = revoluteJointDef(
                bodyA=body,
                bodyB=upper,
                anchor=(init_x, init_y + self.ARM_UP),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=-0.5 * np.pi,
                upperAngle=0.8 * np.pi,
            )

            upper.userData = CustomBodyUserData(False, name="upper_arm")
            self.body_parts.append(upper)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            lower = world.CreateDynamicBody(
                position=(init_x, init_y - self.LIMB_H * 3 / 2 + self.ARM_UP),
                # angle=(i * 0.05),
                fixtures=LOWER_LIMB_FD
            )
            lower.color1 = (0.6 - j / 10., 0.3 - j / 10., 0.5 - j / 10.)
            lower.color2 = (0.4 - j / 10., 0.2 - j / 10., 0.3 - j / 10.)
            rjd = revoluteJointDef(
                bodyA=upper,
                bodyB=lower,
                anchor=(init_x, init_y - self.LIMB_H + self.ARM_UP),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=0,
                upperAngle=0.75 * np.pi,
            )

            lower.userData = CustomBodyUserData(False, name="lower_arm")
            self.body_parts.append(lower)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            # hand
            prev_part = lower
            initial_y = init_y - self.LIMB_H * 2 + self.ARM_UP
            angle_boundaries = [[-0.4, 0.35], [-0.5, 0], [-0.8, 0]]
            nb_hand_parts = 3
            for u in range(nb_hand_parts):
                hand_part = world.CreateDynamicBody(
                    position=(init_x, initial_y - self.HAND_PART_H / 2 - self.HAND_PART_H * u),
                    fixtures=HAND_PART_FD
                )

                hand_part.color1 = (0.6 - j / 10., 0.3 - j / 10., 0.5 - j / 10.)
                hand_part.color2 = (0.4 - j / 10., 0.2 - j / 10., 0.3 - j / 10.)
                rjd = revoluteJointDef(
                    bodyA=prev_part,
                    bodyB=hand_part,
                    anchor=(init_x, initial_y - self.HAND_PART_H * u),
                    enableMotor=True,
                    enableLimit=True,
                    maxMotorTorque=self.MOTORS_TORQUE,
                    motorSpeed=1,
                    lowerAngle=angle_boundaries[u][0] * np.pi,
                    upperAngle=angle_boundaries[u][1] * np.pi,
                )

                hand_part.userData = CustomBodyUserData(True, name="hand")
                self.body_parts.append(hand_part)

                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(SPEED_HAND,
                                                           True,
                                                           contact_body=hand_part)
                self.motors.append(joint_motor)

                prev_part = hand_part



===== .\TeachMyAgent\environments\envs\bodies\walkers\SmallBipedalBody.py =====
from Box2D.b2 import fixtureDef, polygonShape, revoluteJointDef
from TeachMyAgent.environments.envs.bodies.walkers.WalkerAbstractBody import WalkerAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData

HULL_POLYGONS = [
    [(-15, +5), (+15, +5), (+15, -5), (-15, -5)]
]
HULL_BOTTOM_WIDTH = 30
HULL_DENSITY = 2.0

SPEED_HIP     = 4
SPEED_KNEE    = 6

class SmallBipedalBody(WalkerAbstractBody):
    def __init__(self, scale, motors_torque=80, nb_steps_under_water=600, reset_on_hull_critical_contact=False):
        super(SmallBipedalBody, self).__init__(scale, motors_torque, nb_steps_under_water)
        self.LEG_DOWN = 3 / self.SCALE
        self.LEG_W, self.LEG_H = 8 / self.SCALE, 17 / self.SCALE
        self.TORQUE_PENALTY = 0.00035
        self.reset_on_hull_critical_contact = reset_on_hull_critical_contact
        self.AGENT_WIDTH = HULL_BOTTOM_WIDTH / self.SCALE
        self.AGENT_HEIGHT = 10 / self.SCALE + self.LEG_H * 2 - self.LEG_DOWN
        self.AGENT_CENTER_HEIGHT = self.LEG_H * 2 + self.LEG_DOWN

    def draw(self, world, init_x, init_y, force_to_center):
        HULL_FIXTURES = [
            fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in polygon]),
                density=HULL_DENSITY,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x000F)
            for polygon in HULL_POLYGONS
        ]
        LEG_FD = fixtureDef(shape=polygonShape(box=(self.LEG_W / 2, self.LEG_H / 2)), density=1.0, restitution=0.0, categoryBits=0x20, maskBits=0x000F)
        LOWER_FD = fixtureDef(shape=polygonShape(box=(0.8 * self.LEG_W / 2, self.LEG_H / 2)), density=1.0, restitution=0.0, categoryBits=0x20, maskBits=0x000F)

        hull = world.CreateDynamicBody(position=(init_x, init_y), fixtures=HULL_FIXTURES)
        hull.color1, hull.color2 = (0.5, 0.4, 0.9), (0.3, 0.3, 0.5)
        hull.ApplyForceToCenter((force_to_center, 0), True)
        hull.userData = CustomBodyUserData(True, is_contact_critical=self.reset_on_hull_critical_contact, name="hull")
        self.body_parts.append(hull)
        self.reference_head_object = hull

        for i in [-1, +1]:
            leg = world.CreateDynamicBody(position=(init_x, init_y - self.LEG_H / 2 - self.LEG_DOWN), fixtures=LEG_FD)
            leg.color1, leg.color2 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.), (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
            rjd = revoluteJointDef(bodyA=hull, bodyB=leg, anchor=(init_x, init_y - self.LEG_DOWN), enableMotor=True, enableLimit=True, maxMotorTorque=self.MOTORS_TORQUE, motorSpeed=i, lowerAngle=-0.8, upperAngle=1.1)
            leg.userData = CustomBodyUserData(False, name="leg")
            self.body_parts.append(leg)
            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            lower = world.CreateDynamicBody(position=(init_x, init_y - self.LEG_H * 3 / 2 - self.LEG_DOWN), fixtures=LOWER_FD)
            lower.color1, lower.color2 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.), (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
            rjd = revoluteJointDef(bodyA=leg, bodyB=lower, anchor=(init_x, init_y - self.LEG_DOWN - self.LEG_H), enableMotor=True, enableLimit=True, maxMotorTorque=self.MOTORS_TORQUE, motorSpeed=1, lowerAngle=-1.6, upperAngle=-0.1)
            lower.userData = CustomBodyUserData(True, name="lower")
            self.body_parts.append(lower)
            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_KNEE, True, contact_body=lower, angle_correction=1.0)
            self.motors.append(joint_motor)

===== .\TeachMyAgent\environments\envs\bodies\walkers\SpiderBody.py =====
import numpy as np
from Box2D.b2 import edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener

from TeachMyAgent.environments.envs.bodies.walkers.WalkerAbstractBody import WalkerAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData

MAIN_BODY_POLYGONS = [
    [(-10, +10), (+10, +10),
    (+10, -10), (-10, -10)]
]
MAIN_BODY_BOTTOM_WIDTH = 20
SPEED_HIP     = 4
SPEED_KNEE    = 6

class SpiderBody(WalkerAbstractBody):
    '''
        Walking spider embodiment.
    '''
    def __init__(self, scale, motors_torque=100, nb_pairs_of_legs=2, nb_steps_under_water=600,
                 reset_on_hull_critical_contact=False):
        '''
            Creates a spider with `n` pair of legs.

            Each legs has 3 parts.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                nb_pairs_of_legs: Number of pair of legs the agent has
                 nb_steps_under_water: How many consecutive steps the embodiment can survive under water
                reset_on_hull_critical_contact: Whether a contact detected with the head should stop the episode
        '''
        super(SpiderBody, self).__init__(scale, motors_torque, nb_steps_under_water)
        self.LEG_DOWN = 4 / self.SCALE
        self.LEG_W, self.LEG_H = 6 / self.SCALE, 20 / self.SCALE
        self.reset_on_hull_critical_contact = reset_on_hull_critical_contact

        self.nb_pairs_of_legs = nb_pairs_of_legs

        self.TORQUE_PENALTY = 0.00035 / self.nb_pairs_of_legs

        # not exact but works
        self.AGENT_WIDTH = MAIN_BODY_BOTTOM_WIDTH / self.SCALE + \
                           self.LEG_H * 4
        self.AGENT_HEIGHT = 20 / self.SCALE + \
                            self.LEG_H * 2
        self.AGENT_CENTER_HEIGHT = self.LEG_H + self.LEG_DOWN

    def draw(self, world, init_x, init_y, force_to_center):
        ''' Circular body
        MAIN_BODY_FIXTURES = fixtureDef(
            shape=circleShape(radius=0.4),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F
        )

        '''
        MAIN_BODY_FIXTURES = [
            fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in polygon]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x000F)
            for polygon in MAIN_BODY_POLYGONS
        ]

        LEG_FD = fixtureDef(
            shape=polygonShape(box=(self.LEG_W / 2, self.LEG_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        LOWER_FD = fixtureDef(
            shape=polygonShape(box=(0.8 * self.LEG_W / 2, self.LEG_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        main_body = world.CreateDynamicBody(
            position=(init_x, init_y),
            fixtures=MAIN_BODY_FIXTURES
        )

        basis_color1 = (0.6, 0.3, 0.5)
        basis_color2 = (0.4, 0.2, 0.3)
        main_body.color1 = tuple([c - 0.1 for c in basis_color1])
        main_body.color2 = tuple([c - 0.1 for c in basis_color2])
        leg_color1 = tuple([c + 0.1 for c in basis_color1])
        leg_color2 = tuple([c + 0.1 for c in basis_color2])

        main_body.ApplyForceToCenter((force_to_center, 0), True)

        main_body.userData = CustomBodyUserData(True, is_contact_critical=self.reset_on_hull_critical_contact, name="main_body")
        self.body_parts.append(main_body)
        self.reference_head_object = main_body


        for i in [+1, -1] * self.nb_pairs_of_legs:
            ##### First part of the leg #####
            upper_leg_angle = 0.15 * np.pi * i 
            upper_leg_x_distance = np.sin(upper_leg_angle) * self.LEG_H / 2
            upper_leg_y_distance = np.cos(upper_leg_angle) * self.LEG_H / 2
            upper_leg_x = init_x - i * MAIN_BODY_BOTTOM_WIDTH / self.SCALE / 2 - upper_leg_x_distance
            upper_leg_y = init_y + upper_leg_y_distance - self.LEG_DOWN

            upper_leg = world.CreateDynamicBody(
                position=(upper_leg_x, upper_leg_y),
                angle=upper_leg_angle,
                fixtures=LEG_FD
            )
            upper_leg.color1 = leg_color1
            upper_leg.color2 = leg_color2

            rjd = revoluteJointDef(
                bodyA=main_body,
                bodyB=upper_leg,
                anchor=(init_x - i * MAIN_BODY_BOTTOM_WIDTH / self.SCALE / 2,
                        init_y - self.LEG_DOWN),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=-0.1*np.pi,
                upperAngle=0.1*np.pi,
            )

            upper_leg.userData = CustomBodyUserData(False, name="upper_leg")
            self.body_parts.append(upper_leg)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            ##### Second part of the leg #####
            middle_leg_angle = 0.5 * np.pi * i
            middle_leg_x_distance = np.sin(middle_leg_angle) * self.LEG_H / 2
            middle_leg_y_distance = -np.cos(middle_leg_angle) * self.LEG_H / 2
            middle_leg_x = upper_leg_x - upper_leg_x_distance - middle_leg_x_distance
            middle_leg_y = upper_leg_y + upper_leg_y_distance - middle_leg_y_distance
            middle_leg = world.CreateDynamicBody(
                position=(middle_leg_x, middle_leg_y),
                angle=middle_leg_angle,
                fixtures=LEG_FD
            )
            middle_leg.color1 = leg_color1
            middle_leg.color2 = leg_color2

            rjd = revoluteJointDef(
                bodyA=upper_leg,
                bodyB=middle_leg,
                anchor=(upper_leg_x - upper_leg_x_distance,
                        upper_leg_y + upper_leg_y_distance),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=-0.15*np.pi,
                upperAngle=0.15*np.pi,
            )

            middle_leg.userData = CustomBodyUserData(False, name="middle_leg")
            self.body_parts.append(middle_leg)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            ##### Third part of the leg #####
            lower_leg_angle = 0.7 * np.pi * i
            lower_leg_x_distance = np.sin(lower_leg_angle) * self.LEG_H / 2
            lower_leg_y_distance = -np.cos(lower_leg_angle) * self.LEG_H / 2
            lower_leg_x = middle_leg_x - middle_leg_x_distance - lower_leg_x_distance
            lower_leg_y = middle_leg_y - middle_leg_y_distance - lower_leg_y_distance
            lower_leg = world.CreateDynamicBody(
                position=(lower_leg_x, lower_leg_y),
                angle=lower_leg_angle,
                fixtures=LOWER_FD
            )
            lower_leg.color1 = leg_color1
            lower_leg.color2 = leg_color2

            rjd = revoluteJointDef(
                bodyA=middle_leg,
                bodyB=lower_leg,
                anchor=(middle_leg_x - middle_leg_x_distance,
                        middle_leg_y - middle_leg_y_distance ),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=-0.2*np.pi,
                upperAngle=0.2*np.pi,
            )

            lower_leg.userData = CustomBodyUserData(True, name="lower_leg")
            self.body_parts.append(lower_leg)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_KNEE,
                                                       True,
                                                       contact_body=lower_leg)
            self.motors.append(joint_motor)


===== .\TeachMyAgent\environments\envs\bodies\walkers\WalkerAbstractBody.py =====
from TeachMyAgent.environments.envs.bodies.AbstractBody import AbstractBody
from TeachMyAgent.environments.envs.bodies.BodyTypesEnum import BodyTypesEnum

class WalkerAbstractBody(AbstractBody):
    '''
        Base class for walkers.
    '''
    def __init__(self, scale, motors_torque, nb_steps_under_water):
        '''
            Creates a walker, which cannot survive under water.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                nb_steps_under_water: How many consecutive steps the embodiment can survive under water
        '''
        super(WalkerAbstractBody, self).__init__(scale, motors_torque)

        self.body_type = BodyTypesEnum.WALKER
        self.nb_steps_can_survive_under_water = nb_steps_under_water

===== .\TeachMyAgent\environments\envs\bodies\walkers\WheelBody.py =====
import numpy as np
import math
from Box2D.b2 import edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener

from TeachMyAgent.environments.envs.bodies.walkers.WalkerAbstractBody import WalkerAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData

MAIN_BODY_POLYGONS = [
    [(-10, +10), (+10, +10),
    (+10, -10), (-10, -10)]
]
HULL_BOTTOM_WIDTH = 20
SPEED_HIP     = 4
SPEED_KNEE    = 6

class WheelBody(WalkerAbstractBody):
    '''
        Walking 'wheel' embodiment.
    '''
    def __init__(self, scale, motors_torque=500, body_scale=1, nb_steps_under_water=600,
                 reset_on_hull_critical_contact=False):
        '''
            Creates an embodiment with a square hull and a pair of leg at each of its side.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                body_scale: If the hull must be reduced or increased (1 means leave it as it is)
                 nb_steps_under_water: How many consecutive steps the embodiment can survive under water
                reset_on_hull_critical_contact: Whether a contact detected with the head should stop the episode
        '''
        super(WheelBody, self).__init__(scale, motors_torque, nb_steps_under_water)
        self.LEG_W, self.LEG_H = 4 / self.SCALE, 10 / self.SCALE
        self.TORQUE_PENALTY = 0.00035 / 2 # 4 legs = 2 pair of legs
        self.reset_on_hull_critical_contact = reset_on_hull_critical_contact

        self.body_scale = body_scale

        self.AGENT_WIDTH = HULL_BOTTOM_WIDTH * self.body_scale / self.SCALE
        self.AGENT_HEIGHT = 20 * self.body_scale / self.SCALE + \
                            self.LEG_H * 4
        self.AGENT_CENTER_HEIGHT = 20 * self.body_scale / self.SCALE / 2 + \
                                   self.LEG_H * 2

        self.remove_reward_on_head_angle = True

    def draw(self, world, init_x, init_y, force_to_center):
        ''' Circular body
        MAIN_BODY_FIXTURES = fixtureDef(
            shape=circleShape(radius=0.4),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F
        )
        '''
        MAIN_BODY_FIXTURES = [
            fixtureDef(
                shape=polygonShape(vertices=[(x * self.body_scale / self.SCALE, y * self.body_scale / self.SCALE) for x, y in polygon]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x000F)
            for polygon in MAIN_BODY_POLYGONS
        ]

        LEG_FD = fixtureDef(
            shape=polygonShape(box=(self.LEG_W / 2, self.LEG_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        LOWER_FD = fixtureDef(
            shape=polygonShape(box=(0.8 * self.LEG_W / 2, self.LEG_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        main_body = world.CreateDynamicBody(
            position=(init_x, init_y),
            fixtures=MAIN_BODY_FIXTURES
        )

        basis_color1 = (0.6, 0.3, 0.5)
        basis_color2 = (0.4, 0.2, 0.3)
        main_body.color1 = tuple([c - 0.1 for c in basis_color1])
        main_body.color2 = tuple([c - 0.1 for c in basis_color2])
        leg_color1 = tuple([c + 0.1 for c in basis_color1])
        leg_color2 = tuple([c + 0.1 for c in basis_color2])

        main_body.ApplyForceToCenter((force_to_center, 0), True)

        main_body.userData = CustomBodyUserData(True, is_contact_critical=self.reset_on_hull_critical_contact, name="main_body")
        self.body_parts.append(main_body)
        self.reference_head_object = main_body

        for j in [[0, -1, 0], [0, 1, 0],[-1, 0, np.pi/2], [1, 0, np.pi/2]]:
            x_position = j[0] * (HULL_BOTTOM_WIDTH * self.body_scale / self.SCALE / 2)
            y_position = j[1] * (HULL_BOTTOM_WIDTH * self.body_scale / self.SCALE / 2)
            # for i in [-1, +1]:
            leg_x = init_x + j[0] * (self.LEG_H / 2) + x_position
            leg_y = init_y + j[1] * (self.LEG_H / 2) + y_position
            leg = world.CreateDynamicBody(
                position=(leg_x, leg_y),
                angle=(j[2]),
                fixtures=LEG_FD
            )
            leg.color1 = leg_color1
            leg.color2 = leg_color2
            rjd = revoluteJointDef(
                bodyA=main_body,
                bodyB=leg,
                anchor=(init_x + x_position, init_y + y_position),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=-0.8,
                upperAngle=1.1,
            )

            leg.userData = CustomBodyUserData(False, name="leg")
            self.body_parts.append(leg)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            lower = world.CreateDynamicBody(
                position=(leg_x + j[0] * (self.LEG_H),
                          leg_y + j[1] * (self.LEG_H)),
                angle=(j[2]),
                fixtures=LOWER_FD
            )
            lower.color1 = leg_color1
            lower.color2 = leg_color2
            rjd = revoluteJointDef(
                bodyA=leg,
                bodyB=lower,
                anchor=(leg_x + j[0] * (self.LEG_H / 2),
                        leg_y + j[1] * (self.LEG_H / 2)),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=-1.6,
                upperAngle=-0.1,
            )

            lower.userData = CustomBodyUserData(True, name="lower")
            self.body_parts.append(lower)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(
                SPEED_KNEE,
                True,
                contact_body=lower,
                angle_correction=1.0)
            self.motors.append(joint_motor)

===== .\TeachMyAgent\environments\envs\bodies\walkers\__init__.py =====


===== .\TeachMyAgent\environments\envs\bodies\walkers\old\OldBigQuadruBody.py =====
# TeachMyAgent/environments/envs/bodies/walkers/old/OldBigQuadruBody.py
# Taken from https://github.com/flowersteam/teachDeepRL

import numpy as np
from Box2D.b2 import edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener

from TeachMyAgent.environments.envs.bodies.walkers.WalkerAbstractBody import WalkerAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData

HULL_POLYGONS = [
        [(-46, +13), (+6, +13), (+50, +5),
        (+50, -12), (-46, -12)]
    ]
HULL_BOTTOM_WIDTH = 96
SPEED_HIP     = 4
SPEED_KNEE    = 6

class OldBigQuadruBody(WalkerAbstractBody):
    def __init__(self, scale, motors_torque=300, nb_steps_under_water=600, reset_on_hull_critical_contact=False):
        super(OldBigQuadruBody, self).__init__(scale, motors_torque, nb_steps_under_water)
        self.LEG_DOWN = -8 / self.SCALE
        self.LEG_W, self.LEG_H = 10 / self.SCALE, 51 / self.SCALE
        self.TORQUE_PENALTY = 0.00035 / 2
        self.reset_on_hull_critical_contact = reset_on_hull_critical_contact
        self.AGENT_WIDTH = HULL_BOTTOM_WIDTH / self.SCALE
        self.AGENT_HEIGHT = 25 / self.SCALE + self.LEG_H * 2 - self.LEG_DOWN
        self.AGENT_CENTER_HEIGHT = self.LEG_H * 2 + self.LEG_DOWN
        self.old_morphology = True
        self.nb_motors = 8
        self.state_size = self.nb_motors * 2 + 4

    def draw(self, world, init_x, init_y, force_to_center):
        HULL_FIXTURES = [
            fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in polygon]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x000F)
            for polygon in HULL_POLYGONS
        ]
        LEG_FD = fixtureDef(shape=polygonShape(box=(self.LEG_W / 2, self.LEG_H / 2)), density=1.0, restitution=0.0, categoryBits=0x20, maskBits=0x000F)
        LOWER_FD = fixtureDef(shape=polygonShape(box=(0.8 * self.LEG_W / 2, self.LEG_H / 2)), density=1.0, restitution=0.0, categoryBits=0x20, maskBits=0x000F)

        hull = world.CreateDynamicBody(position=(init_x, init_y), fixtures=HULL_FIXTURES)
        hull.color1, hull.color2 = (0.5, 0.4, 0.9), (0.3, 0.3, 0.5)
        hull.ApplyForceToCenter((force_to_center, 0), True)
        hull.userData = CustomBodyUserData(True, is_contact_critical=self.reset_on_hull_critical_contact, name="hull")
        self.body_parts.append(hull)
        self.reference_head_object = hull

        # START FIX: Using absolute position calculation for better physics stability
        for x_anchor_rel in [-0.7, 0.5]: # Relative anchor position on the hull
            absolute_x = init_x + np.interp(x_anchor_rel, [-1,1], [-HULL_BOTTOM_WIDTH / 2 / self.SCALE, HULL_BOTTOM_WIDTH / 2 / self.SCALE])
            for i in [-1, +1]:
                leg = world.CreateDynamicBody(position=(absolute_x, init_y - self.LEG_H / 2 - self.LEG_DOWN), fixtures=LEG_FD)
                leg.color1, leg.color2 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.), (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
                rjd = revoluteJointDef(bodyA=hull, bodyB=leg, anchor=(absolute_x, init_y - self.LEG_DOWN), enableMotor=True, enableLimit=True, maxMotorTorque=self.MOTORS_TORQUE, motorSpeed=i, lowerAngle=-0.8, upperAngle=1.1)
                leg.userData = CustomBodyUserData(False, name="leg")
                self.body_parts.append(leg)
                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
                self.motors.append(joint_motor)
                
                lower = world.CreateDynamicBody(position=(absolute_x, init_y - self.LEG_H * 3 / 2 - self.LEG_DOWN), fixtures=LOWER_FD)
                lower.color1, lower.color2 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.), (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
                rjd = revoluteJointDef(bodyA=leg, bodyB=lower, anchor=(absolute_x, init_y - self.LEG_DOWN - self.LEG_H), enableMotor=True, enableLimit=True, maxMotorTorque=self.MOTORS_TORQUE, motorSpeed=1, lowerAngle=-1.6, upperAngle=-0.1)
                lower.userData = CustomBodyUserData(True, name="lower")
                self.body_parts.append(lower)
                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(SPEED_KNEE, True, contact_body=lower, angle_correction=1.0)
                self.motors.append(joint_motor)
        # END FIX

===== .\TeachMyAgent\environments\envs\bodies\walkers\old\OldClassicBipedalBody.py =====
# Taken from https://github.com/flowersteam/teachDeepRL

from Box2D.b2 import edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener

from TeachMyAgent.environments.envs.bodies.walkers.WalkerAbstractBody import WalkerAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData

HULL_POLYGONS = [
    [(-30, +9), (+6, +9), (+34, +1),
    (+34, -8), (-30, -8)]
]
HULL_BOTTOM_WIDTH = 64
SPEED_HIP     = 4
SPEED_KNEE    = 6

class OldClassicBipedalBody(WalkerAbstractBody):
    '''
        Bipedal walker implemented in https://gym.openai.com/envs/BipedalWalker-v2/.
    '''
    def __init__(self, scale, nb_steps_under_water=600, reset_on_hull_critical_contact=True):
        '''
            Creates a bipedal walker with a torque of 80.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                 nb_steps_under_water: How many consecutive steps the embodiment can survive under water
                reset_on_hull_critical_contact: Whether a contact detected with the head should stop the episode
        '''
        super(OldClassicBipedalBody, self).__init__(scale, 80, nb_steps_under_water)
        self.LEG_DOWN = -8 / self.SCALE # 0 = center of hull
        self.LEG_W, self.LEG_H = 8 / self.SCALE, 34 / self.SCALE
        self.TORQUE_PENALTY = 0.00035
        self.reset_on_hull_critical_contact = reset_on_hull_critical_contact

        # Approximative...
        self.AGENT_WIDTH = HULL_BOTTOM_WIDTH / self.SCALE
        self.AGENT_HEIGHT = 17 / self.SCALE + \
                            self.LEG_H * 2 - self.LEG_DOWN + 0.5
        self.AGENT_CENTER_HEIGHT = self.LEG_H * 2 + self.LEG_DOWN + 0.5

        self.old_morphology = True

        self.body_parts = []
        self.nb_motors = 4
        self.motors = []
        self.state_size = self.nb_motors * 2 + 2

    def draw(self, world, init_x, init_y, force_to_center):
        HULL_FIXTURES = [
            fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in polygon]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x000F)  # 0.99 bouncy
            for polygon in HULL_POLYGONS
        ]

        LEG_FD = fixtureDef(
            shape=polygonShape(box=(self.LEG_W / 2, self.LEG_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        LOWER_FD = fixtureDef(
            shape=polygonShape(box=(0.8 * self.LEG_W / 2, self.LEG_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        hull = world.CreateDynamicBody(
            position=(init_x, init_y),
            fixtures=HULL_FIXTURES
        )
        hull.color1 = (0.5, 0.4, 0.9)
        hull.color2 = (0.3, 0.3, 0.5)
        hull.ApplyForceToCenter((force_to_center, 0), True)

        # hull.userData = CustomBodyUserData(True, is_contact_critical=True, name="hull")
        hull.userData = CustomBodyUserData(True, is_contact_critical=self.reset_on_hull_critical_contact, name="hull")
        self.body_parts.append(hull)
        self.reference_head_object = hull

        for i in [-1, +1]:
            leg = world.CreateDynamicBody(
                position=(init_x, init_y - self.LEG_H / 2 - self.LEG_DOWN),
                angle=(i * 0.05),#2¬∞
                fixtures=LEG_FD
            )
            leg.color1 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.)
            leg.color2 = (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
            rjd = revoluteJointDef(
                bodyA=hull,
                bodyB=leg,
                localAnchorA=(0, self.LEG_DOWN),
                localAnchorB=(0, self.LEG_H / 2),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=i,
                lowerAngle=-0.8,
                upperAngle=1.1,
            )

            leg.userData = CustomBodyUserData(False, name="leg")
            self.body_parts.append(leg)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            lower = world.CreateDynamicBody(
                position=(init_x, init_y - self.LEG_H * 3 / 2 - self.LEG_DOWN),
                angle=(i * 0.05), #2¬∞
                fixtures=LOWER_FD
            )
            lower.color1 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.)
            lower.color2 = (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
            rjd = revoluteJointDef(
                bodyA=leg,
                bodyB=lower,
                localAnchorA=(0, -self.LEG_H / 2),
                localAnchorB=(0, self.LEG_H / 2),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=-1.6,
                upperAngle=-0.1,
            )

            lower.userData = CustomBodyUserData(True, name="lower")
            self.body_parts.append(lower)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(
                SPEED_KNEE,
                True,
                contact_body=lower,
                angle_correction=1.0)
            self.motors.append(joint_motor)

===== .\TeachMyAgent\environments\envs\bodies\walkers\old\__init__.py =====


===== .\TeachMyAgent\environments\envs\Box2D_dynamics\climbing_dynamics.py =====
# TeachMyAgent/environments/envs/Box2D_dynamics/climbing_dynamics.py
import Box2D
from Box2D.b2 import (edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener)
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomUserDataObjectTypes

class ClimbingDynamics(object):
    # START FIX: Add __init__ to create a list for joints that need to be destroyed
    def __init__(self):
        self.joints_to_destroy = []
        
    def before_step_climbing_dynamics(self, actions, body, world):
        '''
        Check if sensors should grasp or release.
        If releasing and a joint exists, mark it for destruction.
        '''
        for i in range(len(body.sensors)):
            action_to_check = actions[len(actions) - i - 1]
            sensor_to_check = body.sensors[len(body.sensors) - i - 1]

            if action_to_check > 0:
                sensor_to_check.userData.ready_to_attach = True
            else:
                sensor_to_check.userData.ready_to_attach = False
                if sensor_to_check.userData.has_joint:
                    sensor_to_check.userData.has_joint = False
                    joint_to_destroy = next((_joint.joint for _joint in sensor_to_check.joints
                                             if isinstance(_joint.joint, Box2D.b2RevoluteJoint)), None)
                    if joint_to_destroy is not None:
                        # START FIX: Defer joint destruction instead of immediate removal
                        # The old line which caused crashes: world.DestroyJoint(joint_to_destroy)
                        self.joints_to_destroy.append(joint_to_destroy)
                        # END FIX

    def after_step_climbing_dynamics(self, contact_detector, world):
        '''
        Safely destroy marked joints and create new climbing joints if sensors are still overlapping.
        '''
        # START FIX: Safely destroy all joints marked for removal after world.Step()
        # This is the correct and safe way to modify the physics world.
        for joint in self.joints_to_destroy:
            world.DestroyJoint(joint)
        self.joints_to_destroy.clear() # Clean up the list
        # END FIX
        
        for sensor in contact_detector.contact_dictionaries:
            if len(contact_detector.contact_dictionaries[sensor]) > 0 and \
                    sensor.userData.ready_to_attach and not sensor.userData.has_joint:
                other_body = contact_detector.contact_dictionaries[sensor][0]

                # Simple overlap check (fast approximation)
                other_body_shape = other_body.fixtures[0].shape
                x_values = [v[0] for v in other_body_shape.vertices]
                y_values = [v[1] for v in other_body_shape.vertices]
                radius = sensor.fixtures[0].shape.radius + 0.01

                if (sensor.worldCenter[0] + radius > min(x_values) and sensor.worldCenter[0] - radius < max(x_values) and
                    sensor.worldCenter[1] + radius > min(y_values) and sensor.worldCenter[1] - radius < max(y_values)):
                    rjd = revoluteJointDef(
                        bodyA=sensor,
                        bodyB=other_body,
                        anchor=sensor.worldCenter
                    )

                    joint = world.CreateJoint(rjd)
                    joint.bodyA.userData.joint = joint
                    sensor.userData.has_joint = True
                else:
                    contact_detector.contact_dictionaries[sensor].remove(other_body)
                    if len(contact_detector.contact_dictionaries[sensor]) == 0:
                        sensor.userData.has_contact = False
class ClimbingContactDetector(contactListener):
    '''
    Stores contacts between sensors and graspable surfaces.
    '''
    def __init__(self):
        super(ClimbingContactDetector, self).__init__()
        self.contact_dictionaries = {}

    def BeginContact(self, contact):
        bodies = [contact.fixtureA.body, contact.fixtureB.body]
        for idx, body in enumerate(bodies):
            if body.userData.object_type == CustomUserDataObjectTypes.BODY_SENSOR and body.userData.check_contact:
                other_body = bodies[(idx + 1) % 2]
                if other_body.userData.object_type in (
                    CustomUserDataObjectTypes.GRIP_TERRAIN,
                    CustomUserDataObjectTypes.SENSOR_GRIP_TERRAIN,
                ):
                    body.userData.has_contact = True
                    if body in self.contact_dictionaries:
                        self.contact_dictionaries[body].append(other_body)
                    else:
                        self.contact_dictionaries[body] = [other_body]

    def EndContact(self, contact):
        fA, fB = contact.fixtureA, contact.fixtureB

        if not (hasattr(fA, 'body') and hasattr(fB, 'body') and fA.body and fB.body and
                hasattr(fA.body, 'userData') and hasattr(fB.body, 'userData') and
                fA.body.userData and fB.body.userData):
            return

        bodies = [fA.body, fB.body]
        for idx, body in enumerate(bodies):
            if (body.userData.object_type == CustomUserDataObjectTypes.BODY_SENSOR and
                body.userData.check_contact and body.userData.has_contact):

                other_body = bodies[(idx + 1) % 2]

                if hasattr(other_body, 'userData') and other_body.userData is not None:
                    if body in self.contact_dictionaries and other_body in self.contact_dictionaries[body]:
                        self.contact_dictionaries[body].remove(other_body)

                    if body in self.contact_dictionaries and len(self.contact_dictionaries[body]) == 0:
                        body.userData.has_contact = False

    def Reset(self):
        self.contact_dictionaries = {}

===== .\TeachMyAgent\environments\envs\Box2D_dynamics\water_dynamics.py =====
# TeachMyAgent/environments/envs/Box2D_dynamics/water_dynamics.py
import Box2D
from Box2D.b2 import (edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener)
from copy import copy
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomUserDataObjectTypes
import numpy as np


class WaterDynamics(object):
    '''
    Simplified water physics simulation using buoyancy, drag, lift, and push forces.
    Based on: https://www.iforce2d.net/b2dtut/buoyancy
    '''
    def __init__(self, gravity, drag_mod=0.25, lift_mod=0.25, push_mod=0.05,
                 max_drag=2000, max_lift=500, max_push=20):
        self.gravity = gravity
        self.drag_mod = drag_mod
        self.lift_mod = lift_mod
        self.push_mod = push_mod
        self.max_drag = max_drag
        self.max_lift = max_lift
        self.max_push = max_push

    def compute_centroids(self, vectors):
        '''Compute the centroid and area of a polygon.'''
        count = len(vectors)
        assert count >= 3

        c = Box2D.b2Vec2(0, 0)
        area = 0
        ref_point = Box2D.b2Vec2(0, 0)
        inv3 = 1 / 3

        for i in range(count):
            p1 = ref_point
            p2 = vectors[i]
            p3 = vectors[i + 1] if i + 1 < count else vectors[0]

            e1 = p2 - p1
            e2 = p3 - p1
            d = Box2D.b2Cross(e1, e2)

            triangle_area = 0.5 * d
            area += triangle_area
            c += triangle_area * inv3 * (p1 + p2 + p3)

        if area > Box2D.b2_epsilon:
            c *= 1 / area
        else:
            area = 0

        return c, area

    def inside(self, cp1, cp2, p):
        '''Check if point p is inside an edge defined by cp1, cp2.'''
        return (cp2.x - cp1.x) * (p.y - cp1.y) > (cp2.y - cp1.y) * (p.x - cp1.x)

    def intersection(self, cp1, cp2, s, e):
        '''Find the intersection point of two line segments.'''
        dc = Box2D.b2Vec2(cp1.x - cp2.x, cp1.y - cp2.y)
        dp = Box2D.b2Vec2(s.x - e.x, s.y - e.y)
        n1 = cp1.x * cp2.y - cp1.y * cp2.x
        n2 = s.x * e.y - s.y * e.x
        n3 = 1.0 / (dc.x * dp.y - dc.y * dp.x)
        return Box2D.b2Vec2((n1 * dp.x - n2 * dc.x) * n3,
                            (n1 * dp.y - n2 * dc.y) * n3)

    def find_intersection(self, fixture_A, fixture_B):
        '''Find intersection polygon between two fixtures.'''
        output_vertices = []
        polygon_A = fixture_A.shape
        polygon_B = fixture_B.shape

        for v in polygon_A.vertices:
            output_vertices.append(fixture_A.body.GetWorldPoint(v))

        clip_polygon = [fixture_B.body.GetWorldPoint(v) for v in polygon_B.vertices]

        cp1 = clip_polygon[-1]
        for cp2 in clip_polygon:
            if not output_vertices:
                break

            input_list = copy(output_vertices)
            output_vertices.clear()
            s = input_list[-1]

            for e in input_list:
                if self.inside(cp1, cp2, e):
                    if not self.inside(cp1, cp2, s):
                        output_vertices.append(self.intersection(cp1, cp2, s, e))
                    output_vertices.append(e)
                elif self.inside(cp1, cp2, s):
                    output_vertices.append(self.intersection(cp1, cp2, s, e))
                s = e
            cp1 = cp2
        return len(output_vertices) != 0, output_vertices

    def calculate_forces(self, fixture_pairs):
        '''Apply buoyancy, drag, lift, and push forces for intersecting fixtures.'''
        for pair in fixture_pairs:
            density = pair[0].density
            has_intersection, intersection_points = self.find_intersection(pair[0], pair[1])

            if not has_intersection:
                continue

            centroid, area = self.compute_centroids(intersection_points)

            # Buoyancy
            displaced_mass = density * area
            buoyancy_force = displaced_mass * -self.gravity
            pair[1].body.ApplyForce(force=buoyancy_force, point=centroid, wake=True)

            # Hydrodynamic forces
            for i in range(len(intersection_points)):
                v0 = intersection_points[i]
                v1 = intersection_points[(i + 1) % len(intersection_points)]
                mid_point = 0.5 * (v0 + v1)

                # Drag
                vel_dir = pair[1].body.GetLinearVelocityFromWorldPoint(mid_point) - \
                          pair[0].body.GetLinearVelocityFromWorldPoint(mid_point)
                vel = vel_dir.Normalize()

                edge = v1 - v0
                edge_length = edge.Normalize()
                normal = Box2D.b2Cross(-1, edge)
                drag_dot = Box2D.b2Dot(normal, vel_dir)

                if drag_dot >= 0:  # Backward edge
                    drag_mag = drag_dot * self.drag_mod * edge_length * density * vel * vel
                    drag_mag = min(drag_mag, self.max_drag)
                    drag_force = drag_mag * -vel_dir
                    pair[1].body.ApplyForce(force=drag_force, point=mid_point, wake=True)

                    # Lift
                    lift_dot = Box2D.b2Dot(edge, vel_dir)
                    lift_mag = drag_dot * lift_dot * self.lift_mod * edge_length * density * vel * vel
                    lift_mag = min(lift_mag, self.max_lift)
                    lift_dir = Box2D.b2Cross(1, vel_dir)
                    lift_force = lift_mag * lift_dir
                    pair[1].body.ApplyForce(force=lift_force, point=mid_point, wake=True)

                # Push (torque-based linear force)
                body_to_check = pair[1].body
                joints_to_check = [
                    joint_edge.joint for joint_edge in body_to_check.joints
                    if joint_edge.joint.bodyB == body_to_check
                ]

                for joint in joints_to_check:
                    if joint.lowerLimit < joint.angle < joint.upperLimit:
                        torque = joint.GetMotorTorque(60)
                        moment_of_inertia = body_to_check.inertia
                        angular_velocity = body_to_check.angularVelocity
                        angular_inertia = moment_of_inertia * angular_velocity

                        world_center = body_to_check.worldCenter
                        anchor = joint.anchorB
                        lever_vector = world_center - anchor
                        force_at_center = Box2D.b2Cross(lever_vector, -torque)

                        push_dot = Box2D.b2Dot(normal, force_at_center)
                        if push_dot > 0:
                            vel = torque + angular_inertia
                            push_mag = push_dot * self.push_mod * edge_length * density * vel * vel
                            push_force = np.clip(push_mag * -force_at_center, -self.max_push, self.max_push)
                            body_to_check.ApplyForce(force=push_force, point=anchor, wake=True)


class WaterContactDetector(contactListener):
    '''Tracks fixtures that are in contact with water.'''
    def __init__(self):
        super(WaterContactDetector, self).__init__()
        self.fixture_pairs = []

    def BeginContact(self, contact):
        fA, fB = contact.fixtureA, contact.fixtureB
        if fA.body.userData.object_type == CustomUserDataObjectTypes.WATER and \
           fB.body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT:
            self.fixture_pairs.append((fA, fB))
        elif fB.body.userData.object_type == CustomUserDataObjectTypes.WATER and \
             fA.body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT:
            self.fixture_pairs.append((fB, fA))

    def EndContact(self, contact):
        '''Safely remove fixture pairs when contact ends.'''
        fA, fB = contact.fixtureA, contact.fixtureB

        # START FIX: Added safety checks to prevent crashes from destroyed bodies
        if not (hasattr(fA, 'body') and hasattr(fB, 'body') and fA.body and fB.body and
                hasattr(fA.body, 'userData') and hasattr(fB.body, 'userData') and
                fA.body.userData and fB.body.userData):
            return
        # END FIX

        pair_to_remove = None
        if fA.body.userData.object_type == CustomUserDataObjectTypes.WATER and \
           fB.body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT:
            pair_to_remove = (fA, fB)
        elif fB.body.userData.object_type == CustomUserDataObjectTypes.WATER and \
             fA.body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT:
            pair_to_remove = (fB, fA)

        if pair_to_remove and pair_to_remove in self.fixture_pairs:
            self.fixture_pairs.remove(pair_to_remove)

    def Reset(self):
        '''Clear all stored contacts.'''
        self.fixture_pairs = []

===== .\TeachMyAgent\environments\envs\Box2D_dynamics\__init__.py =====


===== .\TeachMyAgent\environments\envs\PCGAgents\CPPN\BaseCPPN.py =====
import tensorflow as tf
import numpy as np

class BaseCPPN():
    '''
        Simple Base CPPN class wich takes an input vector in addition of a vector defining the x position.
    '''
    def __init__(self, x_dim, input_dim, batch_size=1, output_dim=1, weights_path=None):
        '''
            Builds the computational graph.

            Args:
                x_dim: How many times the CPPN should slide on the x axis
                input_dim: Size of the input vector controlling the generated pattern
                batch_size: Size of batch provided
                output_dim: Size of the output vector
                weights_path: Path to load weights. If None, weights are randomly sampled
        '''
        self.batch_size = batch_size
        self.output_dim = output_dim
        self.x_dim = x_dim
        self.input_dim = input_dim

        # builds the generator network
        self.G = self.generator()

        self.init()

        if weights_path is not None:
            saver = tf.train.Saver()
            saver.restore(self.sess, weights_path)

    def init(self):
        '''
            Initialize the tf session.
        '''
        config = tf.ConfigProto()
        config.gpu_options.allow_growth = True
        self.sess = tf.Session(config=config)
        init = tf.global_variables_initializer()
        self.sess.run(init)

    def generator(self):
        '''
            Build the computational graph.
        '''
        tf.reset_default_graph()
        # inputs to cppn
        self.input = tf.placeholder(tf.float32, [self.x_dim, self.input_dim + 1])

        output_weights = tf.Variable(tf.truncated_normal([self.input_dim + 1, self.output_dim]))
        output = tf.matmul(self.input, output_weights)
        result = tf.reshape(output, [self.x_dim])

        return result

    def generate(self, input_vector):
        '''
            Generate an output of size `batch_size*x_dim*output_size` given the input vector
        '''
        x = np.arange(self.x_dim)
        scaled_x = x / (self.x_dim - 1)
        x_vec = scaled_x.reshape((self.x_dim, 1))
        reshaped_input_vector = np.ones((self.x_dim, self.input_dim)) * input_vector
        final_input = np.concatenate((x_vec, reshaped_input_vector), axis=1)
        return self.sess.run(self.G, feed_dict={self.input: final_input})

    def close(self):
        '''
            Close the tf session.
        '''
        self.sess.close()

===== .\TeachMyAgent\environments\envs\PCGAgents\CPPN\cppn_pytorch.py =====
import torch
import torch.nn as nn
import numpy as np
import os


class CPPN_Pytorch(nn.Module):
    """
    PyTorch version of TanHSoftplusMixCPPN.
    - Matches the original TensorFlow model (no bias terms).
    - Supports loading pretrained weights converted from TensorFlow.
    """
    def __init__(self, x_dim: int, input_dim: int, output_dim: int = 2):
        super(CPPN_Pytorch, self).__init__()
        self.x_dim = x_dim
        self.input_dim = input_dim

        # Important: all layers use `bias=False` to match the original model
        self.net = nn.Sequential(
            nn.Linear(input_dim + 1, 64, bias=False),
            nn.Tanh(),
            nn.Linear(64, 64, bias=False),
            nn.Softplus(),
            nn.Linear(64, 64, bias=False),
            nn.Tanh(),
            nn.Linear(64, 64, bias=False),
            nn.Softplus(),
            nn.Linear(64, output_dim, bias=False)
        )
        print("CPPN (PyTorch) initialized ‚Äî no bias parameters.")

    def load_tf_weights(self, weights_path: str) -> None:
        """Load pretrained weights (converted from TensorFlow)."""
        if not os.path.exists(weights_path):
            print(f"Weight file '{weights_path}' not found. Using random initialization.")
            print("Run 'convert_weights.py' to generate the .pt file.")
            return

        state_dict = torch.load(weights_path)
        self.net.load_state_dict(state_dict)
        print("Successfully loaded original TensorFlow weights into CPPN (PyTorch).")

    def generate(self, input_vector: np.ndarray) -> np.ndarray:
        """
        Generate terrain data from an input vector.

        Args:
            input_vector: NumPy array representing the latent input.

        Returns:
            NumPy array of generated terrain values.
        """
        input_vector_t = torch.from_numpy(input_vector).float()

        x = np.arange(self.x_dim)
        scaled_x = x / (self.x_dim - 1)
        x_vec_t = torch.from_numpy(scaled_x).float().reshape((self.x_dim, 1))

        # Repeat input vector across the x-axis and concatenate
        reshaped_input = input_vector_t.repeat(self.x_dim, 1)
        final_input = torch.cat((x_vec_t, reshaped_input), dim=1)

        with torch.no_grad():
            output = self.net(final_input)

        return output.numpy()


===== .\TeachMyAgent\environments\envs\PCGAgents\CPPN\TanHSoftplusMixCPPN.py =====
import tensorflow as tf
from TeachMyAgent.environments.envs.PCGAgents.CPPN.BaseCPPN import BaseCPPN

class TanHSoftplusMixCPPN(BaseCPPN):
    '''
        Feedforward CPPN with 4 layers of 64 units alternating TanH/Softplus activation functions.
    '''
    def generator(self):
        tf.reset_default_graph()
        # inputs to cppn
        self.input = tf.placeholder(tf.float32, [self.x_dim, self.input_dim + 1])

        self.h1_weights = tf.Variable(tf.truncated_normal([self.input_dim + 1, 64], mean=0.0, stddev=2.0))
        h1 = tf.nn.tanh(tf.matmul(self.input, self.h1_weights))

        self.h2_weights = tf.Variable(tf.truncated_normal([64, 64], mean=0.0, stddev=2.0))
        h2 = tf.nn.softplus(tf.matmul(h1, self.h2_weights))

        self.h3_weights = tf.Variable(tf.truncated_normal([64, 64], mean=0.0, stddev=2.0))
        h3 = tf.nn.tanh(tf.matmul(h2, self.h3_weights))

        self.h4_weights = tf.Variable(tf.truncated_normal([64, 64], mean=0.0, stddev=2.0))
        h4 = tf.nn.softplus(tf.matmul(h3, self.h4_weights))

        self.output_weights = tf.Variable(tf.truncated_normal([64, self.output_dim], mean=0.0, stddev=2.0))
        output = tf.matmul(h4, self.output_weights)
        result = tf.reshape(output, [self.x_dim, self.output_dim])

        return result

===== .\TeachMyAgent\environments\envs\utils\custom_user_data.py =====
from enum import Enum


class CustomUserDataObjectTypes(Enum):
    """Enumeration of object types for custom user data."""
    BODY_OBJECT = 0
    WATER = 1
    TERRAIN = 2
    GRIP_TERRAIN = 3       # Graspable terrain
    MOTOR = 4
    BODY_SENSOR = 5
    SENSOR_GRIP_TERRAIN = 6  # Graspable sensor terrain (e.g., creeper)


class CustomUserData:
    """
    Base class for storing custom properties on simulation objects.
    """
    def __init__(self, name: str, object_type: CustomUserDataObjectTypes):
        self.name = name
        self.object_type = object_type


class CustomMotorUserData(CustomUserData):
    """
    User data for joints with `enableMotor=True`.
    Stores motor control parameters and contact linkage info.
    """
    def __init__(self, speed_control: bool, check_contact: bool,
                 angle_correction: float = 0.0, contact_body=None):
        """
        Args:
            speed_control: Whether this motor is controlled by speed.
            check_contact: If True, a `contact_body` must be provided.
                           Used in the observation space to provide contact info
                           for linked objects.
            angle_correction: Correction term for the joint angle (default=0.0).
            contact_body: Body to monitor for contact events.
        """
        super().__init__("motor", CustomUserDataObjectTypes.MOTOR)
        self.speed_control = speed_control
        self.check_contact = check_contact
        self.angle_correction = angle_correction
        self.contact_body = contact_body


class CustomBodyUserData(CustomUserData):
    """
    User data for body parts.
    Defines collision and termination behavior.
    """
    def __init__(self, check_contact: bool, is_contact_critical: bool = False,
                 name: str = "body_part",
                 object_type: CustomUserDataObjectTypes = CustomUserDataObjectTypes.BODY_OBJECT):
        """
        Args:
            check_contact: If False, collisions for this body are ignored.
            is_contact_critical: If True, a collision ends the episode.
            name: Name of the body part.
            object_type: Type of body (default = BODY_OBJECT).
        """
        super().__init__(name, object_type)
        self.check_contact = check_contact
        self.is_contact_critical = is_contact_critical
        self.has_contact = False


class CustomBodySensorUserData(CustomBodyUserData):
    """
    User data for sensors attached to bodies.
    """
    def __init__(self, check_contact: bool, is_contact_critical: bool = False,
                 name: str = "body_sensor"):
        super().__init__(
            check_contact=check_contact,
            is_contact_critical=is_contact_critical,
            name=name,
            object_type=CustomUserDataObjectTypes.BODY_SENSOR
        )
        self.has_joint = False
        self.ready_to_attach = False


===== .\TeachMyAgent\environments\envs\utils\rendering.py =====
import os
import sys
import math
import numpy as np

# --- macOS compatibility fix for pyglet ---
if "Apple" in sys.version:
    if "DYLD_FALLBACK_LIBRARY_PATH" in os.environ:
        os.environ["DYLD_FALLBACK_LIBRARY_PATH"] += ":/usr/lib"

# --- Import pyglet safely ---
try:
    import pyglet
except ImportError:
    raise ImportError("Pyglet is required for rendering. Please install it via `pip install pyglet`.")

try:
    from pyglet.gl import *
except ImportError:
    raise ImportError(
        "Error importing OpenGL from pyglet. "
        "This likely occurred because pyglet installed the wrong architecture binaries."
    )

RAD2DEG = 57.29577951308232


# ============================================================================ #
#                                Utility Functions                             #
# ============================================================================ #

def get_display(spec):
    """
    Converts a display specification (e.g., ':0') into a pyglet Display object.
    Pyglet only supports multiple displays on Linux.

    Args:
        spec (str or None): Display specification string.

    Returns:
        pyglet.canvas.Display or None
    """
    if spec is None:
        return None
    elif isinstance(spec, str):
        return pyglet.canvas.Display(spec)
    else:
        raise ValueError(
            f"Invalid display specification: {spec}. Must be a string like ':0' or None."
        )


# ============================================================================ #
#                                   Viewer                                     #
# ============================================================================ #

class Viewer:
    def __init__(self, width, height, display=None, visible=True):
        display = get_display(display)
        self.width = width
        self.height = height

        self.window = pyglet.window.Window(
            width=width, height=height, display=display, vsync=False, resizable=True, visible=visible
        )
        self.window.on_close = self.window_closed_by_user
        self.window.push_handlers(self)

        self.geoms = []
        self.onetime_geoms = []
        self.transform = Transform()

        glEnable(GL_BLEND)
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)

    def close(self):
        """Safely close the rendering window."""
        if self.window:
            self.window.close()
            self.window = None

    def window_closed_by_user(self):
        """Ensure proper cleanup when the user closes the window."""
        self.close()

    def on_resize(self, width, height):
        """Handle window resizing."""
        self.width = width
        self.height = height

    def set_bounds(self, left, right, bottom, top):
        """Set the visible bounds of the window."""
        assert right > left and top > bottom
        scalex = self.width / (right - left)
        scaley = self.height / (top - bottom)
        self.transform = Transform(
            translation=(-left * scalex, -bottom * scaley),
            scale=(scalex, scaley)
        )

    def add_geom(self, geom):
        """Add a persistent geometry to be rendered each frame."""
        self.geoms.append(geom)

    def add_onetime(self, geom):
        """Add a geometry to be rendered once."""
        self.onetime_geoms.append(geom)

    def render(self, return_rgb_array=False):
        """
        Render the current scene.
        Returns the RGB image array if `return_rgb_array=True`.
        """

        # --- Safety Check 1: Handle rendering after window close ---
        if self.window is None or self.window.has_exit:
            if return_rgb_array:
                return np.zeros((self.height, self.width, 3), dtype=np.uint8)
            return None

        glClearColor(1, 1, 1, 1)
        self.window.clear()
        self.window.switch_to()
        self.window.dispatch_events()  # Process on_close event if triggered

        # --- Safety Check 2: Recheck window status after event dispatch ---
        if self.window is None or self.window.has_exit:
            if return_rgb_array:
                return np.zeros((self.height, self.width, 3), dtype=np.uint8)
            return None

        glViewport(0, 0, self.width, self.height)
        self.transform.enable()

        for geom in self.geoms:
            geom.render()
        for geom in self.onetime_geoms:
            geom.render()

        self.transform.disable()

        arr = None
        if return_rgb_array:
            buffer = pyglet.image.get_buffer_manager().get_color_buffer()
            image_data = buffer.get_image_data()
            arr = np.frombuffer(image_data.get_data(), dtype=np.uint8)
            arr = arr.reshape(buffer.height, buffer.width, 4)
            arr = arr[::-1, :, 0:3]

        self.window.flip()
        self.onetime_geoms = []
        return arr

    # --- Drawing Utilities ---

    def draw_circle(self, radius=10, res=30, filled=True, **attrs):
        geom = make_circle(radius=radius, res=res, filled=filled)
        _add_attrs(geom, attrs)
        self.add_onetime(geom)
        return geom

    def draw_polygon(self, v, filled=True, **attrs):
        geom = make_polygon(v, filled=filled)
        _add_attrs(geom, attrs)
        self.add_onetime(geom)
        return geom

    def draw_polyline(self, v, **attrs):
        geom = make_polyline(v)
        _add_attrs(geom, attrs)
        self.add_onetime(geom)
        return geom

    def draw_line(self, start, end, **attrs):
        geom = Line(start, end)
        _add_attrs(geom, attrs)
        self.add_onetime(geom)
        return geom

    def get_mouse_coords(self):
        return (self.mouse_x, self.mouse_y)


# ============================================================================ #
#                            Geometry and Attributes                           #
# ============================================================================ #

class Geom:
    """Base geometry class."""
    def __init__(self):
        self._color = Color((0, 0, 0, 1.0))
        self.attrs = [self._color]

    def render(self):
        for attr in reversed(self.attrs):
            attr.enable()
        self.render1()
        for attr in self.attrs:
            attr.disable()

    def render1(self):
        raise NotImplementedError

    def add_attr(self, attr):
        self.attrs.append(attr)

    def set_color(self, r, g, b):
        self._color.vec4 = (r, g, b, 1)


class Attr:
    """Base attribute class."""
    def enable(self):
        raise NotImplementedError

    def disable(self):
        pass


class Transform(Attr):
    """Represents translation, rotation, and scaling transformations."""
    def __init__(self, translation=(0.0, 0.0), rotation=0.0, scale=(1.0, 1.0)):
        self.set_translation(*translation)
        self.set_rotation(rotation)
        self.set_scale(*scale)

    def enable(self):
        glPushMatrix()
        glTranslatef(self.translation.x, self.translation.y, 0)
        glRotatef(RAD2DEG * self.rotation, 0, 0, 1.0)
        glScalef(self.scale.x, self.scale.y, 1.0)

    def disable(self):
        glPopMatrix()

    def set_translation(self, newx, newy):
        self.translation = Vec2(newx, newy)

    def set_rotation(self, newa):
        self.rotation = newa

    def set_scale(self, newx, newy):
        self.scale = Vec2(newx, newy)


class Color(Attr):
    def __init__(self, vec4):
        self.vec4 = vec4

    def enable(self):
        glColor4f(*self.vec4)


class LineWidth(Attr):
    def __init__(self, stroke):
        self.stroke = stroke

    def enable(self):
        glLineWidth(self.stroke)


# ============================================================================ #
#                                 Primitives                                   #
# ============================================================================ #

class Point(Geom):
    def render1(self):
        glBegin(GL_POINTS)
        glVertex3f(0.0, 0.0, 0.0)
        glEnd()


class FilledPolygon(Geom):
    def __init__(self, v):
        super().__init__()
        self.v = v

    def render1(self):
        if len(self.v) == 4:
            glBegin(GL_QUADS)
        elif len(self.v) > 4:
            glBegin(GL_POLYGON)
        else:
            glBegin(GL_TRIANGLES)
        for p in self.v:
            glVertex3f(p[0], p[1], 0)
        glEnd()


class PolyLine(Geom):
    def __init__(self, v, close):
        super().__init__()
        self.v = v
        self.close = close

    def render1(self):
        glBegin(GL_LINE_LOOP if self.close else GL_LINE_STRIP)
        for p in self.v:
            glVertex3f(p[0], p[1], 0)
        glEnd()


class Line(Geom):
    def __init__(self, start=(0.0, 0.0), end=(0.0, 0.0)):
        super().__init__()
        self.start = start
        self.end = end

    def render1(self):
        glBegin(GL_LINES)
        glVertex2f(*self.start)
        glVertex2f(*self.end)
        glEnd()


class Image(Geom):
    def __init__(self, fname, width, height):
        super().__init__()
        self.set_color(1.0, 1.0, 1.0)
        self.img = pyglet.image.load(fname)
        self.width = width
        self.height = height

    def render1(self):
        self.img.blit(-self.width / 2, -self.height / 2, width=self.width, height=self.height)


# ============================================================================ #
#                           Helper Functions                                   #
# ============================================================================ #

def make_circle(radius=10, res=30, filled=True):
    points = [(math.cos(2 * math.pi * i / res) * radius,
               math.sin(2 * math.pi * i / res) * radius) for i in range(res)]
    return FilledPolygon(points) if filled else PolyLine(points, True)


def make_polygon(v, filled=True):
    return FilledPolygon(v) if filled else PolyLine(v, True)


def make_polyline(v):
    return PolyLine(v, False)


def _add_attrs(geom, attrs):
    if "color" in attrs:
        geom.set_color(*attrs["color"])
    if "linewidth" in attrs:
        geom.add_attr(LineWidth(attrs["linewidth"]))


# ============================================================================ #
#                             Simple Image Viewer                              #
# ============================================================================ #

class SimpleImageViewer:
    def __init__(self, display=None, maxwidth=500):
        self.window = None
        self.isopen = False
        self.display = display
        self.maxwidth = maxwidth

    def imshow(self, arr):
        if self.window is None:
            height, width, _ = arr.shape
            if width > self.maxwidth:
                scale = self.maxwidth / width
                width = int(scale * width)
                height = int(scale * height)
            self.window = pyglet.window.Window(
                width=width, height=height, display=self.display, vsync=False, resizable=True
            )
            self.width = width
            self.height = height
            self.isopen = True

            @self.window.event
            def on_resize(width, height):
                self.width = width
                self.height = height

            @self.window.event
            def on_close():
                self.isopen = False

        assert arr.shape[0] == self.height and arr.shape[1] == self.width, \
            f"Image shape {arr.shape} does not match window size {(self.height, self.width)}."

        image = pyglet.image.ImageData(
            self.width, self.height, "RGB", arr.tobytes(), pitch=self.width * -3
        )
        self.window.clear()
        self.window.switch_to()
        self.window.dispatch_events()
        image.blit(0, 0)
        self.window.flip()

    def close(self):
        if self.isopen:
            self.window.close()
            self.isopen = False

    def __del__(self):
        self.close()


# ============================================================================ #
#                                   Vec2                                       #
# ============================================================================ #

class Vec2:
    """Simple 2D vector class."""
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

    def __repr__(self):
        return f"Vec2({self.x:.2f}, {self.y:.2f})"


===== .\TeachMyAgent\environments\envs\utils\__init__.py =====


===== .\utils\env_utils.py =====
# utils/env_utils.py
import gymnasium as gym
import numpy as np
import tkinter as tk
from TeachMyAgent.environments.envs.bodies.BodiesEnum import BodiesEnum
from TeachMyAgent.environments.envs.bodies.BodyTypesEnum import BodyTypesEnum

def get_screen_resolution():
    """Get screen resolution."""
    try:
        root = tk.Tk()
        root.withdraw()
        w, h = root.winfo_screenwidth(), root.winfo_screenheight()
        root.destroy()
        return w, h
    except Exception:
        return 1280, 720

def collect_env_params(env_key, args):
    """Collect environment parameters from command-line args into a dictionary."""
    params = {}
    if env_key == 'stump':
        if hasattr(args, 'roughness') and args.roughness is not None:
            params['roughness'] = args.roughness
        if hasattr(args, 'stump_height') and args.stump_height is not None:
            params['stump_height'] = tuple(args.stump_height)
        if hasattr(args, 'stump_width') and args.stump_width is not None:
            params['stump_width'] = tuple(args.stump_width)
        if hasattr(args, 'obstacle_spacing') and args.obstacle_spacing is not None:
            params['obstacle_spacing'] = args.obstacle_spacing
    
    elif env_key == 'parkour':
        if hasattr(args, 'input_vector') and args.input_vector is not None:
            params['input_vector'] = np.array(args.input_vector)
        if hasattr(args, 'water_level') and args.water_level is not None:
            params['water_level'] = args.water_level
        if hasattr(args, 'creepers_width') and args.creepers_width is not None:
            params['creepers_width'] = args.creepers_width
        if hasattr(args, 'creepers_height') and args.creepers_height is not None:
            params['creepers_height'] = args.creepers_height
        if hasattr(args, 'creepers_spacing') and args.creepers_spacing is not None:
            params['creepers_spacing'] = args.creepers_spacing
    
    return params

def build_and_setup_env(env_key, body_name, user_params, render_mode=None, args=None):
    """Create and configure the environment with default and user parameters."""
    
    mapping = {
        'stump': ('parametric-continuous-stump-tracks-v0', 'walker_type'),
        'parkour': ('parametric-continuous-parkour-v0', 'agent_body_type'),
    }
    env_id, param_name = mapping.get(env_key, (None, None))
    if not env_id:
        raise ValueError(f"Invalid environment '{env_key}'.")

    env_kwargs = {param_name: body_name}
    
    if render_mode:
        env_kwargs['render_mode'] = render_mode
        
    if args and hasattr(args, 'horizon') and args.horizon is not None:
        env_kwargs['horizon'] = args.horizon

    if env_key == "parkour":
        body_type = BodiesEnum.get_body_type(body_name)
        lidar_map = {BodyTypesEnum.CLIMBER: 'up', BodyTypesEnum.SWIMMER: 'full', BodyTypesEnum.WALKER: 'full'}
        env_kwargs['lidars_type'] = lidar_map.get(body_type, 'down') # 'down' s·∫Ω l√† fallback
        print(f"Automatically set Lidar to '{env_kwargs['lidars_type']}' for body '{body_name}'.")

        if body_type in [BodyTypesEnum.SWIMMER, BodyTypesEnum.AMPHIBIAN]:
            from TeachMyAgent.environments.envs.parametric_continuous_parkour import WATER_DENSITY
            env_kwargs['density'] = WATER_DENSITY
            print(f"Automatically set density for body '{body_name}'.")
    
    env = gym.make(env_id, **env_kwargs)
    
    if env_key == "stump":
        default_params = {"roughness": 0.0, "stump_height": (0.1, 0.05)}
        default_params.update(user_params)
        env.unwrapped.set_environment(**default_params)
        print("STUMP environment configured with:", default_params)

    elif env_key == "parkour":
        default_params = {
            "input_vector": np.array([-0.25, 0.8, 0.0]),
            "water_level": 0.1,
            "creepers_width": 0.25,
            "creepers_height": 2.0,
            "creepers_spacing": 1.5
        }
        if 'creepers_height' in user_params and user_params['creepers_height'] == 0:
            user_params['creepers_width'] = None

        default_params.update(user_params)
        env.unwrapped.set_environment(**default_params)
        print("PARKOUR environment configured with:", default_params)
        
    return env

def setup_render_window(env, args):
    """Compute and apply render window resolution."""
    if hasattr(env.unwrapped, "_SET_RENDERING_VIEWPORT_SIZE"):
        screen_w, screen_h = get_screen_resolution()
        if args.fullscreen:
            render_width, render_height = screen_w, screen_h
        elif args.width and args.height:
            render_width, render_height = args.width, args.height
        else:
            render_height = int(screen_h * 0.8)
            render_width = int(render_height * 16 / 9)
        
        print(f"Render resolution set to: {render_width}x{render_height}")
        env.unwrapped._SET_RENDERING_VIEWPORT_SIZE(render_width, render_height, keep_ratio=False)

===== .\utils\marl_utils.py =====
import gymnasium as gym
import numpy as np

class SB3MultiAgentWrapper(gym.Wrapper):
    """
    Wrapper that converts an RLlib MultiAgentEnv into a Stable Baselines 3‚Äìcompatible
    environment by flattening observations and actions across all agents.
    """
    def __init__(self, env):
        super().__init__(env)
        # RLlib's MultiAgentEnv doesn‚Äôt follow gym.Wrapper‚Äôs API,
        # so we access the base environment via self.env.
        self.agents = self.env.possible_agents
        
        agent_obs_space = self.env.observation_space[self.agents[0]]
        agent_act_space = self.env.action_space[self.agents[0]]
        
        self.observation_space = gym.spaces.Box(
            low=np.tile(agent_obs_space.low, len(self.agents)),
            high=np.tile(agent_obs_space.high, len(self.agents)),
            dtype=agent_obs_space.dtype
        )

        if isinstance(agent_act_space, gym.spaces.Box):
            self.action_space = gym.spaces.Box(
                low=np.tile(agent_act_space.low, len(self.agents)),
                high=np.tile(agent_act_space.high, len(self.agents)),
                dtype=agent_act_space.dtype
            )
        else:
            raise NotImplementedError("Only Box action spaces are supported in this wrapper.")

    def reset(self, **kwargs):
        obs, info = self.env.reset(**kwargs)
        return self._flatten_obs(obs), info

    def step(self, action):
        split_actions = np.split(action, len(self.agents))
        action_dict = {agent: act for agent, act in zip(self.agents, split_actions)}
        
        obs, reward, terminated, truncated, info = self.env.step(action_dict)
        
        flat_obs = self._flatten_obs(obs)
        total_reward = sum(reward.values()) if isinstance(reward, dict) else reward
        all_done = terminated.get('__all__', False)
        all_trunc = truncated.get('__all__', False)
        
        return flat_obs, total_reward, all_done or all_trunc, info

    def _flatten_obs(self, obs_dict):
        """Flatten agent observations from a dict into a single NumPy array."""
        obs_list = []
        for agent in self.agents:
            if agent in obs_dict:
                obs_list.append(obs_dict[agent])
            else:
                # If an agent is done, its observation may be missing from the dict
                obs_list.append(np.zeros_like(self.env.observation_space[agent].sample()))
        return np.concatenate(obs_list)

    @property
    def unwrapped(self):
        """Return the base environment (for attributes like `viewer`)."""
        return self.env


===== .\utils\seeding.py =====
# utils/seeding.py
import random
import numpy as np
import torch

def set_seed(seed: int):
    """Sets the seed for reproducibility."""
    if seed is None:
        return
    random.seed(seed)
    np.random.seed(seed)
    torch.manual_seed(seed)
    if torch.cuda.is_available():
        torch.cuda.manual_seed(seed)
        torch.cuda.manual_seed_all(seed)
        # Potentially slow down training, but ensures reproducibility
        torch.backends.cudnn.deterministic = True
        torch.backends.cudnn.benchmark = False

===== .\utils\shared_args.py =====
# shared_args.py
import argparse

def available_bodies():
    """Return a list of available agent bodies."""
    from TeachMyAgent.environments.envs.bodies.BodiesEnum import BodiesEnum
    return [e.name for e in BodiesEnum]

def add_common_args(parser):
    """Add common arguments for environment and agent."""
    parser.add_argument('--env', type=str, default='parkour',
                        choices=['stump', 'parkour'],
                        help="Select environment.")
    parser.add_argument('--body', type=str, default='classic_bipedal',
                        help=f"Select body. Available: {available_bodies()}")
    return parser

def add_environment_args(parser):
    """Add all environment parameters to the ArgumentParser."""
    # Stump environment parameters
    stump_group = parser.add_argument_group('Stump Environment Parameters')
    stump_group.add_argument('--roughness', type=float, help="Terrain roughness.")
    stump_group.add_argument('--stump_height', type=float, nargs=2, metavar=('MEAN', 'STD'),
                             help="Mean and standard deviation of obstacle height.")
    stump_group.add_argument('--stump_width', type=float, nargs=2, metavar=('MEAN', 'STD'),
                             help="Mean and standard deviation of obstacle width.")
    stump_group.add_argument('--obstacle_spacing', type=float, help="Spacing between obstacles.")

    # Parkour environment parameters
    parkour_group = parser.add_argument_group('Parkour Environment Parameters')
    parkour_group.add_argument('--input_vector', type=float, nargs='+',
                               help="Input vector for CPPN terrain generation.")
    parkour_group.add_argument('--water_level', type=float, help="Water level (0.0‚Äì1.0).")
    parkour_group.add_argument('--creepers_width', type=float, help="Width of climbing objects.")
    parkour_group.add_argument('--creepers_height', type=float,
                               help="Height of climbing objects (0 = none).")
    parkour_group.add_argument('--creepers_spacing', type=float,
                               help="Spacing between climbing objects.")
    
    return parser

def add_render_args(parser):
    """Add rendering/display parameters to the ArgumentParser."""
    render_group = parser.add_argument_group('Rendering Parameters')
    render_group.add_argument('--width', type=int, help="Window width (manual override).")
    render_group.add_argument('--height', type=int, help="Window height (manual override).")
    render_group.add_argument('--fullscreen', action='store_true', help="Enable fullscreen mode.")
    return parser


===== .\utils\__init__.py =====


===== DIRECTORY TREE =====
./
    LICENSE
    README.md
    requirements.txt
    run.py
    configs/
        main_pipeline.yaml
    output/
        acl/
            test_suite_acl/
                vecnormalize.pkl
                logs/
                    student/
                        PPO_0/
                            events.out.tfevents.1762148472.HoangNam.11604.1
                            events.out.tfevents.1762148480.HoangNam.11604.2
                            events.out.tfevents.1762148664.HoangNam.23896.1
                            events.out.tfevents.1762148674.HoangNam.23896.2
                            events.out.tfevents.1762149025.HoangNam.4404.1
                            events.out.tfevents.1762149033.HoangNam.4404.2
                            events.out.tfevents.1762149192.HoangNam.20356.1
                            events.out.tfevents.1762149201.HoangNam.20356.2
                            events.out.tfevents.1762149394.HoangNam.12420.1
                            events.out.tfevents.1762149404.HoangNam.12420.2
                            events.out.tfevents.1762149635.HoangNam.20680.1
                            events.out.tfevents.1762149649.HoangNam.20680.2
                            events.out.tfevents.1762149833.HoangNam.8828.1
                            events.out.tfevents.1762149842.HoangNam.8828.2
                            events.out.tfevents.1762150052.HoangNam.7044.1
                            events.out.tfevents.1762150109.HoangNam.13716.1
                            events.out.tfevents.1762150121.HoangNam.13716.2
                            events.out.tfevents.1762150590.HoangNam.25084.1
                            events.out.tfevents.1762150602.HoangNam.25084.2
                models/
                    student_final.zip
        marl/
            test_suite_marl/
                algorithm_state.pkl
                class_and_ctor_args.pkl
                rllib_checkpoint.json
                env_runner/
                    class_and_ctor_args.pkl
                    metadata.json
                    state.pkl
                    env_to_module_connector/
                        class_and_ctor_args.pkl
                        metadata.json
                        state.pkl
                    module_to_env_connector/
                        class_and_ctor_args.pkl
                        metadata.json
                        state.pkl
                learner_group/
                    class_and_ctor_args.pkl
                    metadata.json
                    state.pkl
                    learner/
                        class_and_ctor_args.pkl
                        metadata.json
                        state.pkl
                        rl_module/
                            class_and_ctor_args.pkl
                            metadata.json
                            module_state.pkl
                            shared_policy/
                                class_and_ctor_args.pkl
                                metadata.json
                                module_state.pkl
        ppo/
            test_suite_ppo/
                vecnormalize.pkl
                logs/
                    PPO_1/
                        events.out.tfevents.1762148456.HoangNam.11604.0
                    PPO_10/
                        events.out.tfevents.1762150574.HoangNam.25084.0
                    PPO_2/
                        events.out.tfevents.1762148647.HoangNam.23896.0
                    PPO_3/
                        events.out.tfevents.1762149008.HoangNam.4404.0
                    PPO_4/
                        events.out.tfevents.1762149179.HoangNam.20356.0
                    PPO_5/
                        events.out.tfevents.1762149382.HoangNam.12420.0
                    PPO_6/
                        events.out.tfevents.1762149623.HoangNam.20680.0
                    PPO_7/
                        events.out.tfevents.1762149817.HoangNam.8828.0
                    PPO_8/
                        events.out.tfevents.1762150036.HoangNam.7044.0
                    PPO_9/
                        events.out.tfevents.1762150092.HoangNam.13716.0
                models/
                    ppo_model_1024_steps.zip
                    ppo_model_1280_steps.zip
                    ppo_model_1536_steps.zip
                    ppo_model_1792_steps.zip
                    ppo_model_2048_steps.zip
                    ppo_model_2304_steps.zip
                    ppo_model_2560_steps.zip
                    ppo_model_256_steps.zip
                    ppo_model_2816_steps.zip
                    ppo_model_3072_steps.zip
                    ppo_model_3328_steps.zip
                    ppo_model_3584_steps.zip
                    ppo_model_3840_steps.zip
                    ppo_model_4096_steps.zip
                    ppo_model_4352_steps.zip
                    ppo_model_4608_steps.zip
                    ppo_model_4864_steps.zip
                    ppo_model_5120_steps.zip
                    ppo_model_512_steps.zip
                    ppo_model_5376_steps.zip
                    ppo_model_5632_steps.zip
                    ppo_model_5888_steps.zip
                    ppo_model_6144_steps.zip
                    ppo_model_6400_steps.zip
                    ppo_model_6656_steps.zip
                    ppo_model_6912_steps.zip
                    ppo_model_7168_steps.zip
                    ppo_model_7424_steps.zip
                    ppo_model_7680_steps.zip
                    ppo_model_768_steps.zip
                    ppo_model_7936_steps.zip
                    ppo_model_8192_steps.zip
                    ppo_model_final.zip
    preprocessing/
        convert_weight.py
        __init__.py
    scripts/
        calculate_map_length.py
        check_all.py
        check_map_length.py
        demo.py
        evaluate.py
        run_single_test.py
        test_suite.py
        train_acl.py
        train_marl.py
        train_ppo.py
        watch.py
        __init__.py
    TeachMyAgent/
        __init__.py
        environments/
            __init__.py
            envs/
                interactive_multi_agent_parkour.py
                LidarCallback_class.py
                multi_agent_parametric_parkour.py
                parametric_continuous_parkour.py
                parametric_continuous_stump_tracks.py
                __init__.py
                bodies/
                    AbstractBody.py
                    BodiesEnum.py
                    BodyTypesEnum.py
                    __init__.py
                    amphibians/
                        AmphibianAbstractBody.py
                        AmphibiousBipedalBody.py
                        __init__.py
                    climbers/
                        ClimberAbstractBody.py
                        ClimbingChestProfileChimpanzee.py
                        ClimbingProfileChimpanzee.py
                        __init__.py
                    swimmers/
                        FishBody.py
                        SwimmerAbstractBody.py
                        __init__.py
                    walkers/
                        BigQuadruBody.py
                        ClassicBipedalBody.py
                        MillipedeBody.py
                        ProfileChimpanzee.py
                        SmallBipedalBody.py
                        SpiderBody.py
                        WalkerAbstractBody.py
                        WheelBody.py
                        __init__.py
                        old/
                            OldBigQuadruBody.py
                            OldClassicBipedalBody.py
                            __init__.py
                Box2D_dynamics/
                    climbing_dynamics.py
                    water_dynamics.py
                    __init__.py
                PCGAgents/
                    CPPN/
                        BaseCPPN.py
                        cppn_pytorch.py
                        GroundAndCeiling_CPPN_Analysis.ipynb
                        TanHSoftplusMixCPPN.py
                        weights/
                            same_ground_ceiling_cppn_pytorch.pt
                            ground_cppn/
                                .data-00000-of-00001
                                .index
                                .meta
                                checkpoint
                            same_ground_ceiling_cppn/
                                checkpoint
                                model.ckpt.data-00000-of-00001
                                model.ckpt.index
                                model.ckpt.meta
                utils/
                    custom_user_data.py
                    rendering.py
                    __init__.py
    utils/
        env_utils.py
        marl_utils.py
        seeding.py
        shared_args.py
        __init__.py
