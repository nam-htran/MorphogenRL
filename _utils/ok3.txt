
===== .\run.py =====
# run.py
import argparse
import os
import sys
import yaml
from types import SimpleNamespace
import ray

sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from scripts import demo as demo_script
from scripts import train_ppo, train_acl, train_marl, watch
from scripts import test_suite as test_suite_script
from preprocessing import convert_weight
from scripts import record as record_script

def load_config(config_path):
    if not os.path.exists(config_path):
        print(f"ERROR: Config not found at '{config_path}'")
        sys.exit(1)
    with open(config_path, 'r', encoding='utf-8') as f:
        return yaml.safe_load(f)

def print_header(title):
    width = 80
    print("\n\n" + "#"*width + f"\n##{title:^76}##\n" + "#"*width)

def run_task(func, args_namespace, task_name):
    print_header(f"START TASK: {task_name.upper()}")
    try:
        result = func(args_namespace) if args_namespace else func()
        print_header(f"FINISHED TASK: {task_name.upper()}")
        return result
    except KeyboardInterrupt:
        print(f"\nINFO: Task '{task_name}' stopped by user.")
        sys.exit(0)
    except Exception as e:
        if e.__class__.__name__ == 'UserInterrupt':
            print(f"\nINFO: Task '{task_name}' stopped by user.")
            sys.exit(0)
        print(f"\nERROR: Task '{task_name}' failed.")
        import traceback
        traceback.print_exc()
        sys.exit(1)

def run_pipeline(args):
    config = load_config(args.config)
    global_cfg = {'watch': args.watch, 'WATCH': config.get('WATCH', {})}
    
    for stage_name in ['PPO', 'ACL', 'MARL']:
        if not config.get(stage_name, {}).get('enabled', False):
            continue
        cfg = config[stage_name]

        if stage_name in ['PPO', 'ACL']:
            print(f"Skipping stage: {stage_name}")
            continue

        elif stage_name == 'MARL':
            marl_args = SimpleNamespace(**cfg)
            
            if not hasattr(marl_args, 'check_env'): marl_args.check_env = False
            if not hasattr(marl_args, 'width'): marl_args.width = None
            if not hasattr(marl_args, 'height'): marl_args.height = None
            if not hasattr(marl_args, 'fullscreen'): marl_args.fullscreen = False
            
            checkpoint_path = run_task(train_marl.main, marl_args, f"MARL Training ({cfg['mode']})")
            
            if args.watch and checkpoint_path:
                print_header("WATCH MARL (INFO)")
                print("RLlib MARL checkpoints are complex and not directly supported by 'watch.py'.")
                print("To watch a trained MARL agent, you would need to manually load the checkpoint")
                print("using RLlib's API and run an inference loop.")
                print(f"Best MARL checkpoint from tuning saved at: {checkpoint_path}")

    print_header("PIPELINE COMPLETE")

if __name__ == '__main__':
    temp_dir = "D:/ray_tmp" 
    print(f"Initializing Ray with temporary directory: {temp_dir}")
    os.makedirs(temp_dir, exist_ok=True)
    ray.init(
        ignore_reinit_error=True, 
        _temp_dir=temp_dir,
        object_store_memory=10**9 # 1GB
    )
    
    try:
        parser = argparse.ArgumentParser(description="Main entry point for TeachMyAgent.", formatter_class=argparse.RawTextHelpFormatter)
        subparsers = parser.add_subparsers(dest='command', required=True)

        pipeline_parser = subparsers.add_parser('pipeline', help="Run training pipeline from config.")
        pipeline_parser.add_argument('--config', type=str, default='configs/main_pipeline.yaml')
        pipeline_parser.add_argument('--watch', action='store_true')
        pipeline_parser.add_argument('--render-stages', action='store_true')
        pipeline_parser.set_defaults(func=run_pipeline)

        # ... (C√°c subparsers kh√°c gi·ªØ nguy√™n)

        args = parser.parse_args()
        if hasattr(args, 'func'):
            args.func(args)
        else:
            parser.print_help()

    finally:
        if ray.is_initialized():
            ray.shutdown()
            print("Ray has been shut down.")

===== .\preprocessing\convert_weight.py =====
import tensorflow as tf
import torch
import numpy as np
import os

# Suppress unnecessary TensorFlow 1.x warnings
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'
if tf.__version__.startswith('1.'):
    tf.logging.set_verbosity(tf.logging.ERROR)

def convert_tf1_to_pytorch(project_root=None):
    """
    Convert TensorFlow 1.x checkpoint weights to a PyTorch state_dict.
    """
    if project_root is None:
        project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

    TF_WEIGHTS_DIR = os.path.join(project_root, 'TeachMyAgent', 'environments', 'envs', 'PCGAgents', 'CPPN', 'weights', 'same_ground_ceiling_cppn')
    PYTORCH_WEIGHTS_PATH = os.path.join(project_root, 'TeachMyAgent', 'environments', 'envs', 'PCGAgents', 'CPPN', 'weights', 'same_ground_ceiling_cppn_pytorch.pt')

    # Skip conversion if PyTorch weights already exist
    if os.path.exists(PYTORCH_WEIGHTS_PATH):
        print(f"PyTorch weights already exist at: {PYTORCH_WEIGHTS_PATH}. Skipping conversion.")
        return
    
    TF_VAR_TO_PYTORCH_NAME = {
        'Variable':   '0.weight', 
        'Variable_1': '2.weight', 
        'Variable_2': '4.weight',
        'Variable_3': '6.weight', 
        'Variable_4': '8.weight',
    }

    print("Starting weight conversion...")
    checkpoint_path = tf.train.latest_checkpoint(TF_WEIGHTS_DIR)
    if not checkpoint_path:
        print(f"ERROR: No checkpoint found in {TF_WEIGHTS_DIR}.")
        return

    try:
        reader = tf.train.NewCheckpointReader(checkpoint_path)
        pytorch_state_dict = {}
        
        print("\n--- Variables found in checkpoint ---")
        for key in sorted(reader.get_variable_to_shape_map().keys()):
            print(f"  Name: {key}")
        print("------------------------------------------")
        
        for tf_name, pt_name in TF_VAR_TO_PYTORCH_NAME.items():
            if reader.has_tensor(tf_name):
                weight_numpy = reader.get_tensor(tf_name)
                # Transpose to match PyTorch Linear (out_features, in_features)
                pytorch_state_dict[pt_name] = torch.from_numpy(weight_numpy).float().T
            else:
                print(f"ERROR: Variable '{tf_name}' not found in checkpoint!")
                return
        print("\nWeight extraction and mapping successful.")

    except Exception as e:
        print(f"ERROR while reading checkpoint: {e}")
        return

    torch.save(pytorch_state_dict, PYTORCH_WEIGHTS_PATH)
    print(f"Converted weights saved to: {PYTORCH_WEIGHTS_PATH}")

if __name__ == '__main__':
    if not tf.__version__.startswith('1.'):
        print("Error: TensorFlow 1.x required to run this conversion script directly.")
        exit()
    convert_tf1_to_pytorch()


===== .\preprocessing\__init__.py =====


===== .\scripts\check_all.py =====
# scripts/check_all.py
import argparse
import os
import sys
import subprocess
from types import SimpleNamespace

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from utils.shared_args import available_bodies

def print_header(text, char='='):
    width = 80
    print("\n" + char * width)
    print(f"{text:^{width}}")
    print(char * width)

def print_success(text):
    print(f"‚úÖ SUCCESS: {text}")

def print_failure(text):
    print(f"‚ùå FAILURE: {text}")

def add_check_all_args(parser):
    parser.add_argument('--env', type=str, default='all',
                        choices=['all', 'stump', 'parkour', 'marl-cooperative', 'marl-interactive'],
                        help="Environment type to test.")
    parser.add_argument('--body', type=str, default='all',
                        help="Body type to test. Use 'all' to test all available ones.")
    parser.add_argument('--steps', type=int, default=100,
                        help="Number of random steps to run in each test.")
    parser.add_argument('--delay', type=float, default=0.02,
                        help="Pause duration (seconds) between steps for visualization.")
    return parser

def main(args):
    all_bodies = available_bodies()
    bodies_to_test = all_bodies if args.body == 'all' else [args.body]

    if args.body != 'all' and args.body not in all_bodies:
        print(f"ERROR: Body '{args.body}' not found. Available bodies: {all_bodies}")
        sys.exit(1)

    all_envs = ['stump', 'parkour', 'marl-cooperative', 'marl-interactive']
    envs_to_test = all_envs if args.env == 'all' else [args.env]
        
    test_plan = [(env_key, body_name) for env_key in envs_to_test for body_name in bodies_to_test]
    
    failures = 0
    total_tests = len(test_plan)
    
    print_header(f"STARTING FULL TEST: {total_tests} TESTS")
    
    single_test_script_path = os.path.join(os.path.dirname(__file__), 'run_single_test.py')

    for i, (env_key, body_name) in enumerate(test_plan):
        test_name = f"Env: '{env_key}', Body: '{body_name}'"
        print(f"\n--- Test [{i+1}/{total_tests}]: {test_name} ---")

        command = [
            sys.executable,
            single_test_script_path,
            '--env', env_key,
            '--body', body_name,
            '--steps', str(args.steps),
            '--delay', str(args.delay)
        ]

        child_env = os.environ.copy()
        child_env['PYTHONIOENCODING'] = 'utf-8'
        
        result = subprocess.run(
            command, 
            capture_output=True, 
            text=True, 
            encoding='utf-8',
            errors='replace',
            env=child_env
        )

        if result.returncode == 0:
            print_success(test_name)
            if result.stdout:
                print(result.stdout.strip())
        else:
            print_failure(test_name)
            failures += 1
            print("------- ERROR FROM CHILD PROCESS -------")
            print(result.stdout)
            print(result.stderr)
            print("---------------------------------------")
            
    print_header("TEST SUMMARY")
    if failures == 0:
        print(f"üéâ All {total_tests} tests passed successfully! üéâ")
    else:
        print(f"üî• {failures} out of {total_tests} tests failed. Please check logs above.")
        sys.exit(1)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Run full environment and agent tests.")
    parser = add_check_all_args(parser)
    args = parser.parse_args()
    main(args)


===== .\scripts\demo.py =====
# scripts/demo.py
import argparse
import time
import os
import sys
import numpy as np

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import TeachMyAgent.environments
from utils.env_utils import build_and_setup_env, collect_env_params, setup_render_window
from utils.shared_args import add_common_args, add_environment_args, add_render_args

def add_demo_args(parser):
    parser = add_common_args(parser)
    parser = add_environment_args(parser)
    parser = add_render_args(parser)
    parser.add_argument('--steps', type=int, default=2000, help="Number of steps to run in the demo.")
    return parser

def main(args):
    print(f"--- Demo Configuration ---\nEnvironment: {args.env}\nBody: {args.body}\n---------------------------")
    env = None
    try:
        user_params = collect_env_params(args.env, args)
        env = build_and_setup_env(args.env, args.body, user_params, render_mode="human")
        setup_render_window(env, args)
        obs, info = env.reset(seed=np.random.randint(1000))
        
        for step in range(args.steps):
            env.render()

            # Safe exit if window is closed
            if env.unwrapped.viewer and env.unwrapped.viewer.window and env.unwrapped.viewer.window.has_exit:
                print("Window closed. Exiting demo.")
                break

            action = env.action_space.sample()
            obs, reward, terminated, truncated, info = env.step(action)
            time.sleep(1.0 / 60.0)

            if terminated or truncated:
                print(f"Episode ended after {step+1} steps. Resetting environment.")
                obs, info = env.reset()
    except KeyboardInterrupt:
        print("\nDemo interrupted by user.")
    finally:
        if env:
            env.close()
            print("Environment closed.")

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description="Run an environment demo.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser = add_demo_args(parser)
    args = parser.parse_args()
    main(args)


===== .\scripts\record.py =====
# scripts/record.py
import argparse
import time
import os
import sys
import numpy as np
import cv2  # OpenCV for video recording

# Add project root to path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from utils.env_utils import build_and_setup_env, collect_env_params, setup_render_window
from utils.shared_args import add_common_args, add_environment_args, add_render_args
from stable_baselines3 import PPO

# Custom exception to handle user interruption
class UserInterrupt(Exception):
    pass

def add_record_args(parser):
    """Add CLI arguments for recording."""
    parser.add_argument('--model_path', type=str, required=True, help="Path to the trained model (.zip).")
    
    parser = add_common_args(parser)
    parser = add_environment_args(parser)
    parser = add_render_args(parser)
    
    record_group = parser.add_argument_group('Recording Parameters')
    record_group.add_argument('-o', '--output', type=str, default='recordings/recording.mp4', help="Output MP4 file path.")
    record_group.add_argument('--num_episodes', type=int, default=1, help="Number of episodes to record.")
    record_group.add_argument('--timeout', type=int, default=2000, help="Maximum number of steps per episode.")
    record_group.add_argument('--fps', type=int, default=60, help="FPS of the output video.")
    return parser

def main(args):
    """Main function: load model, simulate, and record video."""
    print(f"--- Starting Video Recording ---\nModel: {args.model_path}\nOutput: {args.output}\n--------------------")

    if not os.path.exists(args.model_path):
        print(f"ERROR: Model not found at '{args.model_path}'")
        sys.exit(1)

    # Ensure output directory exists
    output_dir = os.path.dirname(args.output)
    if output_dir:
        os.makedirs(output_dir, exist_ok=True)

    env = None
    video_writer = None
    try:
        user_params = collect_env_params(args.env, args)
        env = build_and_setup_env(args.env, args.body, user_params, render_mode="rgb_array")
        setup_render_window(env, args)

        print("Loading model...")
        model = PPO.load(args.model_path)
        print("Model loaded successfully.")

        obs, info = env.reset()
        frame = env.render()
        height, width, _ = frame.shape
        fourcc = cv2.VideoWriter_fourcc(*'mp4v')
        video_writer = cv2.VideoWriter(args.output, fourcc, args.fps, (width, height))
        print(f"Initialized video file: {width}x{height} @ {args.fps} FPS.")
        
        print("\nRecording video... this may take a while and will not open a display window.")

        for i in range(args.num_episodes):
            if i > 0:
                obs, info = env.reset()

            done = False
            ep_len = 0
            print(f"--- Recording Episode {i+1}/{args.num_episodes} ---")
            
            # Write first frame
            bgr_frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
            video_writer.write(bgr_frame)

            while not done:
                action, _states = model.predict(obs, deterministic=True)
                obs, reward, terminated, truncated, info = env.step(action)
                done = terminated or truncated
                ep_len += 1
                
                frame = env.render()
                bgr_frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
                video_writer.write(bgr_frame)
                
                if ep_len >= args.timeout:
                    print(f"  -> Episode stopped after exceeding {args.timeout} steps (timeout).")
                    done = True

            print(f"Episode {i+1} finished after {ep_len} steps.")

    except KeyboardInterrupt:
        print("\nStopped by user (Ctrl+C).")
        raise UserInterrupt
    finally:
        if env:
            env.close()
        if video_writer:
            video_writer.release()
            print(f"\n‚úÖ Video saved successfully at: {args.output}")

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Record an MP4 video of a trained agent.")
    parser = add_record_args(parser)
    args = parser.parse_args()
    
    try:
        main(args)
    except UserInterrupt:
        sys.exit(0)

===== .\scripts\run_single_test.py =====
# scripts/run_single_test.py
import argparse
import os
import sys
import time
from types import SimpleNamespace

# Add root directory to import path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import TeachMyAgent.environments
from utils.env_utils import build_and_setup_env, setup_render_window
from TeachMyAgent.environments.envs.multi_agent_parametric_parkour import MultiAgentParkour
from TeachMyAgent.environments.envs.interactive_multi_agent_parkour import InteractiveMultiAgentParkour


def check_single_agent_env(env_key, body_name, steps, delay):
    """Single-agent test."""
    env = None
    try:
        fake_args = SimpleNamespace(fullscreen=False, width=None, height=None)
        env = build_and_setup_env(env_key, body_name, {}, render_mode="human")
        setup_render_window(env, fake_args)
        env.reset()
        for _ in range(steps):
            env.render()
            if env.unwrapped.viewer and env.unwrapped.viewer.window and env.unwrapped.viewer.window.has_exit:
                break
            action = env.action_space.sample()
            env.step(action)
            time.sleep(delay)
        return True
    finally:
        if env:
            env.close()


def check_multi_agent_env(mode, body_name, steps, delay):
    """Multi-agent test."""
    env = None
    try:
        fake_args = SimpleNamespace(fullscreen=False, width=None, height=None, n_agents=2)
        env_config = {
            "n_agents": fake_args.n_agents,
            "agent_body_type": body_name,
            "render_mode": "human"
        }

        if mode == 'cooperative':
            env = MultiAgentParkour(config=env_config)
            if env.envs:
                setup_render_window(env.envs[0], fake_args)
        else:  # interactive
            env = InteractiveMultiAgentParkour(config=env_config)
            setup_render_window(env, fake_args)
        
        env.reset()
        for _ in range(steps):
            env.render()
            viewer = env.viewer if hasattr(env, 'viewer') and env.viewer else (
                env.envs[0].viewer if hasattr(env, 'envs') and env.envs else None
            )
            if viewer and viewer.window and viewer.window.has_exit:
                break
            action = env.action_space.sample()
            _, _, terminated, truncated, _ = env.step(action)
            if terminated.get("__all__", False) or truncated.get("__all__", False):
                env.reset()
            time.sleep(delay)
        return True
    finally:
        if env:
            env.close()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Run a single environment test.")
    parser.add_argument('--env', type=str, required=True, help="Environment type.")
    parser.add_argument('--body', type=str, required=True, help="Body type.")
    parser.add_argument('--steps', type=int, default=100)
    parser.add_argument('--delay', type=float, default=0.02)
    args = parser.parse_args()

    try:
        success = False
        if args.env in ['stump', 'parkour']:
            success = check_single_agent_env(args.env, args.body, args.steps, args.delay)
        elif args.env == 'marl-cooperative':
            success = check_multi_agent_env('cooperative', args.body, args.steps, args.delay)
        elif args.env == 'marl-interactive':
            success = check_multi_agent_env('interactive', args.body, args.steps, args.delay)

        sys.exit(0 if success else 1)
    except Exception:
        import traceback
        traceback.print_exc()
        sys.exit(1)


===== .\scripts\test_suite.py =====
# scripts/test_suite.py
import argparse
import os
import sys
from types import SimpleNamespace

# Add project root to path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from preprocessing import convert_weight
from scripts import demo as demo_script
from scripts import train_ppo
from scripts import train_acl
from scripts import train_marl
from scripts import watch
from utils.shared_args import available_bodies

def print_header(text, char='='):
    width = 80
    print("\n" + char * width)
    print(f"{text:^{width}}")
    print(char * width)

def run_test(func, args_namespace, test_name):
    print_header(f"RUNNING TEST: {test_name.upper()}", char='-')
    if args_namespace:
        print(f"Args: {vars(args_namespace)}")
    try:
        result = func(args_namespace) if args_namespace else func()
        print(f"‚úÖ SUCCESS: {test_name} completed.")
        return result, True
    except Exception:
        print(f"‚ùå FAILURE: {test_name} failed.")
        import traceback
        traceback.print_exc()
        return None, False

def main(args=None):
    print_header("STARTING FULL PIPELINE TEST")
    overall_success = True

    # Test 1: Weight conversion
    _, success = run_test(convert_weight.convert_tf1_to_pytorch, None, "Convert Weight")
    if not success: overall_success = False

    # Test 2: Demo environment
    demo_args = SimpleNamespace(
        env='parkour', body='classic_bipedal', steps=50, fullscreen=True, width=600, height=400,
        roughness=None, stump_height=None, stump_width=None, obstacle_spacing=None,
        input_vector=None, water_level=None, creepers_width=None, creepers_height=None, creepers_spacing=None
    )
    _, success = run_test(demo_script.main, demo_args, "Demo Parkour Env")
    if not success: overall_success = False

    # Test 3: PPO training (short) and playback
    ppo_args = SimpleNamespace(
        run_id="test_suite_ppo", total_timesteps=128, body='classic_bipedal', env='parkour',
        save_freq=128, n_envs=1, render=False, width=None, height=None, fullscreen=True,
        roughness=None, stump_height=None, stump_width=None, obstacle_spacing=None,
        input_vector=None, water_level=None, creepers_width=None, creepers_height=None, creepers_spacing=None
    )
    model_path, success = run_test(train_ppo.main, ppo_args, "Train PPO (short)")
    if not success:
        overall_success = False
    elif model_path:
        watch_args = SimpleNamespace(
            model_path=model_path, framework='sb3', num_episodes=1, n_agents=1,
            env='parkour', body='classic_bipedal', fullscreen=True, width=200, height=150,
            roughness=None, stump_height=None, stump_width=None, obstacle_spacing=None,
            input_vector=None, water_level=None, creepers_width=None, creepers_height=None, creepers_spacing=None,
            timeout=100, auto_skip_stuck=False, fast_forward=True
        )
        _, watch_success = run_test(watch.main, watch_args, "Watch Trained PPO Model")
        if not watch_success: overall_success = False

    # Test 4: ACL training (short)
    acl_args = SimpleNamespace(
        run_id="test_suite_acl", 
        body='climbing_profile_chimpanzee', 
        env='parkour',
        total_stages=2,
        student_steps_per_stage=64,
        eval_episodes=1,
        mastery_threshold=50.0,
        difficulty_increment=0.1,
        render=False, fullscreen=True,
        width=None, height=None, roughness=None, stump_height=None, stump_width=None,
        obstacle_spacing=None, input_vector=None, water_level=None, creepers_width=None,
        creepers_height=None, creepers_spacing=None
    )
    _, success = run_test(train_acl.main, acl_args, "Train ACL (short)")
    if not success: overall_success = False

    # Test 5: MARL training (short)
    marl_args = SimpleNamespace(
        run_id="test_suite_marl", mode='interactive', n_agents=2, body='classic_bipedal',
        iterations=2, num_workers=1, check_env=False, width=None, height=None, fullscreen=True
    )
    _, success = run_test(train_marl.main, marl_args, "Train MARL (short)")
    if not success: overall_success = False

    print_header("TEST SUITE SUMMARY")
    if overall_success:
        print("üéâüéâüéâ All pipeline tests passed successfully! üéâüéâüéâ")
    else:
        print("üî•üî•üî• ERRORS DETECTED DURING TESTING. üî•üî•üî•")
        sys.exit(1)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Run the project's integrated test suite.")
    main(None)


===== .\scripts\train_acl.py =====
#!/usr/bin/env python3
"""
train_acl.py
Train an agent using Automatic Curriculum Learning (ACL)
in the custom Parkour environment.
"""
import os
import sys
import time
import argparse
import numpy as np
import gymnasium as gym
from stable_baselines3 import PPO
from stable_baselines3.common.env_util import make_vec_env

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import TeachMyAgent.environments
from utils.env_utils import build_and_setup_env, setup_render_window
from utils.shared_args import add_common_args, add_environment_args, add_render_args

PARAM_SPACE_LIMS = np.array([
    [-1.0, 1.0],  # CPPN Input 1
    [-1.0, 1.0],  # CPPN Input 2
    [-1.0, 1.0],  # CPPN Input 3
    [0.0, 0.8],   # Water level (capped to avoid excessive difficulty)
])

EASY_PARAMS = np.array([0.0, 0.0, 0.0, 0.0])


def add_acl_args(parser):
    parser = add_common_args(parser)
    parser = add_environment_args(parser)
    parser = add_render_args(parser)

    group = parser.add_argument_group("ACL Training Parameters")
    group.add_argument("--run_id", type=str, default="acl_run1", help="Run identifier.")
    group.add_argument("--total_stages", type=int, default=500, help="Total number of curriculum stages.")
    group.add_argument("--student_steps_per_stage", type=int, default=2048 * 8, help="Training steps per stage.")
    group.add_argument("--eval_episodes", type=int, default=10, help="Number of evaluation episodes.")
    group.add_argument("--mastery_threshold", type=float, default=150.0, help="Reward threshold to increase difficulty.")
    group.add_argument("--difficulty_increment", type=float, default=0.01, help="Difficulty increase step.")
    group.add_argument("--render", action="store_true", help="Enable rendering during training and evaluation.")
    return parser


def sample_task_params(difficulty_ratio):
    low_bounds = EASY_PARAMS
    high_bounds = np.array([lim[1] if p > 0 else lim[0] for p, lim in zip(EASY_PARAMS, PARAM_SPACE_LIMS)])
    current_max = low_bounds + difficulty_ratio * (high_bounds - low_bounds)
    sampled = np.random.uniform(low=low_bounds, high=current_max)
    return {"input_vector": sampled[:3], "water_level": sampled[3]}


def evaluate_student(student_model, env_id, body_type, difficulty_ratio, num_episodes, args, render_mode=None):
    total_rewards = 0.0
    eval_env = None
    MAX_STEPS_PER_EVAL_EPISODE = 1600

    try:
        initial_task = sample_task_params(difficulty_ratio)
        eval_env = build_and_setup_env(env_id, body_type, initial_task, render_mode=render_mode)

        if render_mode == "human":
            setup_render_window(eval_env, args)

        for i in range(num_episodes):
            print(f"  Evaluating Episode {i + 1}/{num_episodes}...")

            if i > 0:
                task = sample_task_params(difficulty_ratio)
                eval_env.unwrapped.set_environment(**task)

            obs, _ = eval_env.reset()
            terminated, truncated = False, False
            episode_reward = 0.0
            step_count = 0

            while not (terminated or truncated):
                if render_mode == "human":
                    eval_env.render()
                    if eval_env.unwrapped.viewer and eval_env.unwrapped.viewer.window.has_exit:
                        print("Window closed. Evaluation stopped.")
                        return -np.inf

                action, _ = student_model.predict(obs, deterministic=True)
                obs, reward, terminated, truncated, _ = eval_env.step(action)
                episode_reward += reward

                step_count += 1
                if step_count >= MAX_STEPS_PER_EVAL_EPISODE:
                    print(f"    Episode stopped after {MAX_STEPS_PER_EVAL_EPISODE} steps (timeout).")
                    truncated = True

            total_rewards += episode_reward

    finally:
        if eval_env:
            eval_env.close()

    if 'eval_env' in locals() and render_mode == "human" and (not eval_env.unwrapped.viewer or not eval_env.unwrapped.viewer.window or eval_env.unwrapped.viewer.window.has_exit):
        return -np.inf

    return total_rewards / num_episodes


def main(args):
    if args.env != "parkour":
        print(f"ERROR: ACL training currently supports only 'parkour', got '{args.env}'.")
        sys.exit(1)

    output_base = f"output/acl/{args.run_id}"
    model_dir = os.path.join(output_base, "models")
    log_dir = os.path.join(output_base, "logs")
    os.makedirs(model_dir, exist_ok=True)
    os.makedirs(log_dir, exist_ok=True)

    print(f"\n{'=' * 60}\nStarting ACL training for env '{args.env}' with body '{args.body}'")
    print(f"Output directory: {output_base}\n{'=' * 60}")

    render_mode = "human" if args.render else None

    print("--- Initializing Student (PPO) ---")
    initial_params = sample_task_params(0.0)
    initial_env = build_and_setup_env(args.env, args.body, initial_params)
    student = PPO("MlpPolicy", initial_env, verbose=0, tensorboard_log=os.path.join(log_dir, "student"))
    initial_env.close()

    difficulty_ratio = 0.0
    print(f"\n--- Starting ACL training over {args.total_stages} stages ---")

    try:
        for stage in range(1, args.total_stages + 1):
            start_time = time.time()

            task_params = sample_task_params(difficulty_ratio)
            print(f"\n--- Stage {stage}/{args.total_stages} | Difficulty: {difficulty_ratio:.3f} ---")
            print(f"Task parameters: {task_params}")

            env_fn = lambda: build_and_setup_env(args.env, args.body, task_params, render_mode=render_mode)
            vec_env = make_vec_env(env_fn, n_envs=1)

            if render_mode == "human":
                render_env = vec_env.envs[0]
                setup_render_window(render_env, args)

            student.set_env(vec_env)
            student.learn(total_timesteps=args.student_steps_per_stage, reset_num_timesteps=False, progress_bar=True)
            vec_env.close()

            print(f"Evaluating agent over {args.eval_episodes} episodes...")
            avg_reward = evaluate_student(student, args.env, args.body, difficulty_ratio, args.eval_episodes, args, render_mode=render_mode)

            print(f"Average reward = {avg_reward:.2f}")
            if avg_reward > args.mastery_threshold:
                new_diff = min(1.0, difficulty_ratio + args.difficulty_increment)
                if new_diff > difficulty_ratio:
                    difficulty_ratio = new_diff
                    print(f"üéâ Mastery achieved! Increasing difficulty to {difficulty_ratio:.3f}")
            else:
                print(f"Below threshold ({args.mastery_threshold:.2f}). Keeping difficulty unchanged.")

            if stage % 25 == 0:
                model_path = os.path.join(model_dir, f"student_{args.run_id}_stage_{stage}.zip")
                student.save(model_path)
                print(f"Model saved: {model_path}")

            print(f"Stage time: {time.time() - start_time:.2f}s")

    except KeyboardInterrupt:
        print("\nTraining interrupted by user.")

    final_path = os.path.join(model_dir, "student_final.zip")
    student.save(final_path)
    print(f"\n{'=' * 60}\nACL training complete.")
    print(f"Final Student model saved at: {final_path}")
    return final_path


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Train an agent using Automatic Curriculum Learning (ACL).")
    parser = add_acl_args(parser)
    args = parser.parse_args()
    main(args)


===== .\scripts\train_marl.py =====
# scripts/train_marl.py
import argparse
import os
import sys
import time
import ray
import torch
from collections.abc import Mapping
from ray import tune, air
from ray.rllib.algorithms.ppo import PPOConfig
from ray.rllib.policy.policy import PolicySpec
from ray.tune.registry import register_env
from gymnasium.wrappers import TransformObservation
import numpy as np
import gymnasium as gym

from ray.rllib.utils.metrics import (
    ENV_RUNNER_RESULTS,
    EPISODE_RETURN_MEAN,
    LEARNER_RESULTS,
    ALL_MODULES,
)

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import TeachMyAgent.environments
from TeachMyAgent.environments.envs.multi_agent_parametric_parkour import MultiAgentParkour
from TeachMyAgent.environments.envs.interactive_multi_agent_parkour import InteractiveMultiAgentParkour
from utils.env_utils import setup_render_window as setup_render_window_util

def add_marl_args(parser):
    """Th√™m c√°c tham s·ªë d√≤ng l·ªánh ƒë·ªÉ c√≥ th·ªÉ ch·∫°y file n√†y m·ªôt c√°ch ƒë·ªôc l·∫≠p."""
    parser.add_argument("--mode", type=str, default="interactive", choices=["cooperative", "interactive"])
    parser.add_argument("--n-agents", type=int, default=2)
    parser.add_argument("--body", type=str, default="classic_bipedal")
    parser.add_argument("--iterations", type=int, default=100)
    parser.add_argument("--num-workers", type=int, default=2)
    parser.add_argument("--num-gpus", type=float, default=0)
    parser.add_argument("--check-env", action="store_true")
    parser.add_argument("--width", type=int)
    parser.add_argument("--height", type=int)
    parser.add_argument("--fullscreen", action="store_true")
    parser.add_argument("--run_id", type=str, default="marl_run1")
    parser.add_argument("--use-tune", action="store_true")
    return parser

def deep_update(original, new_dict):
    """
    H√†m ti·ªán √≠ch ƒë·ªÉ h·ª£p nh·∫•t hai dictionary l·ªìng nhau m·ªôt c√°ch ƒë·ªá quy.
    """
    for key, value in new_dict.items():
        if key in original and isinstance(original[key], Mapping) and isinstance(value, Mapping):
            deep_update(original[key], value)
        else:
            original[key] = value
    return original

def _parse_search_space(search_space_config):
    """
    Ph√¢n t√≠ch v√† chuy·ªÉn ƒë·ªïi c·∫•u h√¨nh search space t·ª´ string sang c√°c ƒë·ªëi t∆∞·ª£ng Tune.
    """
    if not search_space_config:
        return {}
    
    TUNE_SAMPLERS = {
        "grid_search": tune.grid_search,
        "choice": tune.choice,
        "uniform": tune.uniform,
        "loguniform": tune.loguniform,
    }

    def recursive_parse(config_dict):
        parsed_dict = {}
        for key, value in config_dict.items():
            if isinstance(value, str):
                is_sampler = False
                for sampler_name, sampler_func in TUNE_SAMPLERS.items():
                    if value.startswith(f"tune.{sampler_name}"):
                        args_str = value[len(f"tune.{sampler_name}"):]
                        try:
                            args_val = eval(args_str)
                            if isinstance(args_val, tuple):
                                parsed_dict[key] = sampler_func(*args_val)
                            else:
                                parsed_dict[key] = sampler_func(args_val)
                            is_sampler = True
                            break
                        except Exception as e:
                            print(f"ERROR: Could not parse tune args '{args_str}'. Error: {e}")
                            sys.exit(1)
                if not is_sampler:
                    parsed_dict[key] = value
            elif isinstance(value, dict):
                parsed_dict[key] = recursive_parse(value)
            else:
                parsed_dict[key] = value
        return parsed_dict

    return recursive_parse(search_space_config)

def get_env_creator(mode):
    """Tr·∫£ v·ªÅ m·ªôt h√†m t·∫°o m√¥i tr∆∞·ªùng d·ª±a tr√™n ch·∫ø ƒë·ªô ƒë∆∞·ª£c ch·ªçn."""
    if mode == "cooperative":
        base_env_creator_func = lambda config: MultiAgentParkour(config=config)
    elif mode == "interactive":
        base_env_creator_func = lambda config: InteractiveMultiAgentParkour(config=config)
    else:
        raise ValueError(f"Ch·∫ø ƒë·ªô kh√¥ng h·ª£p l·ªá: '{mode}'. Ch·ªâ h·ªó tr·ª£ 'cooperative' ho·∫∑c 'interactive'.")

    def wrapped_env_creator(config):
        base_env = base_env_creator_func(config)
        def clip_multi_agent_obs(obs_dict):
            return {
                agent_id: np.clip(agent_obs, -10.0, 10.0)
                for agent_id, agent_obs in obs_dict.items()
            }
        original_obs_space = base_env.observation_space
        clipped_sub_spaces = {}
        if isinstance(original_obs_space, gym.spaces.Dict):
             for agent_id, sub_space in original_obs_space.items():
                clipped_sub_spaces[agent_id] = gym.spaces.Box(
                    low=-10.0, high=10.0, shape=sub_space.shape, dtype=sub_space.dtype
                )
        clipped_observation_space = gym.spaces.Dict(clipped_sub_spaces)
        clipped_env = TransformObservation(base_env, clip_multi_agent_obs, clipped_observation_space)
        return clipped_env
    return wrapped_env_creator

def check_environment_mode(args):
    """Ch·∫°y m·ªôt phi√™n t∆∞∆°ng t√°c ng·∫´u nhi√™n ƒë·ªÉ ki·ªÉm tra m√¥i tr∆∞·ªùng."""
    # (Implementation is unchanged)
    pass

def main(args):
    """H√†m ch√≠nh ƒë·ªÉ hu·∫•n luy·ªán, nh·∫≠n to√†n b·ªô c·∫•u h√¨nh t·ª´ ƒë·ªëi t∆∞·ª£ng args."""
    if hasattr(args, 'check_env') and args.check_env:
        check_environment_mode(args)
        return

    env_name = f"marl-{args.mode}-v0"
    register_env(env_name, get_env_creator(args.mode))

    env_config = {"n_agents": args.n_agents, "agent_body_type": args.body, "horizon": 1500}
    
    with get_env_creator(args.mode)(env_config) as temp_env:
        obs_space = temp_env.observation_space["agent_0"]
        act_space = temp_env.action_space["agent_0"]

    # --- X√¢y d·ª±ng PPOConfig t·ª´ `args` ---
    ppo_config_dict = getattr(args, 'ppo_config', {})
    training_config = ppo_config_dict.get('training', {})
    model_config = ppo_config_dict.get('model', {})
    env_runners_config = ppo_config_dict.get('env_runners', {})

    config = (
        PPOConfig()
        .environment(env=env_name, env_config=env_config, normalize_actions=True)
        .env_runners(num_env_runners=args.num_workers, **env_runners_config)
        .framework("torch")
        .training(**training_config)
        .rl_module(model_config=model_config)
        .multi_agent(
            policies={f"agent_{i}": PolicySpec(observation_space=obs_space, action_space=act_space) for i in range(args.n_agents)},
            policy_mapping_fn=lambda agent_id, *a, **kw: agent_id,
        )
        .resources(num_gpus=args.num_gpus)
    )

    use_tune = getattr(args, 'use_tune', False)
    if use_tune:
        print("üöÄ B·∫Øt ƒë·∫ßu hu·∫•n luy·ªán MARL v·ªõi Ray Tune...")
        
        tune_config = getattr(args, 'tune_config', {})
        search_space_config = tune_config.get('search_space', {})
        run_config_dict = tune_config.get('run_config', {})

        if 'stop' not in run_config_dict:
            raise ValueError("Khi 'use_tune: true', b·∫°n ph·∫£i ƒë·ªãnh nghƒ©a 'stop' criteria b√™n trong 'tune_config.run_config' trong file YAML.")
        stop_criteria = run_config_dict['stop']
        
        search_space = _parse_search_space(search_space_config)
        
        param_space = config.to_dict()
        deep_update(param_space, search_space)
        
        checkpoint_config_dict = run_config_dict.get('checkpoint_config', {})
        checkpoint_config_dict.setdefault('num_to_keep', 1)
        checkpoint_config_dict.setdefault('checkpoint_score_attribute', f"{ENV_RUNNER_RESULTS}/{EPISODE_RETURN_MEAN}")
        checkpoint_config_dict.setdefault('checkpoint_score_order', 'max')
        checkpoint_config = air.CheckpointConfig(**checkpoint_config_dict)

        storage_path = run_config_dict.get('storage_path')
        if storage_path:
            storage_path = os.path.expanduser(storage_path)

        run_config = air.RunConfig(
            name=run_config_dict.get('name', args.run_id),
            stop=stop_criteria,
            verbose=run_config_dict.get('verbose', 2),
            checkpoint_config=checkpoint_config,
            storage_path=storage_path,
        )

        # ================================================================ #
        # START FIX: T·∫°o t√™n th∆∞ m·ª•c ng·∫Øn h∆°n cho trial tr√™n Windows        #
        # ================================================================ #
        def short_trial_name_creator(trial):
            # D√πng ID c·ªßa trial, n√≥ v·ªën ƒë√£ ng·∫Øn v√† duy nh·∫•t
            return trial.trial_id

        tuner = tune.Tuner(
            "PPO", 
            param_space=param_space, 
            run_config=run_config,
            tune_config=tune.TuneConfig(
                trial_dirname_creator=short_trial_name_creator
            )
        )
        # ================================================================ #
        # END FIX                                                          #
        # ================================================================ #

        results = tuner.fit()

        best_result = results.get_best_result(metric=f"{ENV_RUNNER_RESULTS}/{EPISODE_RETURN_MEAN}", mode="max")
        best_checkpoint_path = best_result.checkpoint.path if best_result and best_result.checkpoint else None
        
        print("\n" + "="*60)
        print("üéâ Ray Tune ƒë√£ ho√†n t·∫•t! üéâ")
        if best_result:
            print(f"Ph·∫ßn th∆∞·ªüng cu·ªëi c√πng c·ªßa trial t·ªët nh·∫•t: {best_result.metrics.get(ENV_RUNNER_RESULTS, {}).get(EPISODE_RETURN_MEAN, 'N/A')}")
            print(f"C·∫•u h√¨nh c·ªßa trial t·ªët nh·∫•t: {best_result.config}")
            print(f"Checkpoint t·ªët nh·∫•t ƒë∆∞·ª£c l∆∞u t·∫°i: {best_checkpoint_path}")
        else:
            print("Kh√¥ng c√≥ trial n√†o ho√†n th√†nh th√†nh c√¥ng.")
        print("="*60)
        return best_checkpoint_path

    else:
        print(f"üöÄ B·∫Øt ƒë·∫ßu m·ªôt l·∫ßn hu·∫•n luy·ªán MARL duy nh·∫•t trong {args.iterations} v√≤ng l·∫∑p...")
        algo = config.build()
        for i in range(args.iterations):
            result = algo.train()
            env_runner_results = result.get(ENV_RUNNER_RESULTS, {})
            learner_results = result.get(LEARNER_RESULTS, {})
            episode_reward_mean = env_runner_results.get(EPISODE_RETURN_MEAN, float("nan"))
            per_policy_rewards = env_runner_results.get("module_episode_returns_mean", {})
            total_loss_per_module = {
                module_id: stats.get("total_loss", float("nan"))
                for module_id, stats in learner_results.items()
                if module_id != ALL_MODULES
            }
            print(
                f"V√≤ng l·∫∑p {i + 1}/{args.iterations}: "
                f"Ph·∫ßn th∆∞·ªüng trung b√¨nh Episode: {episode_reward_mean:.2f}, "
                f"Ph·∫ßn th∆∞·ªüng m·ªói Policy: {per_policy_rewards}, "
                f"T·ªïng Loss m·ªói Module: {total_loss_per_module}"
            )
        checkpoint_dir = algo.save().checkpoint.path
        print(f"\n‚úÖ Checkpoint ƒë√£ ƒë∆∞·ª£c l∆∞u t·∫°i: {checkpoint_dir}")
        return checkpoint_dir

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Train MARL agents with PPO and optional Ray Tune.")
    add_marl_args(parser)
    args = parser.parse_args()
    
    if not ray.is_initialized():
        ray.init(ignore_reinit_error=True)
    try:
        main(args)
    finally:
        if ray.is_initialized():
            ray.shutdown()

===== .\scripts\train_ppo.py =====
# scripts/train_ppo.py
import os
import sys
import argparse
import time

# Add root folder to import path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from stable_baselines3 import PPO
from stable_baselines3.common.callbacks import CheckpointCallback
from stable_baselines3.common.env_util import make_vec_env

import TeachMyAgent.environments
from utils.env_utils import build_and_setup_env, collect_env_params, setup_render_window
from utils.shared_args import add_common_args, add_environment_args, add_render_args


def add_ppo_args(parser):
    parser = add_common_args(parser)
    parser = add_environment_args(parser)
    parser = add_render_args(parser)
    train_group = parser.add_argument_group('PPO Training Parameters')
    train_group.add_argument('--total_timesteps', type=int, default=1_000_000)
    train_group.add_argument('--run_id', type=str, default='ppo_run1')
    train_group.add_argument('--save_freq', type=int, default=50_000)
    train_group.add_argument('--n_envs', type=int, default=4)
    train_group.add_argument('--render', action='store_true')
    return parser


def main(args):
    output_base_dir = f"output/ppo/{args.run_id}"
    model_dir = os.path.join(output_base_dir, "models")
    os.makedirs(model_dir, exist_ok=True)

    print("=" * 50 + f"\nTraining PPO: {args.env} with body {args.body}\nSaving to: {output_base_dir}\n" + "=" * 50)

    train_render_mode = "human" if args.render else None
    if args.render:
        args.n_envs = 1

    user_params = collect_env_params(args.env, args)
    env_lambda = lambda: build_and_setup_env(args.env, args.body, user_params, render_mode=train_render_mode)
    env = make_vec_env(env_lambda, n_envs=args.n_envs)

    if args.render:
        setup_render_window(env.envs[0], args)

    model = PPO("MlpPolicy", env, verbose=1, tensorboard_log=os.path.join(output_base_dir, "logs"))
    checkpoint_callback = CheckpointCallback(
        save_freq=max(args.save_freq // args.n_envs, 1),
        save_path=model_dir,
        name_prefix="ppo_model"
    )

    try:
        model.learn(total_timesteps=args.total_timesteps, callback=checkpoint_callback, progress_bar=True)
    except KeyboardInterrupt:
        print("\nTraining interrupted by user.")

    final_model_path = os.path.join(model_dir, "ppo_model_final.zip")
    model.save(final_model_path)
    print(f"Final model saved to: {final_model_path}")

    env.close()
    return final_model_path


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Train PPO (Stable Baselines 3).")
    parser = add_ppo_args(parser)
    args = parser.parse_args()
    main(args)


===== .\scripts\watch.py =====
# scripts/watch.py
import argparse
import time
import os
import sys
import numpy as np

# Add root folder to import path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from utils.env_utils import build_and_setup_env, collect_env_params, setup_render_window
from utils.shared_args import add_common_args, add_environment_args, add_render_args
from stable_baselines3 import PPO


class UserInterrupt(Exception):
    """Raised when the user manually stops playback."""
    pass


def add_watch_args(parser):
    """Add CLI arguments for model playback."""
    parser.add_argument('--model_path', type=str, required=True, help="Path to trained model (.zip).")

    parser = add_common_args(parser)
    parser = add_environment_args(parser)
    parser = add_render_args(parser)

    watch_group = parser.add_argument_group('Playback Parameters')
    watch_group.add_argument('--num_episodes', type=int, default=10, help="Number of episodes to watch.")
    watch_group.add_argument('--timeout', type=int, default=2000, help="Max steps per episode (safety timeout).")
    watch_group.add_argument('--auto-skip-stuck', action='store_true', help="Automatically skip if agent gets stuck.")
    watch_group.add_argument('--fast-forward', '-ff', action='store_true', help="Skip frame delays for fast playback.")
    watch_group.add_argument('--framework', type=str, default='sb3', choices=['sb3', 'rllib'], help="Model framework.")
    watch_group.add_argument('--n_agents', type=int, default=1, help="Number of agents (for future MARL support).")
    return parser


def main(args):
    """Load and replay a trained agent."""
    print(f"--- Model Playback ---\nModel: {args.model_path}\nEnv: {args.env}\nBody: {args.body}\n--------------------")

    if not os.path.exists(args.model_path):
        print(f"ERROR: Model not found at '{args.model_path}'")
        sys.exit(1)

    STUCK_CHECK_STEPS = 150
    STUCK_PROGRESS_THRESHOLD = 0.1

    env = None
    try:
        user_params = collect_env_params(args.env, args)
        env = build_and_setup_env(args.env, args.body, user_params, render_mode="human")
        setup_render_window(env, args)

        print("Loading model...")
        model = PPO.load(args.model_path)
        print("Model loaded successfully.")

        for i in range(args.num_episodes):
            obs, info = env.reset()
            done = False
            total_reward = 0
            ep_len = 0
            print(f"\n--- Starting Episode {i + 1}/{args.num_episodes} ---")

            last_check_pos_x = env.unwrapped.agent_body.reference_head_object.position.x
            last_check_step = 0

            while not done:
                env.render()
                viewer = env.unwrapped.viewer
                if viewer is None or viewer.window is None or viewer.window.has_exit:
                    print("Render window closed. Stopping playback.")
                    raise UserInterrupt

                action, _ = model.predict(obs, deterministic=True)
                obs, reward, terminated, truncated, info = env.step(action)
                done = terminated or truncated

                total_reward += reward
                ep_len += 1

                if args.auto_skip_stuck and (ep_len - last_check_step > STUCK_CHECK_STEPS):
                    current_pos_x = env.unwrapped.agent_body.reference_head_object.position.x
                    progress = current_pos_x - last_check_pos_x
                    if progress < STUCK_PROGRESS_THRESHOLD:
                        print(f"  -> Agent stuck (moved {progress:.2f} in {STUCK_CHECK_STEPS} steps), skipping episode.")
                        done = True
                    last_check_pos_x = current_pos_x
                    last_check_step = ep_len

                if not done and ep_len >= args.timeout:
                    print(f"  -> Episode stopped after exceeding {args.timeout} steps (timeout).")
                    done = True

                if not args.fast_forward:
                    time.sleep(1.0 / 60.0)

            print(f"Episode {i + 1} finished. Reward: {total_reward:.2f}, Length: {ep_len}")

    except KeyboardInterrupt:
        print("\nStopped by user (Ctrl+C).")
        raise UserInterrupt
    finally:
        if env:
            env.close()
            print("Environment closed.")


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Replay a trained agent.",
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser = add_watch_args(parser)
    args = parser.parse_args()

    try:
        main(args)
    except UserInterrupt:
        print("Playback stopped by user.")
        sys.exit(0)


===== .\scripts\__init__.py =====


===== .\TeachMyAgent\__init__.py =====


===== .\TeachMyAgent\environments\__init__.py =====
from gymnasium.envs.registration import register

register(
    id='parametric-continuous-stump-tracks-v0',
    entry_point='TeachMyAgent.environments.envs.parametric_continuous_stump_tracks:ParametricContinuousStumpTracks'
)

register(
    id='parametric-continuous-parkour-v0',
    entry_point='TeachMyAgent.environments.envs.parametric_continuous_parkour:ParametricContinuousParkour'
)
register(
    id='multi-agent-parkour-v0',
    entry_point='TeachMyAgent.environments.envs.multi_agent_parametric_parkour:MultiAgentParkour'
)

===== .\TeachMyAgent\environments\envs\interactive_multi_agent_parkour.py =====
# TeachMyAgent/environments/envs/interactive_multi_agent_parkour.py
import math
import numpy as np
import gymnasium as gym
import Box2D
from Box2D.b2 import circleShape
from ray.rllib.env.multi_agent_env import MultiAgentEnv

from .parametric_continuous_parkour import (
    ParametricContinuousParkour, LidarCallback,
    SCALE, FPS, VIEWPORT_W, VIEWPORT_H, NB_LIDAR, LIDAR_RANGE,
    TERRAIN_STEP, TERRAIN_LENGTH, TERRAIN_END, INITIAL_RANDOM,
    TERRAIN_HEIGHT, WATER_DENSITY
)
from .utils.custom_user_data import CustomUserDataObjectTypes, CustomBodyUserData
from TeachMyAgent.environments.envs.bodies.BodiesEnum import BodiesEnum
from TeachMyAgent.environments.envs.bodies.BodyTypesEnum import BodyTypesEnum

class InteractiveMultiAgentParkour(ParametricContinuousParkour, MultiAgentEnv):
    """
    M√¥i tr∆∞·ªùng Parkour ƒëa t√°c nh√¢n t∆∞∆°ng t√°c.
    """
    def __init__(self, config: dict):
        # 1. Chu·∫©n b·ªã c√°c tham s·ªë
        self.n_agents = config.get("n_agents", 2)
        self.agent_body_type = config.get("agent_body_type", "classic_bipedal")
        self.horizon = config.get("horizon", 1500)
        self.ts = 0

        parent_config = config.copy()
        parent_config.pop("n_agents", None)
        
        # 2. T·∫°o m·ªôt m√¥i tr∆∞·ªùng t·∫°m th·ªùi ch·ªâ ƒë·ªÉ l·∫•y kh√¥ng gian obs/act ch√≠nh x√°c
        temp_env_config = parent_config.copy()
        temp_env_config.pop("render_mode", None) # Kh√¥ng c·∫ßn render cho env t·∫°m
        temp_env = ParametricContinuousParkour(**temp_env_config)
        single_action_space = temp_env.action_space
        single_observation_space_original = temp_env.observation_space
        temp_env.close() # H·ªßy m√¥i tr∆∞·ªùng t·∫°m sau khi l·∫•y xong th√¥ng tin

        # 3. Kh·ªüi t·∫°o l·ªõp cha ParametricContinuousParkour cho 'self'
        ParametricContinuousParkour.__init__(self, **parent_config)
        
        # 4. Kh·ªüi t·∫°o l·ªõp cha MultiAgentEnv
        MultiAgentEnv.__init__(self)

        # 5. Thi·∫øt l·∫≠p c√°c thu·ªôc t√≠nh cho multi-agent v√† ghi ƒë√® spaces
        self.agent_bodies = {}
        self.prev_shapings = {}
        self.possible_agents = [f"agent_{i}" for i in range(self.n_agents)]
        self._agent_ids = set(self.possible_agents)
        self.agents = []

        # Ghi ƒë√® action_space th√†nh Dict
        self.action_space = gym.spaces.Dict({i: single_action_space for i in self.possible_agents})

        # Ghi ƒë√® observation_space th√†nh Dict v·ªõi k√≠ch th∆∞·ªõc ƒë√£ m·ªü r·ªông
        original_obs_size = single_observation_space_original.shape[0]
        other_agents_obs_size = (self.n_agents - 1) * 2 
        single_obs_shape = (original_obs_size + other_agents_obs_size,)
        high = np.array([np.inf] * single_obs_shape[0], dtype=np.float32)
        single_observation_space = gym.spaces.Box(-high, high, dtype=np.float32)
        self.observation_space = gym.spaces.Dict({i: single_observation_space for i in self.possible_agents})
        
        self._obs_space_in_preferred_format = True
        self._action_space_in_preferred_format = True

    # ... (C√°c h√†m c√≤n l·∫°i gi·ªØ nguy√™n nh∆∞ phi√™n b·∫£n ƒë√∫ng g·∫ßn nh·∫•t) ...
    # (T√¥i s·∫Ω d√°n l·∫°i to√†n b·ªô ƒë·ªÉ ch·∫Øc ch·∫Øn)

    def _destroy(self):
        if not self.world: return
        self.world.contactListener = None
        if self.terrain:
            for t in self.terrain:
                if t: self.world.DestroyBody(t)
        self.terrain = []
        self._destroy_agents()

    def _generate_agent(self):
        pass

    def _destroy_agents(self):
        if not self.agent_bodies: return
        for agent_id, body in self.agent_bodies.items():
            if body: body.destroy(self.world)
        self.agent_bodies = {}

    def _generate_agents(self):
        self._destroy_agents()
        self.agent_bodies = {}
        body_params = {'scale': SCALE}
        body_type = BodiesEnum.get_body_type(self.agent_body_type)
        if body_type in [BodyTypesEnum.SWIMMER, BodyTypesEnum.AMPHIBIAN]:
            body_params['density'] = WATER_DENSITY
        for i in range(self.n_agents):
            agent_id = f"agent_{i}"
            body = BodiesEnum[self.agent_body_type].value(**body_params)
            self.agent_bodies[agent_id] = body
            init_x = (TERRAIN_STEP * self.TERRAIN_STARTPAD / 2) + i * 2.5
            init_y = self.terrain_ground_y[int(self.TERRAIN_STARTPAD / 2)] + body.AGENT_CENTER_HEIGHT
            body.draw(self.world, init_x, init_y, self.np_random.uniform(-INITIAL_RANDOM, INITIAL_RANDOM))

    def reset(self, *, seed=None, options=None):
        super(ParametricContinuousParkour, self).reset(seed=seed)
        self._destroy()
        
        self.ts = 0
        self.world = Box2D.b2World(contactListener=self.contact_listener)
        self.world.contactListener = self.contact_listener
        if self.contact_listener: self.contact_listener.Reset()
        self.critical_contact = False
        self.prev_shapings = {agent_id: None for agent_id in self.possible_agents}
        self.scroll = [0.0, 0.0]
        self.water_y = self.GROUND_LIMIT
        self.lidar = [LidarCallback(None) for _ in range(NB_LIDAR)] 

        self._generate_terrain()
        self._generate_agents()
        
        self.agents = list(self.possible_agents)
        self.drawlist = self.terrain.copy()
        for body in self.agent_bodies.values(): self.drawlist += body.get_elements_to_render()
        self.terminateds = {agent_id: False for agent_id in self.possible_agents}
        self.truncateds = {agent_id: False for agent_id in self.possible_agents}
        self.terminateds["__all__"] = False
        self.truncateds["__all__"] = False
        
        return self._get_obs(), {}

    def step(self, action_dict):
        self.ts += 1
        for agent_id, action in action_dict.items():
            if agent_id in self.agents and action is not None and len(action) > 0:
                self.agent_bodies[agent_id].activate_motors(action)

        self.world.Step(1.0 / FPS, 6 * 30, 2 * 30)

        rewards = {}
        positions = {aid: self.agent_bodies[aid].reference_head_object.position for aid in self.agents if aid in self.agent_bodies}
        if positions:
            leading_agent_pos_x = max(p[0] for p in positions.values())
            avg_agent_pos_y = sum(p[1] for p in positions.values()) / len(positions)
            self.scroll = [
                leading_agent_pos_x - self.rendering_viewer_w / SCALE / 5,
                avg_agent_pos_y - self.rendering_viewer_h / SCALE / 2.5
            ]
            
        active_agents_before_step = list(self.agents)
        for agent_id in active_agents_before_step:
            body = self.agent_bodies[agent_id]
            pos = body.reference_head_object.position
            
            shaping = 130 * pos[0] / SCALE
            reward = 0
            if self.prev_shapings.get(agent_id) is not None:
                reward = shaping - self.prev_shapings[agent_id]
            self.prev_shapings[agent_id] = shaping

            reward += 0.01

            if agent_id in action_dict and action_dict[agent_id] is not None:
                for a in action_dict[agent_id]:
                    reward -= body.TORQUE_PENALTY * 20 * np.clip(np.abs(a), 0, 1)

            agent_critical_contact = False
            for part in body.body_parts:
                 if isinstance(part.userData, CustomBodyUserData) and part.userData.is_contact_critical and part.userData.has_contact:
                     agent_critical_contact = True
                     break

            if agent_critical_contact or pos[0] < 0:
                reward = -100
                self.terminateds[agent_id] = True
            if pos[0] > (TERRAIN_LENGTH + self.TERRAIN_STARTPAD - TERRAIN_END) * TERRAIN_STEP:
                self.terminateds[agent_id] = True

            rewards[agent_id] = reward
            if self.terminateds.get(agent_id, False):
                if agent_id in self.agents:
                    self.agents.remove(agent_id)
        
        is_truncated = self.ts >= self.horizon
        all_done = not self.agents or is_truncated

        self.terminateds["__all__"] = all_done and not is_truncated
        self.truncateds["__all__"] = is_truncated

        obs = self._get_obs()
        return obs, rewards, self.terminateds, self.truncateds, {}

    def _get_obs(self):
        all_obs = {}
        agent_positions = {aid: body.reference_head_object.position for aid, body in self.agent_bodies.items()}

        for agent_id in self.agents:
            body = self.agent_bodies[agent_id]
            head = body.reference_head_object
            vel = head.linearVelocity
            for lidar_callback in self.lidar:
                lidar_callback.agent_mask_filter = head.fixtures[0].filterData.maskBits
            for i in range(NB_LIDAR):
                self.lidar[i].fraction = 1.0
                self.lidar[i].p1 = head.position
                self.lidar[i].p2 = (
                    head.position[0] + math.sin((self.lidar_angle * i / NB_LIDAR) + self.lidar_y_offset) * LIDAR_RANGE,
                    head.position[1] - math.cos((self.lidar_angle * i / NB_LIDAR) + self.lidar_y_offset) * LIDAR_RANGE
                )
                self.world.RayCast(self.lidar[i], self.lidar[i].p1, self.lidar[i].p2)
            is_under_water = head.position.y <= self.water_y
            state = [
                head.angle, 2.0 * head.angularVelocity / FPS,
                0.3 * vel.x * (VIEWPORT_W / SCALE) / FPS,
                0.3 * vel.y * (VIEWPORT_H / SCALE) / FPS,
                1.0 if is_under_water else 0.0, 0.0 
            ]
            state.extend(body.get_motors_state())
            if body.body_type == BodyTypesEnum.CLIMBER: state.extend(body.get_sensors_state())
            for lidar in self.lidar: state.append(lidar.fraction)
            for lidar in self.lidar:
                if lidar.is_water_detected: state.append(-1)
                elif lidar.is_creeper_detected: state.append(1)
                else: state.append(0)
            original_obs = np.array(state)
            other_agents_pos = []
            my_pos = agent_positions[agent_id]
            for other_id in self.possible_agents:
                if other_id != agent_id:
                    if other_id in self.agents and other_id in agent_positions:
                        other_pos = agent_positions[other_id]
                        relative_pos = (np.array(other_pos) - np.array(my_pos)) / (LIDAR_RANGE * 2)
                        other_agents_pos.extend(relative_pos.tolist())
                    else:
                        other_agents_pos.extend([0.0, 0.0])
            final_obs = np.concatenate([original_obs, np.array(other_agents_pos)])
            all_obs[agent_id] = final_obs.astype(np.float32)
        return all_obs

    def render(self, mode='human', draw_lidars=True):
        from TeachMyAgent.environments.envs.utils import rendering
        if self.viewer is None:
            self.viewer = rendering.Viewer(self.rendering_viewer_w, self.rendering_viewer_h)
        
        self.viewer.set_bounds(self.scroll[0], self.rendering_viewer_w/SCALE + self.scroll[0],
                               self.scroll[1], self.rendering_viewer_h/SCALE + self.scroll[1])

        self.viewer.draw_polygon( [
            (self.scroll[0], self.scroll[1]),
            (self.scroll[0]+self.rendering_viewer_w/SCALE, self.scroll[1]),
            (self.scroll[0]+self.rendering_viewer_w/SCALE, self.scroll[1]+self.rendering_viewer_h/SCALE),
            (self.scroll[0], self.scroll[1]+self.rendering_viewer_h/SCALE),
            ], color=(0.9, 0.9, 1.0) )

        for poly,x1,x2 in self.cloud_poly:
            if x2 < self.scroll[0]/2: continue
            if x1 > self.scroll[0]/2 + self.rendering_viewer_w/SCALE: continue
            self.viewer.draw_polygon( [(p[0]+self.scroll[0]/2, p[1]) for p in poly], color=(1,1,1))

        for obj in self.drawlist:
            color1 = obj.color1
            color2 = obj.color2
            if hasattr(obj.userData, 'object_type') and obj.userData.object_type == CustomUserDataObjectTypes.BODY_SENSOR and obj.userData.has_joint:
                color1 = (1.0, 1.0, 0.0)
                color2 = (1.0, 1.0, 0.0)
            
            for f in obj.fixtures:
                trans = f.body.transform
                if type(f.shape) is circleShape:
                    t = rendering.Transform(translation=trans*f.shape.pos)
                    self.viewer.draw_circle(f.shape.radius, 30, color=color1).add_attr(t)
                    self.viewer.draw_circle(f.shape.radius, 30, color=color2, filled=False, linewidth=2).add_attr(t)
                else:
                    path = [trans*v for v in f.shape.vertices]
                    self.viewer.draw_polygon(path, color=color1)
                    path.append(path[0])
                    self.viewer.draw_polyline(path, color=obj.color2, linewidth=2)

        for poly, color in self.terrain_poly:
            if len(poly) < 2 or poly[1][0] < self.scroll[0]: continue
            if poly[0][0] > self.scroll[0] + self.rendering_viewer_w / SCALE: continue
            self.viewer.draw_polygon(poly, color=color)

        if draw_lidars and hasattr(self, 'lidar'):
            for i in range(len(self.lidar)):
                l = self.lidar[i]
                self.viewer.draw_polyline([l.p1, l.p2], color=(1, 0, 0), linewidth=1)

        flagy1 = TERRAIN_HEIGHT
        flagy2 = flagy1 + 50/SCALE
        x = TERRAIN_STEP*3
        self.viewer.draw_polyline( [(x, flagy1), (x, flagy2)], color=(0,0,0), linewidth=2 )
        f = [(x, flagy2), (x, flagy2-10/SCALE), (x+25/SCALE, flagy2-5/SCALE)]
        self.viewer.draw_polygon(f, color=(0.9,0.2,0) )
        self.viewer.draw_polyline(f + [f[0]], color=(0,0,0), linewidth=2 )

        return self.viewer.render(return_rgb_array = mode=='rgb_array')

===== .\TeachMyAgent\environments\envs\LidarCallback_class.py =====
# TeachMyAgent/environments/envs/LidarCallback_class.py
import Box2D
from .utils.custom_user_data import CustomUserDataObjectTypes

class LidarCallback(Box2D.b2.rayCastCallback):
    '''
        Callback function triggered when lidar detects an object.
    '''
    def __init__(self, agent_mask_filter):
        Box2D.b2.rayCastCallback.__init__(self)
        self.agent_mask_filter = agent_mask_filter
        self.fixture = None
        self.is_water_detected = False
        self.is_creeper_detected = False
    def ReportFixture(self, fixture, point, normal, fraction):
        if (fixture.filterData.categoryBits & self.agent_mask_filter) == 0:
            return -1
        self.p2 = point
        self.fraction = fraction
        self.is_water_detected = True if fixture.body.userData.object_type == CustomUserDataObjectTypes.WATER else False
        self.is_creeper_detected = True if fixture.body.userData.object_type == CustomUserDataObjectTypes.SENSOR_GRIP_TERRAIN else False
        return fraction

===== .\TeachMyAgent\environments\envs\multi_agent_parametric_parkour.py =====
import numpy as np
import gymnasium as gym
from gymnasium import spaces
from ray.rllib.env.multi_agent_env import MultiAgentEnv

from .parametric_continuous_parkour import ParametricContinuousParkour
from .bodies.BodiesEnum import BodiesEnum
from .bodies.BodyTypesEnum import BodyTypesEnum
from .parametric_continuous_parkour import WATER_DENSITY

class MultiAgentParkour(MultiAgentEnv):
    _single_observation_space: gym.Space
    _single_action_space: gym.Space

    def __init__(self, config: dict):
        super().__init__()
        self.n_agents = config.get("n_agents", 2)
        self.render_mode = config.get("render_mode", None)

        sub_env_config = config.copy()
        sub_env_config.pop("n_agents", None)
        sub_env_config.pop("render_mode", None)

        body_type = BodiesEnum.get_body_type(sub_env_config.get("agent_body_type", "classic_bipedal"))
        if body_type in [BodyTypesEnum.SWIMMER, BodyTypesEnum.AMPHIBIAN]:
            sub_env_config['density'] = WATER_DENSITY

        tmp_env = ParametricContinuousParkour(**sub_env_config)
        self._single_observation_space = tmp_env.observation_space
        self._single_action_space = tmp_env.action_space
        tmp_env.close()

        self._agent_ids = {f"agent_{i}" for i in range(self.n_agents)}
        self.possible_agents = list(self._agent_ids)
        
        self.observation_space = gym.spaces.Dict({i: self._single_observation_space for i in self.possible_agents})
        self.action_space = gym.spaces.Dict({i: self._single_action_space for i in self.possible_agents})
        self.envs = [ParametricContinuousParkour(**sub_env_config) for _ in range(self.n_agents)]

        self._terminateds = set()
        self._truncateds = set()

        if self.render_mode == "human":
            self.envs[0].render_mode = "human"
            for i in range(1, self.n_agents):
                self.envs[i].render_mode = None

    def reset(self, *, seed=None, options=None):
        self._terminateds.clear()
        self._truncateds.clear()
        obs, infos = {}, {}
        for i, agent_id in enumerate(self.possible_agents):
            agent_seed = seed + i if seed is not None else None
            obs[agent_id], infos[agent_id] = self.envs[i].reset(seed=agent_seed, options=options)
        return obs, infos

    def step(self, action_dict):
        obs, rewards, terminateds, truncateds, infos = {}, {}, {}, {}, {}
        for agent_id, action in action_dict.items():
            idx = int(agent_id.split("_")[1])
            o, r, term, trunc, info = self.envs[idx].step(action)
            obs[agent_id] = o
            rewards[agent_id] = r
            terminateds[agent_id] = term
            truncateds[agent_id] = trunc
            infos[agent_id] = info
            if term: self._terminateds.add(agent_id)
            if trunc: self._truncateds.add(agent_id)

        all_done = len(self._terminateds) + len(self._truncateds) == self.n_agents
        terminateds["__all__"] = all_done
        truncateds["__all__"] = all_done
        return obs, rewards, terminateds, truncateds, infos

    def render(self):
        if self.render_mode == "human":
            return self.envs[0].render()

    def close(self):
        for env in self.envs:
            env.close()


===== .\TeachMyAgent\environments\envs\parametric_continuous_parkour.py =====
import math
import os

import Box2D
import gymnasium as gym
import numpy as np
from Box2D.b2 import (edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef)
from gymnasium import spaces
from gymnasium.utils import seeding, EzPickle

from TeachMyAgent.environments.envs.Box2D_dynamics.water_dynamics import WaterDynamics, WaterContactDetector
from TeachMyAgent.environments.envs.Box2D_dynamics.climbing_dynamics import ClimbingDynamics, ClimbingContactDetector
from TeachMyAgent.environments.envs.PCGAgents.CPPN.cppn_pytorch import CPPN_Pytorch
from TeachMyAgent.environments.envs.bodies.BodiesEnum import BodiesEnum
from TeachMyAgent.environments.envs.bodies.BodyTypesEnum import BodyTypesEnum
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomUserDataObjectTypes, CustomUserData

class ContactDetector(WaterContactDetector, ClimbingContactDetector):
    def __init__(self, env):
        super(ContactDetector, self).__init__()
        self.env = env
        
    def BeginContact(self, contact):
        bodies = [contact.fixtureA.body, contact.fixtureB.body]
        
        if any([hasattr(body.userData, 'object_type') and body.userData.object_type == CustomUserDataObjectTypes.WATER for body in bodies]):
            WaterContactDetector.BeginContact(self, contact)
        elif any([hasattr(body.userData, 'object_type') and body.userData.object_type == CustomUserDataObjectTypes.BODY_SENSOR for body in bodies]):
            ClimbingContactDetector.BeginContact(self, contact)
        else:
            if contact.fixtureA.sensor or contact.fixtureB.sensor:
                return
            for idx, body in enumerate(bodies):
                if hasattr(body.userData, 'object_type') and body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT and body.userData.check_contact:
                    body.userData.has_contact = True
                    other_body = bodies[(idx + 1) % 2]
                    if body.userData.is_contact_critical and \
                            not (hasattr(other_body.userData, 'object_type') and
                                 other_body.userData.object_type == CustomUserDataObjectTypes.GRIP_TERRAIN and
                                 self.env.agent_body.body_type == BodyTypesEnum.CLIMBER):
                        self.env.critical_contact = True

    def EndContact(self, contact):
        fA, fB = contact.fixtureA, contact.fixtureB
        if (not hasattr(fA, 'body') or not hasattr(fB, 'body') or
                fA.body is None or fB.body is None or
                not hasattr(fA.body, 'userData') or not hasattr(fB.body, 'userData') or
                fA.body.userData is None or fB.body.userData is None):
            return

        bodies = [fA.body, fB.body]

        if any([body.userData.object_type == CustomUserDataObjectTypes.WATER for body in bodies]):
            WaterContactDetector.EndContact(self, contact)
        elif any([body.userData.object_type == CustomUserDataObjectTypes.BODY_SENSOR for body in bodies]):
            ClimbingContactDetector.EndContact(self, contact)
        else:
            for body in bodies:
                if (body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT and
                        body.userData.check_contact):
                    body.userData.has_contact = False

    def Reset(self):
        WaterContactDetector.Reset(self)
        ClimbingContactDetector.Reset(self)

class LidarCallback(Box2D.b2.rayCastCallback):
    def __init__(self, agent_mask_filter):
        Box2D.b2.rayCastCallback.__init__(self)
        self.agent_mask_filter = agent_mask_filter
        self.fixture = None
        self.is_water_detected = False
        self.is_creeper_detected = False
        
    def ReportFixture(self, fixture, point, normal, fraction):
        if (fixture.filterData.categoryBits & self.agent_mask_filter) == 0:
            return -1
        self.p2 = point
        self.fraction = fraction
        self.is_water_detected = True if hasattr(fixture.body.userData, 'object_type') and fixture.body.userData.object_type == CustomUserDataObjectTypes.WATER else False
        self.is_creeper_detected = True if hasattr(fixture.body.userData, 'object_type') and fixture.body.userData.object_type == CustomUserDataObjectTypes.SENSOR_GRIP_TERRAIN else False
        return fraction

FPS    = 50
SCALE  = 30.0
VIEWPORT_W = 600
VIEWPORT_H = 400
NB_LIDAR = 10
LIDAR_RANGE   = 160/SCALE
INITIAL_RANDOM = 5
TERRAIN_STEP   = 14/SCALE
TERRAIN_LENGTH = 200
TERRAIN_HEIGHT = VIEWPORT_H/SCALE/4
TERRAIN_END    = 5
INITIAL_TERRAIN_STARTPAD = 20
FRICTION = 2.5
WATER_DENSITY = 1.0
NB_FIRST_STEPS_HANG = 5

class ParametricContinuousParkour(gym.Env, EzPickle):
    metadata = {'render_modes': ['human', 'rgb_array'], 'video.frames_per_second': FPS}
    
    # === N√ÇNG C·∫§P: Th√™m `horizon` v√†o __init__ ƒë·ªÉ gi·ªõi h·∫°n ƒë·ªô d√†i episode ===
    def __init__(self, agent_body_type, CPPN_weights_path=None, input_CPPN_dim=3,
                 terrain_cppn_scale=10, ceiling_offset=200, ceiling_clip_offset=0,
                 lidars_type='full', water_clip=20, movable_creepers=False,
                 render_mode=None, horizon=1500, **walker_args):

        super().__init__()
        self.rendering_viewer_w = VIEWPORT_W
        self.rendering_viewer_h = VIEWPORT_H
        self.render_mode = render_mode
        self.horizon = horizon  # L∆∞u l·∫°i horizon
        self.ts = 0  # Th√™m bi·∫øn ƒë·∫øm b∆∞·ªõc

        self.np_random = None
        if lidars_type == "down":
            self.lidar_angle = 1.5; self.lidar_y_offset = 0
        elif lidars_type == "up":
            self.lidar_angle = 2.3; self.lidar_y_offset = 1.5
        else:
            self.lidar_angle = np.pi; self.lidar_y_offset = 0

        self.seed()
        self.viewer = None
        self.contact_listener = ContactDetector(self)
        self.world = Box2D.b2World(contactListener=self.contact_listener)
        self.movable_creepers = movable_creepers

        body_type = BodiesEnum.get_body_type(agent_body_type)
        if body_type in [BodyTypesEnum.SWIMMER, BodyTypesEnum.AMPHIBIAN]:
            self.agent_body = BodiesEnum[agent_body_type].value(SCALE, **walker_args)
        elif body_type == BodyTypesEnum.WALKER:
            self.agent_body = BodiesEnum[agent_body_type].value(SCALE, **walker_args,
                                                                reset_on_hull_critical_contact=False)
        else:
            self.agent_body = BodiesEnum[agent_body_type].value(SCALE, **walker_args)

        self.terrain = []
        self.water_dynamics = WaterDynamics(self.world.gravity, max_push=water_clip)
        self.climbing_dynamics = ClimbingDynamics()
        self.prev_shaping = None
        self.episodic_reward = 0

        self.TERRAIN_STARTPAD = max(INITIAL_TERRAIN_STARTPAD,
                                    self.agent_body.AGENT_WIDTH / TERRAIN_STEP + 5)
        self._create_terrain_fixtures()

        self.input_CPPN_dim = input_CPPN_dim
        self.terrain_CPPN = CPPN_Pytorch(x_dim=TERRAIN_LENGTH,
                                         input_dim=input_CPPN_dim,
                                         output_dim=2)
        weights_path = os.path.join(os.path.dirname(os.path.realpath(__file__)),
                                    "PCGAgents/CPPN/weights/same_ground_ceiling_cppn_pytorch.pt")
        self.terrain_CPPN.load_tf_weights(weights_path)

        self.set_terrain_cppn_scale(terrain_cppn_scale, ceiling_offset, ceiling_clip_offset)

        default_params = {"input_vector": np.array([-0.25, 0.8, 0.0]),
                          "water_level": 0.1,
                          "creepers_width": 0.25,
                          "creepers_height": 2.0,
                          "creepers_spacing": 1.5}
        self.set_environment(**default_params)

        self._generate_agent()

        agent_action_size = self.agent_body.get_action_size()
        self.action_space = spaces.Box(np.array([-1]*agent_action_size),
                                       np.array([1]*agent_action_size), dtype=np.float32)

        total_obs_size = 6 + NB_LIDAR*2 + len(self.agent_body.get_motors_state())
        if self.agent_body.body_type == BodyTypesEnum.CLIMBER:
            total_obs_size += len(self.agent_body.get_sensors_state())
        high = np.array([np.inf]*total_obs_size)
        self.observation_space = spaces.Box(-high, high, dtype=np.float32)
    
    def _create_terrain_fixtures(self):
        self.fd_polygon = fixtureDef(shape=polygonShape(vertices=[(0,0),(1,0),(1,-1),(0,-1)]), friction=FRICTION)
        self.fd_edge = fixtureDef(shape=edgeShape(vertices=[(0,0),(1,1)]), friction=FRICTION)
        self.fd_water = fixtureDef(shape=polygonShape(vertices=[(0,0),(1,0),(1,-1),(0,-1)]), density=WATER_DENSITY, isSensor=True)
        self.fd_creeper = fixtureDef(shape=polygonShape(vertices=[(0,0),(1,0),(1,-1),(0,-1)]), density=5.0, isSensor=True)

    def _generate_agent(self):
        init_x = TERRAIN_STEP*self.TERRAIN_STARTPAD/2
        if hasattr(self, 'terrain_ground_y') and len(self.terrain_ground_y) > int(self.TERRAIN_STARTPAD / 2):
            init_y = self.terrain_ground_y[int(self.TERRAIN_STARTPAD / 2)] + self.agent_body.AGENT_CENTER_HEIGHT
        else:
            init_y = TERRAIN_HEIGHT + self.agent_body.AGENT_CENTER_HEIGHT
            
        self.agent_body.draw(self.world, init_x, init_y, self.np_random.uniform(-INITIAL_RANDOM, INITIAL_RANDOM))

    def seed(self, seed=None):
        self.np_random, seed = seeding.np_random(seed)
        return [seed]

    def set_terrain_cppn_scale(self, terrain_cppn_scale, ceiling_offset, ceiling_clip_offset):
        assert terrain_cppn_scale > 1
        self.TERRAIN_CPPN_SCALE = terrain_cppn_scale
        self.CEILING_LIMIT = 1000 / self.TERRAIN_CPPN_SCALE
        self.GROUND_LIMIT = -1000 / self.TERRAIN_CPPN_SCALE
        self.ceiling_offset = ceiling_offset / self.TERRAIN_CPPN_SCALE
        self.ceiling_clip_offset = ceiling_clip_offset / self.TERRAIN_CPPN_SCALE

    def set_environment(self, input_vector, water_level, creepers_width=None, creepers_height=None,
                        creepers_spacing=0.1, terrain_cppn_scale=10):
        self.CPPN_input_vector = input_vector
        self.water_level = water_level.item() if isinstance(water_level, np.float32) else water_level
        self.water_level = max(0.01, self.water_level)
        self.creepers_width = creepers_width if creepers_width is not None else creepers_width
        self.creepers_height = creepers_height if creepers_height is not None else creepers_height
        self.creepers_spacing = max(0.01, creepers_spacing)
        self.set_terrain_cppn_scale(terrain_cppn_scale,
                                    self.ceiling_offset*self.TERRAIN_CPPN_SCALE,
                                    self.ceiling_clip_offset*self.TERRAIN_CPPN_SCALE)

    def _destroy(self):
        if not self.world:
            return
        self.world.contactListener = None
        for t in self.terrain:
            self.world.DestroyBody(t)
        self.terrain = []
        self.agent_body.destroy(self.world)

    def reset(self, seed=None, options=None):
        super().reset(seed=seed)
        self._destroy()

        # === N√ÇNG C·∫§P: Reset bi·∫øn ƒë·∫øm b∆∞·ªõc ===
        self.ts = 0

        self.world = Box2D.b2World(contactListener=self.contact_listener)
        self.world.contactListener = self.contact_listener
        if self.contact_listener:
            self.contact_listener.Reset()

        self.critical_contact = False
        self.prev_shaping = None
        self.scroll = [0.0, 0.0]
        self.lidar_render = 0
        self.water_y = self.GROUND_LIMIT
        self.nb_steps_outside_water = 0
        self.nb_steps_under_water = 0

        self._generate_terrain()
        self._generate_agent()

        self.drawlist = self.terrain + self.agent_body.get_elements_to_render()

        self.lidar = [LidarCallback(self.agent_body.reference_head_object.fixtures[0].filterData.maskBits)
                      for _ in range(NB_LIDAR)]

        actions_to_play = np.array([0] * self.action_space.shape[0])
        if self.agent_body.body_type == BodyTypesEnum.CLIMBER:
            y_diff = 0
            for i in range(len(self.agent_body.sensors)):
                actions_to_play[len(actions_to_play) - i - 1] = 1
                sensor = self.agent_body.sensors[len(self.agent_body.sensors) - i - 1]
                if y_diff == 0:
                    y_diff = TERRAIN_HEIGHT + self.ceiling_offset - sensor.position[1]
                sensor.position = (sensor.position[0],
                                   TERRAIN_HEIGHT + self.ceiling_offset)

            for body_part in self.agent_body.body_parts:
                body_part.position = (body_part.position[0],
                                      body_part.position[1] + y_diff)

            for i in range(NB_FIRST_STEPS_HANG):
                self.step(actions_to_play)

        initial_state, _, _, _, _ = self.step(actions_to_play)
        self.nb_steps_outside_water = 0
        self.nb_steps_under_water = 0
        self.episodic_reward = 0
        self.ts = 0 # Reset l·∫°i bi·∫øn ƒë·∫øm sau khi c√°c step kh·ªüi t·∫°o
        
        # === N√ÇNG C·∫§P: Tu√¢n th·ªß API Gymnasium (tr·∫£ v·ªÅ 2-tuple) ===
        return np.array(initial_state, dtype=np.float32), {}

    def step(self, action):
        # === N√ÇNG C·∫§P: TƒÉng bi·∫øn ƒë·∫øm b∆∞·ªõc ===
        self.ts += 1
        
        is_agent_dead = False
        if hasattr(self.agent_body, "nb_steps_can_survive_outside_water") and \
                        self.nb_steps_outside_water > self.agent_body.nb_steps_can_survive_outside_water:
            is_agent_dead = True
        
        if hasattr(self.agent_body, "nb_steps_can_survive_under_water") and \
                        self.nb_steps_under_water > self.agent_body.nb_steps_can_survive_under_water:
            is_agent_dead = True

        if is_agent_dead:
            action = np.array([0] * self.action_space.shape[0])

        self.agent_body.activate_motors(action)

        if self.agent_body.body_type == BodyTypesEnum.CLIMBER:
            self.climbing_dynamics.before_step_climbing_dynamics(action, self.agent_body, self.world)

        self.world.Step(1.0 / FPS, 6 * 30, 2 * 30)

        if self.agent_body.body_type == BodyTypesEnum.CLIMBER:
            self.climbing_dynamics.after_step_climbing_dynamics(self.world.contactListener, self.world)

        self.water_dynamics.calculate_forces(self.world.contactListener.fixture_pairs)

        head = self.agent_body.reference_head_object
        pos = head.position
        vel = head.linearVelocity

        for i in range(NB_LIDAR):
            self.lidar[i].fraction = 1.0
            self.lidar[i].p1 = pos
            self.lidar[i].p2 = (
                pos[0] + math.sin((self.lidar_angle * i / NB_LIDAR + self.lidar_y_offset)) * LIDAR_RANGE,
                pos[1] - math.cos((self.lidar_angle * i / NB_LIDAR) + self.lidar_y_offset) * LIDAR_RANGE)
            self.world.RayCast(self.lidar[i], self.lidar[i].p1, self.lidar[i].p2)

        is_under_water = pos.y <= self.water_y
        if not is_agent_dead:
            if is_under_water:
                self.nb_steps_under_water += 1
                self.nb_steps_outside_water = 0
            else:
                self.nb_steps_outside_water += 1
                self.nb_steps_under_water = 0

        state = [
            head.angle,
            2.0 * head.angularVelocity / FPS,
            0.3 * vel.x * (VIEWPORT_W / SCALE) / FPS,
            0.3 * vel.y * (VIEWPORT_H / SCALE) / FPS,
            1.0 if is_under_water else 0.0,
            1.0 if is_agent_dead else 0.0
        ]

        state.extend(self.agent_body.get_motors_state())

        if self.agent_body.body_type == BodyTypesEnum.CLIMBER:
            state.extend(self.agent_body.get_sensors_state())

        surface_dectected = []
        for lidar in self.lidar:
            state.append(lidar.fraction)
            if lidar.is_water_detected:
                surface_dectected.append(-1)
            elif lidar.is_creeper_detected:
                surface_dectected.append(1)
            else:
                surface_dectected.append(0)
        state.extend(surface_dectected)

        self.scroll = [pos[0] - self.rendering_viewer_w / SCALE / 5,
                    pos[1] - self.rendering_viewer_h / SCALE / 2.5]

        shaping = 130 * pos[0] / SCALE
        if not (hasattr(self.agent_body, "remove_reward_on_head_angle") and self.agent_body.remove_reward_on_head_angle):
            shaping -= 5.0 * abs(state[0])

        reward = 0
        if self.prev_shaping is not None:
            reward = shaping - self.prev_shaping
        self.prev_shaping = shaping

        for a in action:
            reward -= self.agent_body.TORQUE_PENALTY * 80 * np.clip(np.abs(a), 0, 1)

        terminated = False
        if self.critical_contact or pos[0] < 0 or is_agent_dead:
            reward = -100
            terminated = True
        
        if pos[0] > (TERRAIN_LENGTH + self.TERRAIN_STARTPAD - TERRAIN_END) * TERRAIN_STEP:
            terminated = True
        self.episodic_reward += reward

        # === N√ÇNG C·∫§P: S·ª≠ d·ª•ng horizon ƒë·ªÉ quy·∫øt ƒë·ªãnh truncated ===
        truncated = self.ts >= self.horizon
        
        if self.render_mode == "human":
            self.render()

        # === N√ÇNG C·∫§P: Tu√¢n th·ªß API Gymnasium (tr·∫£ v·ªÅ 5-tuple) ===
        info = {"success": self.episodic_reward > 230}
        return np.array(state, dtype=np.float32), reward, terminated, truncated, info
    
    def _generate_terrain(self):
        self.cloud_poly = []
        self.terrain_x = []
        self.terrain_ground_y = []
        self.terrain_ceiling_y = []
        self.terrain_poly = []
        self.terrain = []

        y = self.terrain_CPPN.generate(self.CPPN_input_vector)
        y = y / self.TERRAIN_CPPN_SCALE
        ground_y = y[:, 0]
        ceiling_y = y[:, 1]

        offset = TERRAIN_HEIGHT - ground_y[0]
        ground_y = np.add(ground_y, offset)

        offset = TERRAIN_HEIGHT + self.ceiling_offset - ceiling_y[0]
        ceiling_y = np.add(ceiling_y, offset)

        terrain_creepers = []
        water_body = None
        x = 0
        max_x = TERRAIN_LENGTH * TERRAIN_STEP + self.TERRAIN_STARTPAD * TERRAIN_STEP

        i = 0
        while x < max_x:
            self.terrain_x.append(x)
            if i < self.TERRAIN_STARTPAD:
                self.terrain_ground_y.append(TERRAIN_HEIGHT)
                self.terrain_ceiling_y.append(TERRAIN_HEIGHT + self.ceiling_offset)
            else:
                self.terrain_ground_y.append(ground_y[i - self.TERRAIN_STARTPAD].item())

                if ceiling_y[i - self.TERRAIN_STARTPAD] >= ground_y[i - self.TERRAIN_STARTPAD] + self.ceiling_clip_offset:
                    ceiling_val = ceiling_y[i - self.TERRAIN_STARTPAD]
                else:
                    ceiling_val = ground_y[i - self.TERRAIN_STARTPAD] + self.ceiling_clip_offset
                self.terrain_ceiling_y.append(ceiling_val.item())

            x += TERRAIN_STEP
            i += 1

        space_from_precedent_creeper = self.creepers_spacing
        for i in range(len(self.terrain_x) - 1):
            poly = [
                (self.terrain_x[i], self.terrain_ground_y[i]),
                (self.terrain_x[i + 1], self.terrain_ground_y[i + 1])
            ]
            self.fd_edge.shape.vertices = poly
            t = self.world.CreateStaticBody(
                fixtures=self.fd_edge,
                userData=CustomUserData("grass", CustomUserDataObjectTypes.TERRAIN))
            color = (0.3, 1.0 if (i % 2) == 0 else 0.8, 0.3)
            t.color1 = color
            t.color2 = color
            self.terrain.append(t)
            color = (0.4, 0.6, 0.3)
            poly += [(poly[1][0], self.GROUND_LIMIT), (poly[0][0], self.GROUND_LIMIT)]
            self.terrain_poly.append((poly, color))

            poly = [
                (self.terrain_x[i], self.terrain_ceiling_y[i]),
                (self.terrain_x[i + 1], self.terrain_ceiling_y[i + 1])
            ]
            self.fd_edge.shape.vertices = poly
            t = self.world.CreateStaticBody(
                fixtures=self.fd_edge,
                userData=CustomUserData("rock", CustomUserDataObjectTypes.GRIP_TERRAIN))
            color = (0, 0.25, 0.25)
            t.color1 = color
            t.color2 = color
            self.terrain.append(t)
            color = (0.5, 0.5, 0.5)
            poly += [(poly[1][0], self.CEILING_LIMIT), (poly[0][0], self.CEILING_LIMIT)]
            self.terrain_poly.append((poly, color))

            if self.creepers_width is not None and self.creepers_height is not None and self.creepers_height > 0:
                if space_from_precedent_creeper >= self.creepers_spacing:
                    creeper_height = max(0.2, self.np_random.normal(self.creepers_height, 0.1))
                    creeper_x = self.terrain_x[i] + TERRAIN_STEP / 2
                    creeper_y = self.terrain_ceiling_y[i]
                    
                    poly = [
                        (creeper_x - self.creepers_width / 2, creeper_y),
                        (creeper_x + self.creepers_width / 2, creeper_y),
                        (creeper_x + self.creepers_width / 2, creeper_y - creeper_height),
                        (creeper_x - self.creepers_width / 2, creeper_y - creeper_height),
                    ]
                    self.fd_creeper.shape.vertices = poly
                    
                    if self.movable_creepers:
                        t = self.world.CreateDynamicBody(
                            position=(0, 0),
                            fixtures=self.fd_creeper,
                            userData=CustomUserData("creeper", CustomUserDataObjectTypes.SENSOR_GRIP_TERRAIN)
                        )
                    else:
                        t = self.world.CreateStaticBody(
                            fixtures=self.fd_creeper,
                            userData=CustomUserData("creeper", CustomUserDataObjectTypes.SENSOR_GRIP_TERRAIN)
                        )

                    t.color1 = (1, 1, 0)
                    t.color2 = (0.8, 0.8, 0)
                    terrain_creepers.append(t)
                    
                    space_from_precedent_creeper = 0
                else:
                    space_from_precedent_creeper += TERRAIN_STEP

        air_max_distance = max(self.terrain_ceiling_y) - self.GROUND_LIMIT
        water_y = self.GROUND_LIMIT + self.water_level * air_max_distance
        self.water_y = water_y
        water_poly = [
            (self.terrain_x[0], self.GROUND_LIMIT),
            (self.terrain_x[0], water_y),
            (self.terrain_x[len(self.terrain_x) - 1], water_y),
            (self.terrain_x[len(self.terrain_x) - 1], self.GROUND_LIMIT)
        ]
        self.fd_water.shape.vertices = water_poly
        t = self.world.CreateStaticBody(
            fixtures=self.fd_water,
            userData=CustomUserData("water", CustomUserDataObjectTypes.WATER))
        c = (0.465, 0.676, 0.898)
        t.color1 = c
        t.color2 = c
        water_body = t

        self.terrain.extend(terrain_creepers)
        if water_body is not None:
            self.terrain.append(water_body)
        self.terrain.reverse()
        
    def _SET_RENDERING_VIEWPORT_SIZE(self, width, height, keep_ratio=True):
        self.rendering_viewer_w = width
        if keep_ratio or height is None:
            self.rendering_viewer_h = int(self.rendering_viewer_w / (VIEWPORT_W / VIEWPORT_H))
        else:
            self.rendering_viewer_h = height
        
    def close(self):
        if self.viewer:
            self.viewer.close()
            self.viewer = None
        self._destroy()

    def color_agent_head(self, c1, c2):
        ratio = 0
        if hasattr(self.agent_body, "nb_steps_can_survive_outside_water"):
            ratio = self.nb_steps_outside_water / self.agent_body.nb_steps_can_survive_outside_water
        elif hasattr(self.agent_body, "nb_steps_can_survive_under_water"):
            ratio = self.nb_steps_under_water / self.agent_body.nb_steps_can_survive_under_water

        color1 = (c1[0] + ratio*(1.0 - c1[0]),
                  c1[1] + ratio*(0.0 - c1[1]),
                  c1[2] + ratio*(0.0 - c1[2]))
        color2 = c2
        return color1, color2

    def render(self, draw_lidars=True):
        from TeachMyAgent.environments.envs.utils import rendering
        
        if self.viewer is None and self.render_mode is not None:
            is_visible = (self.render_mode == 'human')
            self.viewer = rendering.Viewer(self.rendering_viewer_w, self.rendering_viewer_h, visible=is_visible)
            
        if self.viewer is None or self.viewer.window is None or self.viewer.window.has_exit:
            if self.render_mode == 'rgb_array':
                return np.zeros((self.rendering_viewer_h, self.rendering_viewer_w, 3), dtype=np.uint8)
            return None
        
        self.viewer.set_bounds(self.scroll[0], self.rendering_viewer_w/SCALE + self.scroll[0],
                               self.scroll[1], self.rendering_viewer_h/SCALE + self.scroll[1])
        
        self.viewer.draw_polygon( [
            (self.scroll[0], self.scroll[1]),
            (self.scroll[0]+self.rendering_viewer_w/SCALE, self.scroll[1]),
            (self.scroll[0]+self.rendering_viewer_w/SCALE, self.scroll[1]+self.rendering_viewer_h/SCALE),
            (self.scroll[0], self.scroll[1]+self.rendering_viewer_h/SCALE),
            ], color=(0.9, 0.9, 1.0) )

        for poly,x1,x2 in self.cloud_poly:
            if x2 < self.scroll[0]/2: continue
            if x1 > self.scroll[0]/2 + self.rendering_viewer_w/SCALE: continue
            self.viewer.draw_polygon( [(p[0]+self.scroll[0]/2, p[1]) for p in poly], color=(1,1,1))

        for obj in self.drawlist:
            color1 = obj.color1
            color2 = obj.color2
            if hasattr(obj.userData, 'object_type') and obj.userData.object_type == CustomUserDataObjectTypes.BODY_SENSOR and obj.userData.has_joint:
                color1 = (1.0, 1.0, 0.0)
                color2 = (1.0, 1.0, 0.0)
            elif obj == self.agent_body.reference_head_object:
                color1, color2 = self.color_agent_head(color1, color2)

            for f in obj.fixtures:
                trans = f.body.transform
                if type(f.shape) is circleShape:
                    t = rendering.Transform(translation=trans*f.shape.pos)
                    self.viewer.draw_circle(f.shape.radius, 30, color=color1).add_attr(t)
                    self.viewer.draw_circle(f.shape.radius, 30, color=color2, filled=False, linewidth=2).add_attr(t)
                else:
                    path = [trans*v for v in f.shape.vertices]
                    self.viewer.draw_polygon(path, color=color1)
                    path.append(path[0])
                    self.viewer.draw_polyline(path, color=obj.color2, linewidth=2)

        for poly, color in self.terrain_poly:
            if len(poly) < 2 or poly[1][0] < self.scroll[0]: continue
            if poly[0][0] > self.scroll[0] + self.rendering_viewer_w / SCALE: continue
            self.viewer.draw_polygon(poly, color=color)

        if draw_lidars and hasattr(self, 'lidar'):
            for i in range(len(self.lidar)):
                l = self.lidar[i]
                self.viewer.draw_polyline([l.p1, l.p2], color=(1, 0, 0), linewidth=1)

        flagy1 = TERRAIN_HEIGHT
        flagy2 = flagy1 + 50/SCALE
        x = TERRAIN_STEP*3
        self.viewer.draw_polyline( [(x, flagy1), (x, flagy2)], color=(0,0,0), linewidth=2 )
        f = [(x, flagy2), (x, flagy2-10/SCALE), (x+25/SCALE, flagy2-5/SCALE)]
        self.viewer.draw_polygon(f, color=(0.9,0.2,0) )
        self.viewer.draw_polyline(f + [f[0]], color=(0,0,0), linewidth=2 )

        return self.viewer.render(return_rgb_array = self.render_mode=='rgb_array')

===== .\TeachMyAgent\environments\envs\parametric_continuous_stump_tracks.py =====
# Parametric Walker continuous environment
#
# Reward is given for moving forward, total 300+ points up to the far end. If the robot falls,
# it gets -100. Applying motor torque costs a small amount of points, more optimal agent
# will get better score.
#
# State consists of hull angle speed, angular velocity, horizontal speed, vertical speed,
# position of joints and joints angular speed, legs contact with ground, and 10 lidar
# rangefinder measurements. There's no coordinates
# in the state vector.
#
# Initially Created by Oleg Klimov. Licensed on the same terms as the rest of OpenAI Gym.
# Modified by R√©my Portelas and licensed under TeachMyAgent/teachers/LICENSES/ALP-GMM
# Modified Cl√©ment Romac

#region Imports

import numpy as np
import Box2D
from Box2D.b2 import (edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener)
import gymnasium as gym
from gymnasium import spaces
from gymnasium.utils import colorize, seeding, EzPickle
import math


from TeachMyAgent.environments.envs.bodies.BodiesEnum import BodiesEnum
from TeachMyAgent.environments.envs.bodies.BodyTypesEnum import BodyTypesEnum
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomUserDataObjectTypes, CustomUserData

#endregion

#region Utils


class ContactDetector(contactListener):
    '''
        Custom contact detector.
    '''
    def __init__(self, env):
        contactListener.__init__(self)
        self.env = env
    def BeginContact(self, contact):
        '''
            Triggered when contact is detected.

            Checks userData of each of the two fixtures colliding.
            Sets `userData.has_contact` to True on the body if `body.userData.check_contact == True`.
            If `userData.is_contact_critical == True`, `env.critical_contact` is set to True, stopping the episode.
        '''
        for body in [contact.fixtureA.body, contact.fixtureB.body]:
            if body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT and body.userData.check_contact:
                body.userData.has_contact = True
                if body.userData.is_contact_critical:
                    self.env.head_contact = True

    def EndContact(self, contact):
        '''
            Triggered when contact ends.

            Sets `userData.has_contact` to False on the body if `body.userData.check_contact == True`.
        '''
        for body in [contact.fixtureA.body, contact.fixtureB.body]:
            if body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT and body.userData.check_contact:
                body.userData.has_contact = False

def Rotate2D(pts,cnt,ang=np.pi/4):
    '''pts = {} Rotates points(nx2) about center cnt(2) by angle ang(1) in radian'''
    m1 = pts-cnt
    m2 = np.array([[np.cos(ang),np.sin(ang)],[-np.sin(ang),np.cos(ang)]])
    return np.dot(m1,m2)+cnt


class LidarCallback(Box2D.b2.rayCastCallback):
    '''
        Callback function triggered when lidar detects an object.
    '''
    def __init__(self, agent_mask_filter):
        '''
            Args:
                agent_mask_filter: Mask filter used to avoid detecting collisions with the agent's body
        '''
        Box2D.b2.rayCastCallback.__init__(self)
        self.agent_mask_filter = agent_mask_filter
        self.fixture = None
    def ReportFixture(self, fixture, point, normal, fraction):
        '''
            Triggered when a body is detected by the lidar.

            Returns:
                Distance to object detected.
        '''
        if (fixture.filterData.categoryBits & self.agent_mask_filter) == 0:
            return -1
        self.p2 = point
        self.fraction = fraction
        return fraction

#endregion

#region Constants

FPS    = 50
SCALE  = 30.0   # affects how fast-paced the game is, forces should be adjusted as well
VIEWPORT_W = 600 # Careful, this affects training
VIEWPORT_H = 400 # Careful, this affects training

RENDERING_VIEWER_W = VIEWPORT_W # Only affects rendering, not the policy
RENDERING_VIEWER_H = VIEWPORT_H # Only affects rendering, not the policy

NB_LIDAR = 10 # Number of lidars used by the agent
LIDAR_RANGE   = 160/SCALE

INITIAL_RANDOM = 5

TERRAIN_STEP   = 14/SCALE
TERRAIN_LENGTH = 200     # in steps
TERRAIN_HEIGHT = VIEWPORT_H/SCALE/4
TERRAIN_END    = 10    # in steps
INITIAL_TERRAIN_STARTPAD = 20 # in steps
FRICTION = 2.5

#endregion

class ParametricContinuousStumpTracks(gym.Env, EzPickle):
    '''
        The Stump Tracks: a procedurally generated Gym environment.
    '''
    metadata = {
        'render_modes': ['human', 'rgb_array'],
        'video.frames_per_second' : FPS
    }

    def __init__(self, walker_type,render_mode, **walker_args):
        '''
            Creates a Stump Tracks environment with an embodiment.

                walker_type: Embodiment
            :type walker_type: BodiesEnum
                walker_args: kwargs controlling the agent (e.g. number of body for a millipede)
        '''

        super(ParametricContinuousStumpTracks, self).__init__()
        self.render_mode = render_mode

        # Seed env and init Box2D
        self.seed()
        self.viewer = None

        self.world = Box2D.b2World()
        self.terrain = []

        self.prev_shaping = None

        # Create agent
        body_type = BodiesEnum.get_body_type(walker_type)
        if body_type == BodyTypesEnum.SWIMMER or body_type == BodyTypesEnum.AMPHIBIAN:
            self.walker_body = BodiesEnum[walker_type].value(SCALE, density=1.0, **walker_args)
        elif body_type == BodyTypesEnum.WALKER:
            self.walker_body = BodiesEnum[walker_type].value(SCALE, **walker_args,
                                                                reset_on_hull_critical_contact=True)
        else:
            self.walker_body = BodiesEnum[walker_type].value(SCALE, **walker_args)

        # Adapt startpad to walker's width
        self.TERRAIN_STARTPAD = INITIAL_TERRAIN_STARTPAD if \
            self.walker_body.AGENT_WIDTH / TERRAIN_STEP + 5 <= INITIAL_TERRAIN_STARTPAD else \
            self.walker_body.AGENT_WIDTH / TERRAIN_STEP + 5  # in steps
        self.create_terrain_fixtures()

        # Set observation / action spaces
        self._generate_walker()  # To get state / action sizes
        agent_action_size = self.walker_body.get_action_size()
        self.action_space = spaces.Box(np.array([-1] * agent_action_size),
                                       np.array([1] * agent_action_size), dtype=np.float32)

        agent_state_size = self.walker_body.get_state_size()
        high = np.array([np.inf] * (agent_state_size +
                                    4 +  # head infos
                                    NB_LIDAR))  # lidars infos
        self.observation_space = spaces.Box(-high, high, dtype=np.float32)

    def seed(self, seed=None):
        self.np_random, seed = seeding.np_random(seed)
        return [seed]

    def set_environment(self, roughness=None, stump_height=None, stump_width=None, stump_rot=None,
                        obstacle_spacing=None, poly_shape=None, stump_seq=None):
        '''
            Set the parameters controlling the PCG algorithm to generate a task.
            Call this method before `reset()`.

            Args:
                roughness: Input vector controlling the CPPN
                stump_height: Tuple specifying mean and std of a normal distribution from which the height of each stump is sampled
                stump_width: Tuple specifying mean and std of a normal distribution from which the width of each stump is sampled
                stump_rot: Tuple specifying mean and std of a normal distribution from which the rotation degree of each stump is sampled
                obstacle_spacing: Spacing between stumps
                poly_shape: Shape of polygon stumps
        '''
        self.roughness = roughness if roughness else 0
        self.obstacle_spacing = max(0.01, obstacle_spacing) if obstacle_spacing is not None else 8.0
        self.stump_height = stump_height
        self.stump_width = stump_width
        self.stump_rot = stump_rot
        self.hexa_shape = poly_shape
        self.stump_seq = stump_seq
        if poly_shape is not None:
            self.hexa_shape = np.interp(poly_shape,[0,4],[0,4]).tolist()
            assert(len(poly_shape) == 12)
            self.hexa_shape = self.hexa_shape[0:12]

    def _destroy(self):
        # if not self.terrain: return
        self.world.contactListener = None
        for t in self.terrain:
            self.world.DestroyBody(t)
        self.terrain = []

        self.walker_body.destroy(self.world)

    def reset(self, *, seed=None, options=None):
        super().reset(seed=seed)
        self._destroy()
        self.world.contactListener_bug_workaround = ContactDetector(self)
        self.world.contactListener = self.world.contactListener_bug_workaround
        self.head_contact = False
        self.prev_shaping = None
        self.scroll = 0.0
        self.lidar_render = 0

        self.generate_game()

        self.drawlist = self.terrain + self.walker_body.get_elements_to_render()

        self.lidar = [LidarCallback(self.walker_body.reference_head_object.fixtures[0].filterData.maskBits)
                      for _ in range(NB_LIDAR)]
        self.episodic_reward = 0

        obs, _, _, _, _ = self.step(np.array([0] * self.action_space.shape[0]))
        return np.array(obs, dtype=np.float32), {}

    def step(self, action):
        self.walker_body.activate_motors(action)

        self.world.Step(1.0/FPS, 6*30, 2*30)

        head = self.walker_body.reference_head_object
        pos = head.position
        vel = head.linearVelocity

        for i in range(NB_LIDAR):
            self.lidar[i].fraction = 1.0
            self.lidar[i].p1 = pos
            self.lidar[i].p2 = (
                pos[0] + math.sin(1.5*i/NB_LIDAR)*LIDAR_RANGE,
                pos[1] - math.cos(1.5*i/NB_LIDAR)*LIDAR_RANGE)
            self.world.RayCast(self.lidar[i], self.lidar[i].p1, self.lidar[i].p2)
        state = [
            head.angle,        # Normal angles up to 0.5 here, but sure more is possible.
            2.0*head.angularVelocity/FPS,
            0.3*vel.x*(VIEWPORT_W/SCALE)/FPS,  # Normalized to get -1..1 range
            0.3*vel.y*(VIEWPORT_H/SCALE)/FPS]

        # add leg-related state
        state.extend(self.walker_body.get_motors_state())

        if self.walker_body.body_type == BodyTypesEnum.CLIMBER:
            state.extend(self.walker_body.get_sensors_state())

        state += [l.fraction for l in self.lidar]

        self.scroll = pos.x - RENDERING_VIEWER_W/SCALE/5

        shaping  = 130*pos[0]/SCALE  # moving forward is a way to receive reward (normalized to get 300 on completion)
        if not (hasattr(self.walker_body, "remove_reward_on_head_angle") and self.walker_body.remove_reward_on_head_angle):
            shaping -= 5.0*abs(state[0])  # keep head straight, other than that and falling, any behavior is unpunished

        reward = 0
        if self.prev_shaping is not None:
            reward = shaping - self.prev_shaping
        self.prev_shaping = shaping

        for a in action:
            reward -= self.walker_body.TORQUE_PENALTY * 80 * np.clip(np.abs(a), 0, 1) # 80 => Original torque
            # normalized to about -50.0 using heuristic, more optimal agent should spend less

        done = False
        if self.head_contact or pos[0] < 0:
            reward = -100
            done   = True
        if pos[0] > (TERRAIN_LENGTH-TERRAIN_END)*TERRAIN_STEP:
            done   = True
        self.episodic_reward += reward
        terminated = done
        truncated = self.episodic_reward > 230
        return np.array(state, dtype=np.float32), reward, terminated, truncated, {"success": self.episodic_reward > 230}


    def render(self, mode='human', draw_lidars=True):
        #self.scroll = 1
        from TeachMyAgent.environments.envs.utils import rendering
        if self.viewer is None:
            self.viewer = rendering.Viewer(RENDERING_VIEWER_W, RENDERING_VIEWER_H)
        self.viewer.set_bounds(self.scroll, RENDERING_VIEWER_W/SCALE + self.scroll, 0, RENDERING_VIEWER_H/SCALE)

        self.viewer.draw_polygon( [
            (self.scroll,                  0),
            (self.scroll+RENDERING_VIEWER_W/SCALE, 0),
            (self.scroll+RENDERING_VIEWER_W/SCALE, RENDERING_VIEWER_H/SCALE),
            (self.scroll,                  RENDERING_VIEWER_H/SCALE),
            ], color=(0.9, 0.9, 1.0) )
        for poly,x1,x2 in self.cloud_poly:
            if x2 < self.scroll/2: continue
            if x1 > self.scroll/2 + RENDERING_VIEWER_W/SCALE: continue
            self.viewer.draw_polygon( [(p[0]+self.scroll/2, p[1]) for p in poly], color=(1,1,1))
        for poly, color in self.terrain_poly:
            if poly[1][0] < self.scroll: continue
            if poly[0][0] > self.scroll + RENDERING_VIEWER_W/SCALE: continue
            self.viewer.draw_polygon(poly, color=color)

        for obj in self.drawlist:
            for f in obj.fixtures:
                trans = f.body.transform
                if type(f.shape) is circleShape:
                    t = rendering.Transform(translation=trans*f.shape.pos)
                    self.viewer.draw_circle(f.shape.radius, 30, color=obj.color1).add_attr(t)
                    self.viewer.draw_circle(f.shape.radius, 30, color=obj.color2, filled=False, linewidth=2).add_attr(t)
                else:
                    path = [trans*v for v in f.shape.vertices]
                    self.viewer.draw_polygon(path, color=obj.color1)
                    path.append(path[0])
                    self.viewer.draw_polyline(path, color=obj.color2, linewidth=2)

        # Draw lidars
        if draw_lidars:
            for i in range(len(self.lidar)):
                l = self.lidar[i]
                self.viewer.draw_polyline([l.p1, l.p2], color=(1, 0, 0), linewidth=1)

        flagy1 = TERRAIN_HEIGHT
        flagy2 = flagy1 + 50/SCALE
        x = TERRAIN_STEP*3
        self.viewer.draw_polyline( [(x, flagy1), (x, flagy2)], color=(0,0,0), linewidth=2 )
        f = [(x, flagy2), (x, flagy2-10/SCALE), (x+25/SCALE, flagy2-5/SCALE)]
        self.viewer.draw_polygon(f, color=(0.9,0.2,0) )
        self.viewer.draw_polyline(f + [f[0]], color=(0,0,0), linewidth=2 )

        return self.viewer.render(return_rgb_array = mode=='rgb_array')

    def _SET_RENDERING_VIEWPORT_SIZE(self, width, height=None, keep_ratio=True):
        '''
            Set rendering viewport's size (i.e. image size).

            Args:
                width: viewport's width
                height: viewport's height
                keep_ratio: Whether height must be automatically calculated to keep the same ratio as the environment's viewport size.
        '''
        global RENDERING_VIEWER_W, RENDERING_VIEWER_H
        RENDERING_VIEWER_W = width
        if keep_ratio or height is None:
            RENDERING_VIEWER_H = int(RENDERING_VIEWER_W / (VIEWPORT_W / VIEWPORT_H))
        else:
            RENDERING_VIEWER_H = height

    def close(self):
        self._destroy()
        if self.viewer is not None:
            self.viewer.close()
            self.viewer = None

    #region Fixtures Initialization
    # ------------------------------------------ FIXTURES INITIALIZATION ------------------------------------------

    def create_terrain_fixtures(self):
        '''
            Create fixtures used to generate terrain.
        '''
        self.fd_polygon = fixtureDef(
            shape=polygonShape(vertices=
                               [(0, 0),
                                (1, 0),
                                (1, -1),
                                (0, -1)]),
            friction=FRICTION,
            categoryBits=0x1,
            maskBits=0xFFFF
        )

        self.fd_edge = fixtureDef(
            shape=edgeShape(vertices=
                            [(0, 0),
                             (1, 1)]),
            friction=FRICTION,
            categoryBits=0x1,
            maskBits=0xFFFF
        )

        # Init default hexagon fixture and shape, used only for Hexagon Tracks
        self.fd_default_hexagon = fixtureDef(
            shape=polygonShape(vertices=
                               [(0, 0),
                                (1, 0),
                                (1, -1),
                                (0, -1)]),
            friction=FRICTION,
            categoryBits=0x1,
            maskBits=0xFFFF
        )
        self.default_hexagon = [(-0.5, 0), (-0.5, 0.25), (-0.25, 0.5), (0.25, 0.5), (0.5, 0.25), (0.5, 0)]

    #endregion

    # region Game Generation
    # ------------------------------------------ GAME GENERATION ------------------------------------------

    def generate_game(self):
        '''
            Generate the task (i.e. terrain + embodiment).
        '''
        self._generate_terrain()
        self._generate_clouds()
        self._generate_walker()

    def _generate_terrain(self):
        GRASS, STUMP, HEXA = 0, None, None
        cpt=1
        if self.stump_height:
            STUMP = cpt
            cpt += 1
        if self.hexa_shape:
            HEXA = cpt
            cpt += 1
        if self.stump_seq is not None:
            SEQ = cpt
            cpt += 1
        _STATES_ = cpt

        state = self.np_random.integers(1, _STATES_)

        velocity = 0.0
        y = TERRAIN_HEIGHT
        self.terrain = []
        self.terrain_x = []
        self.terrain_y = []
        x = 0
        max_x = TERRAIN_LENGTH * TERRAIN_STEP

        # Add startpad
        max_startpad_x = self.TERRAIN_STARTPAD * TERRAIN_STEP
        self.terrain_x.append(x)
        self.terrain_y.append(y)
        x += max_startpad_x
        self.terrain_x.append(x)
        self.terrain_y.append(y)
        oneshot = True

        # Generation of terrain
        while x < max_x:
            self.terrain_x.append(x)

            if state==GRASS and not oneshot:
                velocity = 0.8*velocity + 0.01*np.sign(TERRAIN_HEIGHT - y)
                if x > max_startpad_x: velocity += self.np_random.uniform(-self.roughness, self.roughness)/SCALE

                y += velocity
                x += self.obstacle_spacing

            elif state==STUMP and oneshot:
                stump_height = max(0.05, self.np_random.normal(self.stump_height[0], self.stump_height[1]))
                stump_width = TERRAIN_STEP
                if self.stump_width is not None:
                    stump_width *= max(0.05, np.random.normal(self.stump_width[0], self.stump_width[1]))
                poly = [
                    (x, y),
                    (x+stump_width, y),
                    (x+stump_width, y+stump_height * TERRAIN_STEP),
                    (x,y+stump_height * TERRAIN_STEP),
                    ]
                x += stump_width
                if self.stump_rot is not None:
                    anchor = (np.array(poly[0]) + np.array(poly[1]))/2
                    rotation = np.clip(self.np_random.normal(self.stump_rot[0], self.stump_rot[1]),0,2*np.pi)
                    poly = Rotate2D(np.array(poly), anchor, rotation).tolist()
                self.fd_polygon.shape.vertices=poly
                t = self.world.CreateStaticBody(
                    fixtures = self.fd_polygon,
                    userData=CustomUserData("grass", CustomUserDataObjectTypes.TERRAIN))
                t.color1, t.color2 = (1,1,1), (0.6,0.6,0.6)
                self.terrain.append(t)
            elif state==HEXA and oneshot:
                # first point do not move
                poly = []
                delta_pos = []
                for i in range(0,len(self.hexa_shape),2):
                    delta_pos.append(tuple(np.random.normal(self.hexa_shape[i:i+2],0.1)))
                for i,(b,d) in enumerate(zip(self.default_hexagon, delta_pos)):
                    if i != 0 and i != (len(self.default_hexagon)-1):
                        poly.append((x + (b[0]*TERRAIN_STEP) + (d[0]*TERRAIN_STEP),
                                     y + (b[1]*TERRAIN_STEP) + (d[1]*TERRAIN_STEP)))
                    else:
                        poly.append((x + (b[0]*TERRAIN_STEP) + (d[0]*TERRAIN_STEP),
                                     y + (b[1]*TERRAIN_STEP)))
                x += 1
                self.fd_default_hexagon.shape.vertices = poly
                t = self.world.CreateStaticBody(
                    fixtures=self.fd_default_hexagon)
                t.color1, t.color2 = (1.0, np.clip(delta_pos[0][1]/3,0,1), np.clip(delta_pos[-1][1]/3,0,1)), (0.6, 0.6, 0.6)
                self.terrain.append(t)

            elif state==SEQ and oneshot:
                for height, width in zip(self.stump_seq[0::2], self.stump_seq[1::2]):
                    stump_height = max(0.05, self.np_random.normal(height, 0.1))
                    stump_width = max(0.05, self.np_random.normal(width, 0.1))
                    poly = [
                        (x, y),
                        (x + stump_width, y),
                        (x + stump_width, y + stump_height * TERRAIN_STEP),
                        (x, y + stump_height * TERRAIN_STEP),
                    ]
                    x += stump_width
                    self.fd_polygon.shape.vertices = poly
                    t = self.world.CreateStaticBody(
                        fixtures=self.fd_polygon,
                        userData=CustomUserData("grass", CustomUserDataObjectTypes.TERRAIN))
                    t.color1, t.color2 = (1, 1, 1), (0.6, 0.6, 0.6)
                    self.terrain.append(t)

            oneshot = False
            self.terrain_y.append(y)
            if state==GRASS:
                state = self.np_random.integers(1, _STATES_)
                oneshot = True
            else:
                state = GRASS
                oneshot = False

        # Draw terrain
        self.terrain_poly = []
        assert len(self.terrain_x) == len(self.terrain_y)
        for i in range(len(self.terrain_x)-1):
            poly = [
                (self.terrain_x[i],   self.terrain_y[i]),
                (self.terrain_x[i+1], self.terrain_y[i+1])
                ]
            self.fd_edge.shape.vertices=poly
            t = self.world.CreateStaticBody(
                fixtures = self.fd_edge,
                userData=CustomUserData("grass", CustomUserDataObjectTypes.TERRAIN))
            color = (0.3, 1.0 if (i % 2) == 0 else 0.8, 0.3)
            t.color1 = color
            t.color2 = color
            self.terrain.append(t)
            color = (0.4, 0.6, 0.3)
            poly += [ (poly[1][0], 0), (poly[0][0], 0) ]
            self.terrain_poly.append( (poly, color) )
        self.terrain.reverse()

    def _generate_clouds(self):
        # Sorry for the clouds, couldn't resist
        self.cloud_poly   = []
        for i in range(TERRAIN_LENGTH//20):
            x = self.np_random.uniform(0, TERRAIN_LENGTH)*TERRAIN_STEP
            y = VIEWPORT_H/SCALE*3/4
            poly = [
                (x+15*TERRAIN_STEP*math.sin(3.14*2*a/5)+self.np_random.uniform(0,5*TERRAIN_STEP),
                 y+ 5*TERRAIN_STEP*math.cos(3.14*2*a/5)+self.np_random.uniform(0,5*TERRAIN_STEP) )
                for a in range(5) ]
            x1 = min( [p[0] for p in poly] )
            x2 = max( [p[0] for p in poly] )
            self.cloud_poly.append( (poly,x1,x2) )

    def _generate_walker(self):
        init_x = TERRAIN_STEP*self.TERRAIN_STARTPAD/2
        if hasattr(self.walker_body, "old_morphology") and self.walker_body.old_morphology:
            init_y = TERRAIN_HEIGHT + 2 * self.walker_body.LEG_H
        else:
            init_y = TERRAIN_HEIGHT + self.walker_body.AGENT_CENTER_HEIGHT

        self.walker_body.draw(
            self.world,
            init_x,
            init_y,
            self.np_random.uniform(-INITIAL_RANDOM, INITIAL_RANDOM)
        )

    #endregion

===== .\TeachMyAgent\environments\envs\__init__.py =====


===== .\TeachMyAgent\environments\envs\bodies\AbstractBody.py =====
import numpy as np

class AbstractBody(object):
    '''
        Base class for all embodiments.
    '''
    def __init__(self, scale, motors_torque):
        '''
            Creates an embodiment.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
        '''
        self.SCALE = scale
        self.MOTORS_TORQUE = motors_torque

        self.body_parts = [] # list of objects constituting the body
        self.motors = [] # list of motors

    # States
    def get_state_size(self):
        '''
            Returns the size of the embodiment's state vector
        '''
        return len(self.get_motors_state())

    def get_motors_state(self):
        '''
            Returns state vector of motors.

            For each motor returns:
            - its angle
            - its speed
            - if `motor.userData` has `check_contact` to True, returns whether the associated body checking contact has contact
        '''
        state = []
        for motor in self.motors:
            motor_info = motor.userData
            if motor_info.check_contact:
                state.extend([
                    motor.angle + motor_info.angle_correction,
                    motor.speed / motor_info.speed_control,
                    1.0 if motor_info.contact_body.userData.has_contact else 0.0 # If motor has check_contact=True, check the contact of the associated contact_body
                ])
            else:
                state.extend([
                    motor.angle + motor_info.angle_correction,
                    motor.speed / motor_info.speed_control
                ])
        return state

    # Actions
    def get_action_size(self):
        '''
            Returns the size of the action space.
        '''
        return len(self.motors)

    def activate_motors(self, action):
        '''
            Activate motors given a vector of actions (between -1 and 1).

            Sets `motorSpeed` to `speed_control * sign(action)`.
            Sets `maxMotorTorque` to `MOTORS_TORQUE * abs(action)` (with `MOTORS_TORQUE` the torque set in the constructor).
        '''
        for i in range(len(self.motors)):
            self.motors[i].motorSpeed  = float(self.motors[i].userData.speed_control * np.sign(action[i]))
            self.motors[i].maxMotorTorque = float(self.MOTORS_TORQUE * np.clip(np.abs(action[i]), 0, 1))

    # Draw
    def draw(self, world, init_x, init_y, force_to_center):
        '''
            Creates fixtures and bodies in the Box2D world.
        '''
        pass

    def get_elements_to_render(self):
        '''
            Returns bodies that must be rendered in the `env.render` function.
        '''
        return self.body_parts

    # Destroy
    def destroy(self, world):
        for body_part in self.body_parts:
            world.DestroyBody(body_part)
        self.body_parts = []
        self.motors = []







===== .\TeachMyAgent\environments\envs\bodies\BodiesEnum.py =====
from enum import Enum
from TeachMyAgent.environments.envs.bodies.BodyTypesEnum import BodyTypesEnum

from TeachMyAgent.environments.envs.bodies.climbers.ClimbingChestProfileChimpanzee import ClimbingChestProfileChimpanzee
from TeachMyAgent.environments.envs.bodies.climbers.ClimbingProfileChimpanzee import ClimbingProfileChimpanzee

from TeachMyAgent.environments.envs.bodies.swimmers.FishBody import FishBody

from TeachMyAgent.environments.envs.bodies.amphibians.AmphibiousBipedalBody import AmphibiousBipedalBody

from TeachMyAgent.environments.envs.bodies.walkers.old.OldBigQuadruBody import OldBigQuadruBody
from TeachMyAgent.environments.envs.bodies.walkers.old.OldClassicBipedalBody import OldClassicBipedalBody
from TeachMyAgent.environments.envs.bodies.walkers.SmallBipedalBody import SmallBipedalBody
from TeachMyAgent.environments.envs.bodies.walkers.BigQuadruBody import BigQuadruBody
from TeachMyAgent.environments.envs.bodies.walkers.ClassicBipedalBody import ClassicBipedalBody
from TeachMyAgent.environments.envs.bodies.walkers.MillipedeBody import MillipedeBody
from TeachMyAgent.environments.envs.bodies.walkers.ProfileChimpanzee import ProfileChimpanzee
from TeachMyAgent.environments.envs.bodies.walkers.SpiderBody import SpiderBody
from TeachMyAgent.environments.envs.bodies.walkers.WheelBody import WheelBody


class BodiesEnum(Enum):
    '''
        Possible embodiments to use.

        Associates a string name to a class.
    '''
    small_bipedal = SmallBipedalBody
    classic_bipedal = ClassicBipedalBody
    big_quadru = BigQuadruBody
    spider = SpiderBody
    millipede = MillipedeBody
    wheel = WheelBody
    old_classic_bipedal = OldClassicBipedalBody
    profile_chimpanzee = ProfileChimpanzee
    old_big_quadru = OldBigQuadruBody
    fish = FishBody
    climbing_profile_chimpanzee = ClimbingProfileChimpanzee
    climbing_chest_profile_chimpanzee = ClimbingChestProfileChimpanzee
    amphibious_bipedal = AmphibiousBipedalBody

    @classmethod
    def get_body_type(self, body_name):
        '''
            Return embodiment's type given its name.
        '''
        if body_name in ['climbing_chest_profile_chimpanzee', 'climbing_profile_chimpanzee']:
            return BodyTypesEnum.CLIMBER
        elif body_name == 'fish':
            return BodyTypesEnum.SWIMMER
        elif body_name == 'amphibious_bipedal':
            return BodyTypesEnum.AMPHIBIAN
        else:
            return BodyTypesEnum.WALKER

===== .\TeachMyAgent\environments\envs\bodies\BodyTypesEnum.py =====
from enum import Enum

class BodyTypesEnum(Enum):
    '''
        Types of pembodiments
    '''
    WALKER = 0
    SWIMMER = 1
    CLIMBER = 2
    AMPHIBIAN = 3

===== .\TeachMyAgent\environments\envs\bodies\__init__.py =====


===== .\TeachMyAgent\environments\envs\bodies\amphibians\AmphibianAbstractBody.py =====
from TeachMyAgent.environments.envs.bodies.AbstractBody import AbstractBody
from TeachMyAgent.environments.envs.bodies.BodyTypesEnum import BodyTypesEnum

class AmphibianAbstractBody(AbstractBody):
    '''
        Base class for amphibians.
    '''
    def __init__(self, scale, motors_torque, density):
        '''
            Creates an amphibious embodiment allowed to go both under and outside water

            :param scale: Scale value used in the environment (to adapt the embodiment to its environment)
            :param motors_torque: Maximum torque the embodiment can use on its motors
            :param density: Water density (in order to make the agent in a zero-gravity-like setup)
        '''
        super(AmphibianAbstractBody, self).__init__(scale, motors_torque)

        self.body_type = BodyTypesEnum.AMPHIBIAN
        self.DENSITY = density # set the embodiment's density to the same value as water so that it will be in a zero-gravity setup

===== .\TeachMyAgent\environments\envs\bodies\amphibians\AmphibiousBipedalBody.py =====
import numpy as np
from Box2D.b2 import edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener

from TeachMyAgent.environments.envs.bodies.amphibians.AmphibianAbstractBody import AmphibianAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData

HULL_POLYGONS = [
    [(-30, +9), (+6, +9), (+34, +1),
    (+34, -8), (-30, -8)]
]
HULL_BOTTOM_WIDTH = 64
SPEED_HIP     = 4
SPEED_KNEE    = 6

class AmphibiousBipedalBody(AmphibianAbstractBody):
    '''
        Amphibious Bipedal walker embodiment.
    '''
    def __init__(self, scale, density, motors_torque=80):
        '''
            Creates an amphibious bipedal embodiment allowed to go both under and outside water

            :param scale: Scale value used in the environment (to adapt the embodiment to its environment)
            :param motors_torque: Maximum torque the embodiment can use on its motors
            :param density: Water density (in order to make the agent in a zero-gravity-like setup)
        '''
        super(AmphibiousBipedalBody, self).__init__(scale, motors_torque, density)
        self.LEG_DOWN = 3 / self.SCALE # 0 = center of hull
        self.LEG_W, self.LEG_H = 8 / self.SCALE, 34 / self.SCALE
        self.TORQUE_PENALTY = 0.00035

        self.AGENT_WIDTH = HULL_BOTTOM_WIDTH / self.SCALE
        self.AGENT_HEIGHT = 17 / self.SCALE + \
                            self.LEG_H * 2 - self.LEG_DOWN
        self.AGENT_CENTER_HEIGHT = self.LEG_H * 2 + self.LEG_DOWN

    def draw(self, world, init_x, init_y, force_to_center):
        HULL_FIXTURES = [
            fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in polygon]),
                density=self.DENSITY * 1.25,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x000F)  # 0.99 bouncy
            for polygon in HULL_POLYGONS
        ]

        LEG_FD = fixtureDef(
            shape=polygonShape(box=(self.LEG_W / 2, self.LEG_H / 2)),
            density=self.DENSITY * 0.25,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        LOWER_FD = fixtureDef(
            shape=polygonShape(box=(0.8 * self.LEG_W / 2, self.LEG_H / 2)),
            density=self.DENSITY * 0.25,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        hull = world.CreateDynamicBody(
            position=(init_x, init_y),
            fixtures=HULL_FIXTURES
        )
        hull.color1 = (0.44, 0.81, 0.14)
        hull.color2 = (0.36, 0.66, 0.11)
        hull.ApplyForceToCenter((force_to_center, 0), True)

        hull.userData = CustomBodyUserData(True, is_contact_critical=False, name="hull")
        self.body_parts.append(hull)
        self.reference_head_object = hull

        for i in [-1, +1]:
            leg = world.CreateDynamicBody(
                position=(init_x, init_y - self.LEG_H / 2 - self.LEG_DOWN),
                #angle=(i * 0.05),#2¬∞
                fixtures=LEG_FD
            )
            leg.color1 = (0.44, 0.81, 0.14)
            leg.color2 = (0.36, 0.66, 0.11)
            rjd = revoluteJointDef(
                bodyA=hull,
                bodyB=leg,
                anchor=(init_x, init_y - self.LEG_DOWN),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=i,
                lowerAngle=-0.8,
                upperAngle=1.1,
            )

            leg.userData = CustomBodyUserData(False, name="leg")
            self.body_parts.append(leg)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            lower = world.CreateDynamicBody(
                position=(init_x, init_y - self.LEG_H * 3 / 2 - self.LEG_DOWN),
                #angle=(i * 0.05), #2¬∞
                fixtures=LOWER_FD
            )
            lower.color1 = (1.0, 0.25, 0.04)
            lower.color2 = (0.86, 0.29, 0.12)
            rjd = revoluteJointDef(
                bodyA=leg,
                bodyB=lower,
                anchor=(init_x, init_y - self.LEG_DOWN - self.LEG_H),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=-1.6,
                upperAngle=-0.1,
            )

            lower.userData = CustomBodyUserData(True, name="lower")
            self.body_parts.append(lower)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(
                SPEED_KNEE,
                True,
                contact_body=lower,
                angle_correction=1.0)
            self.motors.append(joint_motor)

===== .\TeachMyAgent\environments\envs\bodies\amphibians\__init__.py =====


===== .\TeachMyAgent\environments\envs\bodies\climbers\ClimberAbstractBody.py =====
from TeachMyAgent.environments.envs.bodies.walkers.WalkerAbstractBody import WalkerAbstractBody
from TeachMyAgent.environments.envs.bodies.BodyTypesEnum import BodyTypesEnum
import Box2D
from Box2D.b2 import circleShape, fixtureDef

class ClimberAbstractBody(WalkerAbstractBody):
    '''
        Base class for climbers.
    '''
    def __init__(self, scale, motors_torque, nb_steps_under_water):
        '''
            Creates a climber, which cannot survive under water and cannot touch ground.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                nb_steps_under_water: How many consecutive steps the embodiment can survive under water
        '''
        super(ClimberAbstractBody, self).__init__(scale, motors_torque, nb_steps_under_water)

        self.body_type = BodyTypesEnum.CLIMBER
        self.sensors = []
        self.SENSOR_FD = fixtureDef(
            shape=circleShape(radius=0.05),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x1,
            isSensor=True
        )

    # # States
    # def get_state_size(self):
    #     '''
    #         Returns the size of the embodiment's state vector (classic state + sensors)
    #     '''
    #     return super(ClimberAbstractBody, self).get_state_size() + len(self.get_sensors_state())

    def get_sensors_state(self):
        '''
            Returns state vector sensors.

            For each sensor returns:
            - if it a collision is detected
            - if it is already grasping (i.e. it is attached to a joint)
        '''
        state = []
        for sensor in self.sensors:
            state.extend([1.0 if sensor.userData.has_contact else 0.0,
                          1.0 if sensor.userData.has_joint else 0.0])
        return state

    # Actions
    def get_action_size(self):
        '''
            Returns the size of the action space (classic action space + number of sensors).
        '''
        return super(ClimberAbstractBody, self).get_action_size() + len(self.sensors)

    # Draw
    def get_elements_to_render(self):
        '''
            Returns bodies that must be rendered in the `env.render` function (including sensors).
        '''
        return super(ClimberAbstractBody, self).get_elements_to_render() + self.sensors

    # Destroy
    def destroy(self, world):
        super(ClimberAbstractBody, self).destroy(world)  # Destroy the rest of the body as any other agent
        for sensor in self.sensors:
            world.DestroyBody(sensor) # Destroy sensor
        self.sensors = []






===== .\TeachMyAgent\environments\envs\bodies\climbers\ClimbingChestProfileChimpanzee.py =====
import numpy as np
from Box2D.b2 import edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener, weldJointDef

from TeachMyAgent.environments.envs.bodies.climbers.ClimberAbstractBody import ClimberAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData, CustomBodySensorUserData

SPEED_HIP     = 4
SPEED_KNEE    = 6
SPEED_HAND    = 8

class ClimbingChestProfileChimpanzee(ClimberAbstractBody):
    '''
        Climbing 'chimpanzee' embodiment without legs.
    '''
    def __init__(self, scale, motors_torque=100, nb_steps_under_water=600):
        '''
            Creates a legless chimpanzee with:
            - a head
            - a chest
            - two arms (constituted of two limbs each)
            - two hands (constituted of one limbs each)
            - two sensors (each at the extremity of a hand) to detect collisions with graspable areas and grasp them.

            No contact with ground is allowed.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                nb_steps_under_water: How many consecutive steps the embodiment can survive under water
        '''
        super(ClimbingChestProfileChimpanzee, self).__init__(scale, motors_torque, nb_steps_under_water)
        self.LEG_DOWN = 12 / self.SCALE
        self.ARM_UP = 22 / self.SCALE
        self.LIMB_W, self.LIMB_H = 8 / self.SCALE, 28 / self.SCALE
        self.HAND_PART_W, self.HAND_PART_H = 4 / self.SCALE, 8 / self.SCALE
        self.LEG_H = self.LIMB_H
        self.TORQUE_PENALTY = 0.00035 / 5 # Legs + arms + hands
        self.BODY_HEIGHT = 45
        self.HEAD_HEIGHT = 20

        self.AGENT_WIDTH = 24 / self.SCALE
        self.AGENT_HEIGHT = self.BODY_HEIGHT / self.SCALE + \
                            self.HEAD_HEIGHT / self.SCALE + 0.2 + \
                            self.LEG_H * 2 - self.LEG_DOWN
        self.AGENT_CENTER_HEIGHT = self.LEG_H * 2 + self.LEG_DOWN

        self.remove_reward_on_head_angle = True

    def draw(self, world, init_x, init_y, force_to_center):
        head = world.CreateDynamicBody(
            position=(init_x, init_y + self.BODY_HEIGHT / self.SCALE / 2 + self.HEAD_HEIGHT / self.SCALE / 2 + 0.2),
            fixtures=fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in [
                    (-5, +10), (+5, +10),
                    (+5, -10), (-5, -10)]]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x1
            )
        )
        head.color1 = (0.5, 0.4, 0.9)
        head.color2 = (0.3, 0.3, 0.5)
        head.ApplyForceToCenter((force_to_center, 0), True)

        head.userData = CustomBodyUserData(True, is_contact_critical=True, name="head")
        self.body_parts.append(head)
        self.reference_head_object = head

        body = world.CreateDynamicBody(
            position=(init_x, init_y),
            fixtures=fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in [
                    (-12, +25), (+12, +25),
                    (+8, --15), (-8, --15)]]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x1  # collide only with ground
            )
        )
        body.color1 = (0.5, 0.4, 0.9)
        body.color2 = (0.3, 0.3, 0.5)

        body.userData = CustomBodyUserData(True, is_contact_critical=True, name="body")
        self.body_parts.append(body)
        
        rjd = revoluteJointDef(
            bodyA=head,
            bodyB=body,
            anchor=(init_x, init_y + self.BODY_HEIGHT / self.SCALE / 2),
            enableMotor=False,
            enableLimit=True,
            lowerAngle=-0.1 * np.pi,
            upperAngle=0.1 * np.pi,
        )

        world.CreateJoint(rjd)

        UPPER_LIMB_FD = fixtureDef(
            shape=polygonShape(box=(self.LIMB_W / 2, self.LIMB_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x1
        )

        LOWER_LIMB_FD = fixtureDef(
            shape=polygonShape(box=(0.8 * self.LIMB_W / 2, self.LIMB_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x1
        )

        HAND_PART_FD = fixtureDef(
            shape=polygonShape(box=(self.HAND_PART_W / 2, self.HAND_PART_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x1
        )

        # ARMS
        for j in [-1, -1]:
            upper = world.CreateDynamicBody(
                position=(init_x, init_y + self.LIMB_H / 2 + self.ARM_UP),
                # angle=(i * 0.05),
                fixtures=UPPER_LIMB_FD
            )
            upper.color1 = (0.6 - j / 10., 0.3 - j / 10., 0.5 - j / 10.)
            upper.color2 = (0.4 - j / 10., 0.2 - j / 10., 0.3 - j / 10.)
            rjd = revoluteJointDef(
                bodyA=body,
                bodyB=upper,
                anchor=(init_x, init_y + self.ARM_UP),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=-0.75 * 2 * np.pi,
                upperAngle=0,
            )

            upper.userData = CustomBodyUserData(False, name="upper_arm")
            self.body_parts.append(upper)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            lower = world.CreateDynamicBody(
                position=(init_x, init_y + self.LIMB_H * 3 / 2 + self.ARM_UP),
                # angle=(i * 0.05),
                fixtures=LOWER_LIMB_FD
            )
            lower.color1 = (0.6 - j / 10., 0.3 - j / 10., 0.5 - j / 10.)
            lower.color2 = (0.4 - j / 10., 0.2 - j / 10., 0.3 - j / 10.)
            rjd = revoluteJointDef(
                bodyA=upper,
                bodyB=lower,
                anchor=(init_x, init_y + self.LIMB_H + self.ARM_UP),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=0,
                upperAngle=0.75 * np.pi,
            )

            lower.userData = CustomBodyUserData(False, name="lower_arm")
            self.body_parts.append(lower)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            # hand
            prev_part = lower
            initial_y = init_y + self.LIMB_H * 2 + self.ARM_UP
            angle_boundaries = [[-0.5, 0.5]]
            nb_hand_parts = 1
            for u in range(nb_hand_parts):
                hand_part = world.CreateDynamicBody(
                    position=(init_x, initial_y + self.HAND_PART_H / 2 + self.HAND_PART_H * u),
                    fixtures=HAND_PART_FD
                )

                hand_part.color1 = (0.6 - j / 10., 0.3 - j / 10., 0.5 - j / 10.)
                hand_part.color2 = (0.4 - j / 10., 0.2 - j / 10., 0.3 - j / 10.)
                rjd = revoluteJointDef(
                    bodyA=prev_part,
                    bodyB=hand_part,
                    anchor=(init_x, initial_y + self.HAND_PART_H * u),
                    enableMotor=True,
                    enableLimit=True,
                    maxMotorTorque=self.MOTORS_TORQUE,
                    motorSpeed=1,
                    lowerAngle=angle_boundaries[u][0] * np.pi,
                    upperAngle=angle_boundaries[u][1] * np.pi,
                )

                hand_part.userData = CustomBodyUserData(True, name="hand")
                self.body_parts.append(hand_part)

                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(SPEED_HAND,
                                                           True,
                                                           contact_body=hand_part)
                self.motors.append(joint_motor)

                prev_part = hand_part

            hand_sensor_position = (init_x, initial_y + self.HAND_PART_H * nb_hand_parts)
            hand_sensor_part = world.CreateDynamicBody(
                position=hand_sensor_position,
                fixtures=self.SENSOR_FD,
                userData = CustomBodySensorUserData(True, False, "hand_sensor")
            )
            hand_sensor_part.color1 = (1, 0, 0)#(0.6 - j / 10., 0.3 - j / 10., 0.5 - j / 10.)
            hand_sensor_part.color2 = (1, 0, 0)#(0.4 - j / 10., 0.2 - j / 10., 0.3 - j / 10.)

            self.sensors.append(hand_sensor_part)
            world.CreateJoint(weldJointDef(
                bodyA = prev_part,
                bodyB = hand_sensor_part,
                anchor = hand_sensor_position
            ))



===== .\TeachMyAgent\environments\envs\bodies\climbers\ClimbingProfileChimpanzee.py =====
import numpy as np
from Box2D.b2 import edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener, weldJointDef

from TeachMyAgent.environments.envs.bodies.climbers.ClimberAbstractBody import ClimberAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData, CustomBodySensorUserData

SPEED_HIP     = 4
SPEED_KNEE    = 6
SPEED_HAND    = 8

class ClimbingProfileChimpanzee(ClimberAbstractBody):
    '''
        Climbing 'chimpanzee' embodiment.
    '''
    def __init__(self, scale, motors_torque=100, nb_steps_under_water=600):
        '''
            Creates a chimpanzee with:
            - a head
            - a chest
            - two arms (constituted of two limbs each)
            - two hands (constituted of one limbs each)
            - two sensors (each at the extremity of a hand) to detect collisions with graspable areas and grasp them.
            - two legs (constituted of two limbs each)

            No contact with ground is allowed.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                nb_steps_under_water: How many consecutive steps the embodiment can survive under water
        '''
        super(ClimbingProfileChimpanzee, self).__init__(scale, motors_torque, nb_steps_under_water)
        self.LEG_DOWN = 12 / self.SCALE
        self.ARM_UP = 22 / self.SCALE
        self.LIMB_W, self.LIMB_H = 8 / self.SCALE, 28 / self.SCALE
        self.HAND_PART_W, self.HAND_PART_H = 4 / self.SCALE, 8 / self.SCALE
        self.LEG_H = self.LIMB_H
        self.TORQUE_PENALTY = 0.00035 / 5 # Legs + arms + hands
        self.BODY_HEIGHT = 45
        self.HEAD_HEIGHT = 20

        self.AGENT_WIDTH = 24 / self.SCALE
        self.AGENT_HEIGHT = self.BODY_HEIGHT / self.SCALE + \
                            self.HEAD_HEIGHT / self.SCALE + 0.2 + \
                            self.LEG_H * 2 - self.LEG_DOWN
        self.AGENT_CENTER_HEIGHT = self.LEG_H * 2 + self.LEG_DOWN

        self.remove_reward_on_head_angle = True

    def draw(self, world, init_x, init_y, force_to_center):
        head = world.CreateDynamicBody(
            position=(init_x, init_y + self.BODY_HEIGHT / self.SCALE / 2 + self.HEAD_HEIGHT / self.SCALE / 2 + 0.2),
            fixtures=fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in [
                    (-5, +10), (+5, +10),
                    (+5, -10), (-5, -10)]]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x1
            )
        )
        head.color1 = (0.5, 0.4, 0.9)
        head.color2 = (0.3, 0.3, 0.5)
        head.ApplyForceToCenter((force_to_center, 0), True)

        head.userData = CustomBodyUserData(True, is_contact_critical=True, name="head")
        self.body_parts.append(head)
        self.reference_head_object = head

        body = world.CreateDynamicBody(
            position=(init_x, init_y),
            fixtures=fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in [
                    (-12, +25), (+12, +25),
                    (+8, -20), (-8, -20)]]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x1  # collide only with ground
            )
        )
        body.color1 = (0.5, 0.4, 0.9)
        body.color2 = (0.3, 0.3, 0.5)

        body.userData = CustomBodyUserData(True, is_contact_critical=True, name="body")
        self.body_parts.append(body)
        
        rjd = revoluteJointDef(
            bodyA=head,
            bodyB=body,
            anchor=(init_x, init_y + self.BODY_HEIGHT / self.SCALE / 2),
            enableMotor=False,
            enableLimit=True,
            lowerAngle=-0.1 * np.pi,
            upperAngle=0.1 * np.pi,
        )

        world.CreateJoint(rjd)

        UPPER_LIMB_FD = fixtureDef(
            shape=polygonShape(box=(self.LIMB_W / 2, self.LIMB_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x1
        )

        LOWER_LIMB_FD = fixtureDef(
            shape=polygonShape(box=(0.8 * self.LIMB_W / 2, self.LIMB_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x1
        )

        HAND_PART_FD = fixtureDef(
            shape=polygonShape(box=(self.HAND_PART_W / 2, self.HAND_PART_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x1
        )

        # LEGS
        for i in [+1, +1]:
                upper = world.CreateDynamicBody(
                    position=(init_x, init_y - self.LIMB_H / 2 - self.LEG_DOWN),
                    # angle=(i * 0.05),
                    fixtures=UPPER_LIMB_FD
                )
                upper.color1 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.)
                upper.color2 = (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
                rjd = revoluteJointDef(
                    bodyA=body,
                    bodyB=upper,
                    anchor=(init_x, init_y - self.LEG_DOWN),
                    enableMotor=True,
                    enableLimit=True,
                    maxMotorTorque=self.MOTORS_TORQUE,
                    motorSpeed=1,
                    lowerAngle=-0.3 * np.pi,
                    upperAngle=0.6 * np.pi,
                )

                upper.userData = CustomBodyUserData(False, name="upper_leg")
                self.body_parts.append(upper)

                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
                self.motors.append(joint_motor)

                lower = world.CreateDynamicBody(
                    position=(init_x, init_y - self.LIMB_H * 3 / 2 - self.LEG_DOWN),
                    # angle=(i * 0.05),
                    fixtures=LOWER_LIMB_FD
                )
                lower.color1 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.)
                lower.color2 = (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
                rjd = revoluteJointDef(
                    bodyA=upper,
                    bodyB=lower,
                    anchor=(init_x, init_y - self.LIMB_H - self.LEG_DOWN),
                    enableMotor=True,
                    enableLimit=True,
                    maxMotorTorque=self.MOTORS_TORQUE,
                    motorSpeed=1,
                    lowerAngle=-0.75 * np.pi,
                    upperAngle=-0.1,
                )

                lower.userData = CustomBodyUserData(True, name="lower_leg", is_contact_critical=True)
                self.body_parts.append(lower)

                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(SPEED_KNEE,
                                                           True,
                                                           contact_body=lower,
                                                           angle_correction=1.0)
                self.motors.append(joint_motor)

        # ARMS
        for j in [-1, -1]:
            upper = world.CreateDynamicBody(
                position=(init_x, init_y + self.LIMB_H / 2 + self.ARM_UP),
                # angle=(i * 0.05),
                fixtures=UPPER_LIMB_FD
            )
            upper.color1 = (0.6 - j / 10., 0.3 - j / 10., 0.5 - j / 10.)
            upper.color2 = (0.4 - j / 10., 0.2 - j / 10., 0.3 - j / 10.)
            rjd = revoluteJointDef(
                bodyA=body,
                bodyB=upper,
                anchor=(init_x, init_y + self.ARM_UP),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=-0.75 * 2 * np.pi,
                upperAngle=0,
            )

            upper.userData = CustomBodyUserData(False, name="upper_arm")
            self.body_parts.append(upper)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            lower = world.CreateDynamicBody(
                position=(init_x, init_y + self.LIMB_H * 3 / 2 + self.ARM_UP),
                # angle=(i * 0.05),
                fixtures=LOWER_LIMB_FD
            )
            lower.color1 = (0.6 - j / 10., 0.3 - j / 10., 0.5 - j / 10.)
            lower.color2 = (0.4 - j / 10., 0.2 - j / 10., 0.3 - j / 10.)
            rjd = revoluteJointDef(
                bodyA=upper,
                bodyB=lower,
                anchor=(init_x, init_y + self.LIMB_H + self.ARM_UP),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=0,
                upperAngle=0.75 * np.pi,
            )

            lower.userData = CustomBodyUserData(False, name="lower_arm")
            self.body_parts.append(lower)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            # hand
            prev_part = lower
            initial_y = init_y + self.LIMB_H * 2 + self.ARM_UP
            angle_boundaries = [[-0.5, 0.5]]
            nb_hand_parts = 1
            for u in range(nb_hand_parts):
                hand_part = world.CreateDynamicBody(
                    position=(init_x, initial_y + self.HAND_PART_H / 2 + self.HAND_PART_H * u),
                    fixtures=HAND_PART_FD
                )

                hand_part.color1 = (0.6 - j / 10., 0.3 - j / 10., 0.5 - j / 10.)
                hand_part.color2 = (0.4 - j / 10., 0.2 - j / 10., 0.3 - j / 10.)
                rjd = revoluteJointDef(
                    bodyA=prev_part,
                    bodyB=hand_part,
                    anchor=(init_x, initial_y + self.HAND_PART_H * u),
                    enableMotor=True,
                    enableLimit=True,
                    maxMotorTorque=self.MOTORS_TORQUE,
                    motorSpeed=1,
                    lowerAngle=angle_boundaries[u][0] * np.pi,
                    upperAngle=angle_boundaries[u][1] * np.pi,
                )

                hand_part.userData = CustomBodyUserData(True, name="hand")
                self.body_parts.append(hand_part)

                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(SPEED_HAND,
                                                           True,
                                                           contact_body=hand_part)
                self.motors.append(joint_motor)

                prev_part = hand_part

            hand_sensor_position = (init_x, initial_y + self.HAND_PART_H * nb_hand_parts)
            hand_sensor_part = world.CreateDynamicBody(
                position=hand_sensor_position,
                fixtures=self.SENSOR_FD,
                userData = CustomBodySensorUserData(True, False, "hand_sensor")
            )
            hand_sensor_part.color1 = (1, 0, 0)#(0.6 - j / 10., 0.3 - j / 10., 0.5 - j / 10.)
            hand_sensor_part.color2 = (1, 0, 0)#(0.4 - j / 10., 0.2 - j / 10., 0.3 - j / 10.)

            self.sensors.append(hand_sensor_part)
            world.CreateJoint(weldJointDef(
                bodyA = prev_part,
                bodyB = hand_sensor_part,
                anchor = hand_sensor_position
            ))



===== .\TeachMyAgent\environments\envs\bodies\climbers\__init__.py =====


===== .\TeachMyAgent\environments\envs\bodies\swimmers\FishBody.py =====
import numpy as np
from Box2D.b2 import edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener

from TeachMyAgent.environments.envs.bodies.swimmers.SwimmerAbstractBody import SwimmerAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData

# Head
HULL_POLYGONS = [
    (-20, +12), (+6, +12),
     (+15, +4), (+15, -4),
     (+6, -12), (-20, -12)
]

BODY_P1 = [
    (-8, +9), (+8, +12),
     (+8, -12), (-8, -9)
]

BODY_P2 = [
    (-8, +4), (+8, +9),
     (+8, -9), (-8, -4)
]

# Tail
BODY_P3 = [
    (-4, +2), (+4, +4),
     (+4, -4), (-4, -2)
]

FIN = [
    (-1, -10), (-1, +10),
     (+1, +10), (+1, -10)
]

HULL_BOTTOM_WIDTH = 35
SPEED_HIP     = 4
SPEED_KNEE    = 6

class FishBody(SwimmerAbstractBody):
    '''
        Swimming 'fish' embodiment.
    '''
    def __init__(self, scale, density, motors_torque=80, nb_steps_outside_water=600):
        '''
            Creates a fish with three body parts, a fin and a tale.

            Head contact is allowed for the fish.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                density: Water density (in order to make the agent in a zero-gravity-like setup)
                nb_steps_outside_water: How many consecutive steps the embodiment can survive outside water
        '''
        super(FishBody, self).__init__(scale, motors_torque, density, nb_steps_outside_water)
        self.TORQUE_PENALTY = 0.00035

        self.AGENT_WIDTH = HULL_BOTTOM_WIDTH / self.SCALE
        self.AGENT_HEIGHT = 18 /self.SCALE
        self.AGENT_CENTER_HEIGHT = 9 / self.SCALE

        self.remove_reward_on_head_angle = True

        self.fins = []
        self.tail = None

    def draw(self, world, init_x, init_y, force_to_center):
        init_y = init_y + 1
        #### HULL ####
        HULL_FD = fixtureDef(
            shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in HULL_POLYGONS]),
            density=self.DENSITY,
            friction=0.1,
            categoryBits=0x20,
            maskBits=0x000F)  # 0.99 bouncy

        hull = world.CreateDynamicBody(
            position=(init_x, init_y),
            fixtures=HULL_FD
        )
        hull.color1 = (0.5, 0.4, 0.9)
        hull.color2 = (0.3, 0.3, 0.5)
        # hull.ApplyForceToCenter((force_to_center, 0), True)

        hull.userData = CustomBodyUserData(True, is_contact_critical=False, name="head")
        self.body_parts.append(hull)
        self.reference_head_object = hull

        #### P1 ####
        body_p1_x = init_x - 35 / 2 / self.SCALE - 16 / 2 / self.SCALE
        BODY_P1_FD = fixtureDef(
            shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in BODY_P1]),
            density=self.DENSITY,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        body_p1 = world.CreateDynamicBody(
            position=(body_p1_x, init_y),
            fixtures=BODY_P1_FD
        )
        body_p1.color1 = (0.5, 0.4, 0.9)
        body_p1.color2 = (0.3, 0.3, 0.5)

        rjd = revoluteJointDef(
            bodyA=hull,
            bodyB=body_p1,
            anchor=(init_x - 35 / 2 / self.SCALE, init_y),
            enableMotor=True,
            enableLimit=True,
            maxMotorTorque=self.MOTORS_TORQUE,
            motorSpeed=1,
            lowerAngle=-0.1 * np.pi,
            upperAngle=0.2 * np.pi,
        )

        body_p1.userData = CustomBodyUserData(True, name="body")
        self.body_parts.append(body_p1)

        joint_motor = world.CreateJoint(rjd)
        joint_motor.userData = CustomMotorUserData(SPEED_KNEE, True, contact_body=body_p1)
        self.motors.append(joint_motor)

        #### P2 ####
        body_p2_x = body_p1_x - 16 / 2 / self.SCALE - 16 / 2 / self.SCALE
        BODY_P2_FD = fixtureDef(
            shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in BODY_P2]),
            density=self.DENSITY,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        body_p2 = world.CreateDynamicBody(
            position=(body_p2_x, init_y),
            fixtures=BODY_P2_FD
        )
        body_p2.color1 = (0.5, 0.4, 0.9)
        body_p2.color2 = (0.3, 0.3, 0.5)

        rjd = revoluteJointDef(
            bodyA=body_p1,
            bodyB=body_p2,
            anchor=(body_p1_x - 16 / 2 / self.SCALE, init_y),
            enableMotor=True,
            enableLimit=True,
            maxMotorTorque=self.MOTORS_TORQUE,
            motorSpeed=1,
            lowerAngle=-0.15 * np.pi,
            upperAngle=0.15 * np.pi,
        )

        body_p2.userData = CustomBodyUserData(True, name="body")
        self.body_parts.append(body_p2)

        joint_motor = world.CreateJoint(rjd)
        joint_motor.userData = CustomMotorUserData(SPEED_KNEE, True, contact_body=body_p2)
        self.motors.append(joint_motor)

        #### P3 ####
        body_p3_x = body_p2_x - 16 / 2 / self.SCALE - 8 / 2 / self.SCALE
        BODY_P3_FD = fixtureDef(
            shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in BODY_P3]),
            density=self.DENSITY,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        body_p3 = world.CreateDynamicBody(
            position=(body_p3_x, init_y),
            fixtures=BODY_P3_FD
        )
        body_p3.color1 = (0.5, 0.4, 0.9)
        body_p3.color2 = (0.3, 0.3, 0.5)

        rjd = revoluteJointDef(
            bodyA=body_p2,
            bodyB=body_p3,
            anchor=(body_p2_x - 16 / 2 / self.SCALE, init_y),
            enableMotor=True,
            enableLimit=True,
            maxMotorTorque=self.MOTORS_TORQUE,
            motorSpeed=1,
            lowerAngle=-0.3 * np.pi,
            upperAngle=0.3 * np.pi,
        )

        body_p3.userData = CustomBodyUserData(True, name="body")
        self.body_parts.append(body_p3)
        self.tail = body_p3

        joint_motor = world.CreateJoint(rjd)
        joint_motor.userData = CustomMotorUserData(SPEED_KNEE, True, contact_body=body_p3)
        self.motors.append(joint_motor)

        #### FIN ####
        FIN_FD = fixtureDef(
            shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in FIN]),
            density=self.DENSITY,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        fin_positions = [
            # [init_x + 35 / 2 / self.SCALE / 2, init_y],
            # [init_x - 35 / 2 / self.SCALE / 2, init_y],
            [init_x, init_y - 22 / 2 / self.SCALE + 0.2],
            # [init_x - 35 / 2 / self.SCALE / 2, init_y - 22 / 2 / self.SCALE + 0.1],
        ]

        fin_angle = -0.2 * np.pi
        middle_fin_x_distance = np.sin(fin_angle) * 20 / 2 / self.SCALE
        middle_fin_y_distance = np.cos(fin_angle) * 20 / 2 / self.SCALE

        for fin_pos in fin_positions:
            current_fin_x = fin_pos[0] + middle_fin_x_distance
            current_fin_y = fin_pos[1] - middle_fin_y_distance

            fin = world.CreateDynamicBody(
                position=(current_fin_x, current_fin_y),
                fixtures=FIN_FD,
                angle=fin_angle
            )
            fin.color1 = (0.5, 0.4, 0.9)
            fin.color2 = (0.3, 0.3, 0.5)

            rjd = revoluteJointDef(
                bodyA=hull,
                bodyB=fin,
                anchor=(fin_pos[0], fin_pos[1]),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=-0.3 * np.pi,
                upperAngle=0.2 * np.pi,
            )

            fin.userData = CustomBodyUserData(True, name="fin")
            self.body_parts.append(fin)
            self.fins.append(fin)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_KNEE, True, contact_body=fin)
            self.motors.append(joint_motor)

===== .\TeachMyAgent\environments\envs\bodies\swimmers\SwimmerAbstractBody.py =====
from TeachMyAgent.environments.envs.bodies.AbstractBody import AbstractBody
from TeachMyAgent.environments.envs.bodies.BodyTypesEnum import BodyTypesEnum

class SwimmerAbstractBody(AbstractBody):
    '''
        Base class for swimmers.
    '''
    def __init__(self, scale, motors_torque, density, nb_steps_outside_water):
        '''
            Creates a swimmer, which cannot survive outside water.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                density: Water density (in order to make the agent in a zero-gravity-like setup)
                nb_steps_outside_water: How many consecutive steps the embodiment can survive outside water
        '''
        super(SwimmerAbstractBody, self).__init__(scale, motors_torque)

        self.body_type = BodyTypesEnum.SWIMMER
        self.nb_steps_can_survive_outside_water = nb_steps_outside_water
        # set the embodiment's density to the same value as water so that it will be in a zero-gravity setup
        self.DENSITY = density - 0.01 # Make it a little lighter such that it slowly goes up when no action is done

===== .\TeachMyAgent\environments\envs\bodies\swimmers\__init__.py =====


===== .\TeachMyAgent\environments\envs\bodies\walkers\BigQuadruBody.py =====
import numpy as np
from Box2D.b2 import edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener

from TeachMyAgent.environments.envs.bodies.walkers.WalkerAbstractBody import WalkerAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData

HULL_POLYGONS = [
        [(-46, +13), (+6, +13), (+50, +5),
        (+50, -12), (-46, -12)]
    ]
HULL_BOTTOM_WIDTH = 96
SPEED_HIP     = 4
SPEED_KNEE    = 6

class BigQuadruBody(WalkerAbstractBody):
    '''
        New version of the Quadrupedal walker implemented in https://gym.openai.com/envs/BipedalWalker-v2/.

        In the initial version, the embodiment is created with an angle on legs, but position are not set according to this.
        This results in bodies with wrong positions that Box2D's solver has to reposition at the first step of the environment.
        This new version uses straight legs and fixed bad positions.
    '''
    def __init__(self, scale, motors_torque=300, nb_steps_under_water=600, reset_on_hull_critical_contact=False):
        '''
            Creates a bipedal walker

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                 nb_steps_under_water: How many consecutive steps the embodiment can survive under water
                reset_on_hull_critical_contact: Whether a contact detected with the head should stop the episode
        '''
        super(BigQuadruBody, self).__init__(scale, motors_torque, nb_steps_under_water)
        self.LEG_DOWN = 3 / self.SCALE  # 0 = center of hull
        self.LEG_W, self.LEG_H = 10 / self.SCALE, 51 / self.SCALE
        self.TORQUE_PENALTY = 0.00035 / 2 # 2 paris of legs
        self.reset_on_hull_critical_contact = reset_on_hull_critical_contact

        self.AGENT_WIDTH = HULL_BOTTOM_WIDTH / self.SCALE
        self.AGENT_HEIGHT = 25 / self.SCALE + \
                            self.LEG_H * 2 - self.LEG_DOWN
        self.AGENT_CENTER_HEIGHT = self.LEG_H * 2 + self.LEG_DOWN

    def draw(self, world, init_x, init_y, force_to_center):
        HULL_FIXTURES = [
            fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in polygon]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x000F)
            for polygon in HULL_POLYGONS
        ]

        LEG_FD = fixtureDef(
            shape=polygonShape(box=(self.LEG_W / 2, self.LEG_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        LOWER_FD = fixtureDef(
            shape=polygonShape(box=(0.8 * self.LEG_W / 2, self.LEG_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        hull = world.CreateDynamicBody(
            position=(init_x, init_y),
            fixtures=HULL_FIXTURES
        )

        hull.color1 = (0.5, 0.4, 0.9)
        hull.color2 = (0.3, 0.3, 0.5)
        hull.ApplyForceToCenter((force_to_center, 0), True)

        hull.userData = CustomBodyUserData(True, is_contact_critical=self.reset_on_hull_critical_contact, name="hull")
        self.body_parts.append(hull)
        self.reference_head_object = hull

        for x_anchor in [-0.7, 0.5]:
            absolute_x = init_x + np.interp(x_anchor, [-1,1], [-HULL_BOTTOM_WIDTH / 2 / self.SCALE, HULL_BOTTOM_WIDTH / 2 / self.SCALE])
            for i in [-1, +1]:
                leg = world.CreateDynamicBody(
                    position=(absolute_x, init_y - self.LEG_H / 2 - self.LEG_DOWN),
                    #angle=(i * 0.05),
                    fixtures=LEG_FD
                )
                leg.color1 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.)
                leg.color2 = (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
                rjd = revoluteJointDef(
                    bodyA=hull,
                    bodyB=leg,
                    anchor=(absolute_x, init_y - self.LEG_DOWN),
                    enableMotor=True,
                    enableLimit=True,
                    maxMotorTorque=self.MOTORS_TORQUE,
                    motorSpeed=i,
                    lowerAngle=-0.8,
                    upperAngle=1.1,
                )

                leg.userData = CustomBodyUserData(False, name="leg")
                self.body_parts.append(leg)

                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
                self.motors.append(joint_motor)

                lower = world.CreateDynamicBody(
                    position=(absolute_x, init_y - self.LEG_H * 3 / 2 - self.LEG_DOWN),
                    #angle=(i * 0.05),
                    fixtures=LOWER_FD
                )
                lower.color1 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.)
                lower.color2 = (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
                rjd = revoluteJointDef(
                    bodyA=leg,
                    bodyB=lower,
                    anchor=(absolute_x, init_y - self.LEG_DOWN - self.LEG_H),
                    enableMotor=True,
                    enableLimit=True,
                    maxMotorTorque=self.MOTORS_TORQUE,
                    motorSpeed=1,
                    lowerAngle=-1.6,
                    upperAngle=-0.1,
                )

                lower.userData = CustomBodyUserData(True, name="lower")
                self.body_parts.append(lower)

                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(
                    SPEED_KNEE,
                    True,
                    contact_body=lower,
                    angle_correction=1.0)
                self.motors.append(joint_motor)

===== .\TeachMyAgent\environments\envs\bodies\walkers\ClassicBipedalBody.py =====
import numpy as np
from Box2D.b2 import edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener

from TeachMyAgent.environments.envs.bodies.walkers.WalkerAbstractBody import WalkerAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData

HULL_POLYGONS = [
    [(-30, +9), (+6, +9), (+34, +1),
    (+34, -8), (-30, -8)]
]
HULL_BOTTOM_WIDTH = 64
SPEED_HIP     = 4
SPEED_KNEE    = 6

class ClassicBipedalBody(WalkerAbstractBody):
    '''
        New version of the Bipedal walker implemented in https://gym.openai.com/envs/BipedalWalker-v2/.

        In the initial version, the embodiment is created with an angle on legs, but position are not set according to this.
        This results in bodies with wrong positions that Box2D's solver has to reposition at the first step of the environment.
        This new version uses straight legs and fixed bad positions.
    '''
    def __init__(self, scale, motors_torque=80, nb_steps_under_water=600, reset_on_hull_critical_contact=False):
        '''
            Creates a bipedal walker.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                nb_steps_under_water: How many consecutive steps the embodiment can survive under water
                reset_on_hull_critical_contact: Whether a contact detected with the head should stop the episode
        '''
        super(ClassicBipedalBody, self).__init__(scale, motors_torque, nb_steps_under_water)
        self.LEG_DOWN = 3 / self.SCALE # 0 = center of hull
        self.LEG_W, self.LEG_H = 8 / self.SCALE, 34 / self.SCALE
        self.TORQUE_PENALTY = 0.00035
        self.reset_on_hull_critical_contact = reset_on_hull_critical_contact

        self.AGENT_WIDTH = HULL_BOTTOM_WIDTH / self.SCALE
        self.AGENT_HEIGHT = 17 / self.SCALE + \
                            self.LEG_H * 2 - self.LEG_DOWN
        self.AGENT_CENTER_HEIGHT = self.LEG_H * 2 + self.LEG_DOWN

    def draw(self, world, init_x, init_y, force_to_center):
        HULL_FIXTURES = [
            fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in polygon]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x000F)  # 0.99 bouncy
            for polygon in HULL_POLYGONS
        ]

        LEG_FD = fixtureDef(
            shape=polygonShape(box=(self.LEG_W / 2, self.LEG_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        LOWER_FD = fixtureDef(
            shape=polygonShape(box=(0.8 * self.LEG_W / 2, self.LEG_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        hull = world.CreateDynamicBody(
            position=(init_x, init_y),
            fixtures=HULL_FIXTURES
        )
        hull.color1 = (0.5, 0.4, 0.9)
        hull.color2 = (0.3, 0.3, 0.5)
        hull.ApplyForceToCenter((force_to_center, 0), True)

        hull.userData = CustomBodyUserData(True, is_contact_critical=self.reset_on_hull_critical_contact, name="hull")
        self.body_parts.append(hull)
        self.reference_head_object = hull

        for i in [-1, +1]:
            leg = world.CreateDynamicBody(
                position=(init_x, init_y - self.LEG_H / 2 - self.LEG_DOWN),
                #angle=(i * 0.05),#2¬∞
                fixtures=LEG_FD
            )
            leg.color1 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.)
            leg.color2 = (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
            rjd = revoluteJointDef(
                bodyA=hull,
                bodyB=leg,
                anchor=(init_x, init_y - self.LEG_DOWN),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=i,
                lowerAngle=-0.8,
                upperAngle=1.1,
            )

            leg.userData = CustomBodyUserData(False, name="leg")
            self.body_parts.append(leg)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            lower = world.CreateDynamicBody(
                position=(init_x, init_y - self.LEG_H * 3 / 2 - self.LEG_DOWN),
                #angle=(i * 0.05), #2¬∞
                fixtures=LOWER_FD
            )
            lower.color1 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.)
            lower.color2 = (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
            rjd = revoluteJointDef(
                bodyA=leg,
                bodyB=lower,
                anchor=(init_x, init_y - self.LEG_DOWN - self.LEG_H),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=-1.6,
                upperAngle=-0.1,
            )

            lower.userData = CustomBodyUserData(True, name="lower")
            self.body_parts.append(lower)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(
                SPEED_KNEE,
                True,
                contact_body=lower,
                angle_correction=1.0)
            self.motors.append(joint_motor)

===== .\TeachMyAgent\environments\envs\bodies\walkers\MillipedeBody.py =====
import numpy as np
from Box2D.b2 import edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener

from TeachMyAgent.environments.envs.bodies.walkers.WalkerAbstractBody import WalkerAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData

MAIN_BODY_POLYGONS = [
    [(-10, +10), (+10, +10),
     (+10, -10), (-10, -10)]
]
MAIN_BODY_BOTTOM_WIDTH = 20
SPEED_HIP     = 4
SPEED_KNEE    = 6

class MillipedeBody(WalkerAbstractBody):
    '''
        Millipede embodiment with controllable number of bodies.
    '''
    def __init__(self, scale, motors_torque=200, nb_of_bodies=4, nb_steps_under_water=600,
                 reset_on_hull_critical_contact=False):
        '''
            Creates a millipede walker.

            Each of its body has two legs. The head is considered as the rightmost body.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                nb_of_bodies: Number of square bodies the agent has
                 nb_steps_under_water: How many consecutive steps the embodiment can survive under water
                reset_on_hull_critical_contact: Whether a contact detected with the head should stop the episode
        '''
        super(MillipedeBody, self).__init__(scale, motors_torque, nb_steps_under_water)
        self.LEG_DOWN = 3 / self.SCALE  # 0 = center of hull
        self.LEG_W, self.LEG_H = 4 / self.SCALE, 10 / self.SCALE
        self.TORQUE_PENALTY = 0.00035
        self.reset_on_hull_critical_contact = reset_on_hull_critical_contact

        self.nb_of_bodies = nb_of_bodies
        self.TORQUE_PENALTY = 0.00035 / self.nb_of_bodies # 1 body = 1 pair of legs

        self.AGENT_WIDTH = MAIN_BODY_BOTTOM_WIDTH / self.SCALE * self.nb_of_bodies
        self.AGENT_HEIGHT = 20 / self.SCALE + \
                            self.LEG_H * 2 - self.LEG_DOWN
        self.AGENT_CENTER_HEIGHT = self.LEG_H * 2 + self.LEG_DOWN

    def draw(self, world, init_x, init_y, force_to_center):
        MAIN_BODY_FIXTURES = [
            fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in polygon]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x000F)
            for polygon in MAIN_BODY_POLYGONS
        ]
        LEG_FD = fixtureDef(shape=polygonShape(box=(self.LEG_W / 2, self.LEG_H / 2)), density=1.0, restitution=0.0, categoryBits=0x20, maskBits=0x000F)
        LOWER_FD = fixtureDef(shape=polygonShape(box=(0.8 * self.LEG_W / 2, self.LEG_H / 2)), density=1.0, restitution=0.0, categoryBits=0x20, maskBits=0x000F)

        # N√¢ng agent l√™n m·ªôt ch√∫t
        init_y = init_y + 2 / self.SCALE
        
        init_x = init_x - MAIN_BODY_BOTTOM_WIDTH / self.SCALE * self.nb_of_bodies / 2
        previous_main_body = None
        for j in range(self.nb_of_bodies):
            main_body_x = init_x + j * (MAIN_BODY_BOTTOM_WIDTH / self.SCALE)
            main_body = world.CreateDynamicBody(position=(main_body_x, init_y), fixtures=MAIN_BODY_FIXTURES)
            main_body.color1, main_body.color2 = (0.5, 0.4, 0.9), (0.3, 0.3, 0.5)
            main_body.ApplyForceToCenter((force_to_center, 0), True)
            main_body.userData = CustomBodyUserData(True, is_contact_critical=False, name="body")
            self.body_parts.append(main_body)

            for i in [-1, +1]:
                # ... (code t·∫°o ch√¢n gi·ªØ nguy√™n) ...
                leg = world.CreateDynamicBody(position=(main_body_x, init_y - self.LEG_H / 2 - self.LEG_DOWN), fixtures=LEG_FD)
                leg.color1, leg.color2 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.), (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
                rjd = revoluteJointDef(bodyA=main_body, bodyB=leg, anchor=(main_body_x, init_y - self.LEG_DOWN), enableMotor=True, enableLimit=True, maxMotorTorque=self.MOTORS_TORQUE, motorSpeed=i, lowerAngle=-0.8, upperAngle=1.1)
                leg.userData = CustomBodyUserData(False, name="leg")
                self.body_parts.append(leg)
                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
                self.motors.append(joint_motor)
                lower = world.CreateDynamicBody(position=(main_body_x, init_y - self.LEG_H * 3 / 2 - self.LEG_DOWN), fixtures=LOWER_FD)
                lower.color1, lower.color2 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.), (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
                rjd = revoluteJointDef(bodyA=leg, bodyB=lower, anchor=(main_body_x, init_y - self.LEG_DOWN - self.LEG_H), enableMotor=True, enableLimit=True, maxMotorTorque=self.MOTORS_TORQUE, motorSpeed=1, lowerAngle=-1.6, upperAngle=-0.1)
                lower.userData = CustomBodyUserData(True, name="lower")
                self.body_parts.append(lower)
                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(SPEED_KNEE, True, contact_body=lower, angle_correction=1.0)
                self.motors.append(joint_motor)

            if previous_main_body is not None:
                # Kh·ªõp n·ªëi linh ho·∫°t
                rjd = revoluteJointDef(bodyA=previous_main_body, bodyB=main_body, anchor=(main_body_x - MAIN_BODY_BOTTOM_WIDTH / self.SCALE / 2, init_y), enableMotor=False, enableLimit=True, lowerAngle=-0.2 * np.pi, upperAngle=0.2 * np.pi)
                world.CreateJoint(rjd)
            previous_main_body = main_body

        self.reference_head_object = previous_main_body
        self.reference_head_object.userData.is_contact_critical = self.reset_on_hull_critical_contact

===== .\TeachMyAgent\environments\envs\bodies\walkers\ProfileChimpanzee.py =====
import numpy as np
from Box2D.b2 import edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener, weldJointDef

from TeachMyAgent.environments.envs.bodies.walkers.WalkerAbstractBody import WalkerAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData, CustomBodySensorUserData

SPEED_HIP     = 4
SPEED_KNEE    = 6
SPEED_HAND    = 8

class ProfileChimpanzee(WalkerAbstractBody):
    '''
        Walking chimpanzee embodiment.
    '''
    def __init__(self, scale, motors_torque=100, nb_steps_under_water=600, reset_on_hull_critical_contact=False):
        '''
            Creates a chimpanzee walker.

            The morphology has:
            - a head
            - a chest
            - two legs
            - two arms
            - two hands (with 3 limbs)

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                nb_of_bodies: Number of square bodies the agent has
                 nb_steps_under_water: How many consecutive steps the embodiment can survive under water
                reset_on_hull_critical_contact: Whether a contact detected with the head should stop the episode
        '''
        super(ProfileChimpanzee, self).__init__(scale, motors_torque, nb_steps_under_water)
        self.LEG_DOWN = 12 / self.SCALE
        self.ARM_UP = 22 / self.SCALE
        self.LIMB_W, self.LIMB_H = 8 / self.SCALE, 28 / self.SCALE
        self.HAND_PART_W, self.HAND_PART_H = 4 / self.SCALE, 8 / self.SCALE
        self.LEG_H = self.LIMB_H
        self.TORQUE_PENALTY = 0.00035 / 5 # Legs + arms + hands
        self.BODY_HEIGHT = 45
        self.HEAD_HEIGHT = 20
        self.reset_on_hull_critical_contact = reset_on_hull_critical_contact

        self.AGENT_WIDTH = 24 / self.SCALE
        self.AGENT_HEIGHT = self.BODY_HEIGHT / self.SCALE + \
                            self.HEAD_HEIGHT / self.SCALE + 0.2 + \
                            self.LEG_H * 2 - self.LEG_DOWN
        self.AGENT_CENTER_HEIGHT = self.LEG_H * 2 + self.LEG_DOWN

        self.remove_reward_on_head_angle = True

    def draw(self, world, init_x, init_y, force_to_center):
        head = world.CreateDynamicBody(
            position=(init_x, init_y + self.BODY_HEIGHT / self.SCALE / 2 + self.HEAD_HEIGHT / self.SCALE / 2 + 0.2),
            fixtures=fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in [
                    (-5, +10), (+5, +10),
                    (+5, -10), (-5, -10)]]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x1
            )
        )
        head.color1 = (0.5, 0.4, 0.9)
        head.color2 = (0.3, 0.3, 0.5)
        head.ApplyForceToCenter((force_to_center, 0), True)

        head.userData = CustomBodyUserData(True, is_contact_critical=True, name="head")
        self.body_parts.append(head)
        self.reference_head_object = head

        body = world.CreateDynamicBody(
            position=(init_x, init_y),
            fixtures=fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in [
                    (-12, +25), (+12, +25),
                    (+8, -15), (-8, --15)]]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x1  # collide only with ground
            )
        )
        body.color1 = (0.5, 0.4, 0.9)
        body.color2 = (0.3, 0.3, 0.5)

        body.userData = CustomBodyUserData(True, is_contact_critical=self.reference_head_object, name="body")
        self.body_parts.append(body)
        
        rjd = revoluteJointDef(
            bodyA=head,
            bodyB=body,
            anchor=(init_x, init_y + self.BODY_HEIGHT / self.SCALE / 2),
            enableMotor=False,
            enableLimit=True,
            lowerAngle=-0.1 * np.pi,
            upperAngle=0.1 * np.pi,
        )

        world.CreateJoint(rjd)

        UPPER_LIMB_FD = fixtureDef(
            shape=polygonShape(box=(self.LIMB_W / 2, self.LIMB_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x1
        )

        LOWER_LIMB_FD = fixtureDef(
            shape=polygonShape(box=(0.8 * self.LIMB_W / 2, self.LIMB_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x1
        )

        HAND_PART_FD = fixtureDef(
            shape=polygonShape(box=(self.HAND_PART_W / 2, self.HAND_PART_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x1
        )

        # LEGS
        for i in [+1, +1]:
                upper = world.CreateDynamicBody(
                    position=(init_x, init_y - self.LIMB_H / 2 - self.LEG_DOWN),
                    # angle=(i * 0.05),
                    fixtures=UPPER_LIMB_FD
                )
                upper.color1 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.)
                upper.color2 = (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
                rjd = revoluteJointDef(
                    bodyA=body,
                    bodyB=upper,
                    anchor=(init_x, init_y - self.LEG_DOWN),
                    enableMotor=True,
                    enableLimit=True,
                    maxMotorTorque=self.MOTORS_TORQUE,
                    motorSpeed=1,
                    lowerAngle=-0.3 * np.pi,
                    upperAngle=0.6 * np.pi,
                )

                upper.userData = CustomBodyUserData(False, name="upper_leg")
                self.body_parts.append(upper)

                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
                self.motors.append(joint_motor)

                lower = world.CreateDynamicBody(
                    position=(init_x, init_y - self.LIMB_H * 3 / 2 - self.LEG_DOWN),
                    # angle=(i * 0.05),
                    fixtures=LOWER_LIMB_FD
                )
                lower.color1 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.)
                lower.color2 = (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
                rjd = revoluteJointDef(
                    bodyA=upper,
                    bodyB=lower,
                    anchor=(init_x, init_y - self.LIMB_H - self.LEG_DOWN),
                    enableMotor=True,
                    enableLimit=True,
                    maxMotorTorque=self.MOTORS_TORQUE,
                    motorSpeed=1,
                    lowerAngle=-0.75 * np.pi,
                    upperAngle=-0.1,
                )

                lower.userData = CustomBodyUserData(True, name="lower_leg")
                self.body_parts.append(lower)

                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(SPEED_KNEE,
                                                           True,
                                                           contact_body=lower,
                                                           angle_correction=1.0)
                self.motors.append(joint_motor)

        # ARMS
        for j in [-1, -1]:
            upper = world.CreateDynamicBody(
                position=(init_x, init_y - self.LIMB_H / 2 + self.ARM_UP),
                # angle=(i * 0.05),
                fixtures=UPPER_LIMB_FD
            )
            upper.color1 = (0.6 - j / 10., 0.3 - j / 10., 0.5 - j / 10.)
            upper.color2 = (0.4 - j / 10., 0.2 - j / 10., 0.3 - j / 10.)
            rjd = revoluteJointDef(
                bodyA=body,
                bodyB=upper,
                anchor=(init_x, init_y + self.ARM_UP),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=-0.5 * np.pi,
                upperAngle=0.8 * np.pi,
            )

            upper.userData = CustomBodyUserData(False, name="upper_arm")
            self.body_parts.append(upper)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            lower = world.CreateDynamicBody(
                position=(init_x, init_y - self.LIMB_H * 3 / 2 + self.ARM_UP),
                # angle=(i * 0.05),
                fixtures=LOWER_LIMB_FD
            )
            lower.color1 = (0.6 - j / 10., 0.3 - j / 10., 0.5 - j / 10.)
            lower.color2 = (0.4 - j / 10., 0.2 - j / 10., 0.3 - j / 10.)
            rjd = revoluteJointDef(
                bodyA=upper,
                bodyB=lower,
                anchor=(init_x, init_y - self.LIMB_H + self.ARM_UP),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=0,
                upperAngle=0.75 * np.pi,
            )

            lower.userData = CustomBodyUserData(False, name="lower_arm")
            self.body_parts.append(lower)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            # hand
            prev_part = lower
            initial_y = init_y - self.LIMB_H * 2 + self.ARM_UP
            angle_boundaries = [[-0.4, 0.35], [-0.5, 0], [-0.8, 0]]
            nb_hand_parts = 3
            for u in range(nb_hand_parts):
                hand_part = world.CreateDynamicBody(
                    position=(init_x, initial_y - self.HAND_PART_H / 2 - self.HAND_PART_H * u),
                    fixtures=HAND_PART_FD
                )

                hand_part.color1 = (0.6 - j / 10., 0.3 - j / 10., 0.5 - j / 10.)
                hand_part.color2 = (0.4 - j / 10., 0.2 - j / 10., 0.3 - j / 10.)
                rjd = revoluteJointDef(
                    bodyA=prev_part,
                    bodyB=hand_part,
                    anchor=(init_x, initial_y - self.HAND_PART_H * u),
                    enableMotor=True,
                    enableLimit=True,
                    maxMotorTorque=self.MOTORS_TORQUE,
                    motorSpeed=1,
                    lowerAngle=angle_boundaries[u][0] * np.pi,
                    upperAngle=angle_boundaries[u][1] * np.pi,
                )

                hand_part.userData = CustomBodyUserData(True, name="hand")
                self.body_parts.append(hand_part)

                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(SPEED_HAND,
                                                           True,
                                                           contact_body=hand_part)
                self.motors.append(joint_motor)

                prev_part = hand_part



===== .\TeachMyAgent\environments\envs\bodies\walkers\SmallBipedalBody.py =====
from Box2D.b2 import fixtureDef, polygonShape, revoluteJointDef
from TeachMyAgent.environments.envs.bodies.walkers.WalkerAbstractBody import WalkerAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData

HULL_POLYGONS = [
    [(-15, +5), (+15, +5), (+15, -5), (-15, -5)]
]
HULL_BOTTOM_WIDTH = 30
HULL_DENSITY = 2.0

SPEED_HIP     = 4
SPEED_KNEE    = 6

class SmallBipedalBody(WalkerAbstractBody):
    def __init__(self, scale, motors_torque=80, nb_steps_under_water=600, reset_on_hull_critical_contact=False):
        super(SmallBipedalBody, self).__init__(scale, motors_torque, nb_steps_under_water)
        self.LEG_DOWN = 3 / self.SCALE
        self.LEG_W, self.LEG_H = 8 / self.SCALE, 17 / self.SCALE
        self.TORQUE_PENALTY = 0.00035
        self.reset_on_hull_critical_contact = reset_on_hull_critical_contact
        self.AGENT_WIDTH = HULL_BOTTOM_WIDTH / self.SCALE
        self.AGENT_HEIGHT = 10 / self.SCALE + self.LEG_H * 2 - self.LEG_DOWN
        self.AGENT_CENTER_HEIGHT = self.LEG_H * 2 + self.LEG_DOWN

    def draw(self, world, init_x, init_y, force_to_center):
        HULL_FIXTURES = [
            fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in polygon]),
                density=HULL_DENSITY,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x000F)
            for polygon in HULL_POLYGONS
        ]
        LEG_FD = fixtureDef(shape=polygonShape(box=(self.LEG_W / 2, self.LEG_H / 2)), density=1.0, restitution=0.0, categoryBits=0x20, maskBits=0x000F)
        LOWER_FD = fixtureDef(shape=polygonShape(box=(0.8 * self.LEG_W / 2, self.LEG_H / 2)), density=1.0, restitution=0.0, categoryBits=0x20, maskBits=0x000F)

        hull = world.CreateDynamicBody(position=(init_x, init_y), fixtures=HULL_FIXTURES)
        hull.color1, hull.color2 = (0.5, 0.4, 0.9), (0.3, 0.3, 0.5)
        hull.ApplyForceToCenter((force_to_center, 0), True)
        hull.userData = CustomBodyUserData(True, is_contact_critical=self.reset_on_hull_critical_contact, name="hull")
        self.body_parts.append(hull)
        self.reference_head_object = hull

        for i in [-1, +1]:
            leg = world.CreateDynamicBody(position=(init_x, init_y - self.LEG_H / 2 - self.LEG_DOWN), fixtures=LEG_FD)
            leg.color1, leg.color2 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.), (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
            rjd = revoluteJointDef(bodyA=hull, bodyB=leg, anchor=(init_x, init_y - self.LEG_DOWN), enableMotor=True, enableLimit=True, maxMotorTorque=self.MOTORS_TORQUE, motorSpeed=i, lowerAngle=-0.8, upperAngle=1.1)
            leg.userData = CustomBodyUserData(False, name="leg")
            self.body_parts.append(leg)
            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            lower = world.CreateDynamicBody(position=(init_x, init_y - self.LEG_H * 3 / 2 - self.LEG_DOWN), fixtures=LOWER_FD)
            lower.color1, lower.color2 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.), (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
            rjd = revoluteJointDef(bodyA=leg, bodyB=lower, anchor=(init_x, init_y - self.LEG_DOWN - self.LEG_H), enableMotor=True, enableLimit=True, maxMotorTorque=self.MOTORS_TORQUE, motorSpeed=1, lowerAngle=-1.6, upperAngle=-0.1)
            lower.userData = CustomBodyUserData(True, name="lower")
            self.body_parts.append(lower)
            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_KNEE, True, contact_body=lower, angle_correction=1.0)
            self.motors.append(joint_motor)

===== .\TeachMyAgent\environments\envs\bodies\walkers\SpiderBody.py =====
import numpy as np
from Box2D.b2 import edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener

from TeachMyAgent.environments.envs.bodies.walkers.WalkerAbstractBody import WalkerAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData

MAIN_BODY_POLYGONS = [
    [(-10, +10), (+10, +10),
    (+10, -10), (-10, -10)]
]
MAIN_BODY_BOTTOM_WIDTH = 20
SPEED_HIP     = 4
SPEED_KNEE    = 6

class SpiderBody(WalkerAbstractBody):
    '''
        Walking spider embodiment.
    '''
    def __init__(self, scale, motors_torque=100, nb_pairs_of_legs=2, nb_steps_under_water=600,
                 reset_on_hull_critical_contact=False):
        '''
            Creates a spider with `n` pair of legs.

            Each legs has 3 parts.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                nb_pairs_of_legs: Number of pair of legs the agent has
                 nb_steps_under_water: How many consecutive steps the embodiment can survive under water
                reset_on_hull_critical_contact: Whether a contact detected with the head should stop the episode
        '''
        super(SpiderBody, self).__init__(scale, motors_torque, nb_steps_under_water)
        self.LEG_DOWN = 4 / self.SCALE
        self.LEG_W, self.LEG_H = 6 / self.SCALE, 20 / self.SCALE
        self.reset_on_hull_critical_contact = reset_on_hull_critical_contact

        self.nb_pairs_of_legs = nb_pairs_of_legs

        self.TORQUE_PENALTY = 0.00035 / self.nb_pairs_of_legs

        # not exact but works
        self.AGENT_WIDTH = MAIN_BODY_BOTTOM_WIDTH / self.SCALE + \
                           self.LEG_H * 4
        self.AGENT_HEIGHT = 20 / self.SCALE + \
                            self.LEG_H * 2
        self.AGENT_CENTER_HEIGHT = self.LEG_H + self.LEG_DOWN

    def draw(self, world, init_x, init_y, force_to_center):
        ''' Circular body
        MAIN_BODY_FIXTURES = fixtureDef(
            shape=circleShape(radius=0.4),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F
        )

        '''
        MAIN_BODY_FIXTURES = [
            fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in polygon]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x000F)
            for polygon in MAIN_BODY_POLYGONS
        ]

        LEG_FD = fixtureDef(
            shape=polygonShape(box=(self.LEG_W / 2, self.LEG_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        LOWER_FD = fixtureDef(
            shape=polygonShape(box=(0.8 * self.LEG_W / 2, self.LEG_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        main_body = world.CreateDynamicBody(
            position=(init_x, init_y),
            fixtures=MAIN_BODY_FIXTURES
        )

        basis_color1 = (0.6, 0.3, 0.5)
        basis_color2 = (0.4, 0.2, 0.3)
        main_body.color1 = tuple([c - 0.1 for c in basis_color1])
        main_body.color2 = tuple([c - 0.1 for c in basis_color2])
        leg_color1 = tuple([c + 0.1 for c in basis_color1])
        leg_color2 = tuple([c + 0.1 for c in basis_color2])

        main_body.ApplyForceToCenter((force_to_center, 0), True)

        main_body.userData = CustomBodyUserData(True, is_contact_critical=self.reset_on_hull_critical_contact, name="main_body")
        self.body_parts.append(main_body)
        self.reference_head_object = main_body


        for i in [+1, -1] * self.nb_pairs_of_legs:
            ##### First part of the leg #####
            upper_leg_angle = 0.15 * np.pi * i 
            upper_leg_x_distance = np.sin(upper_leg_angle) * self.LEG_H / 2
            upper_leg_y_distance = np.cos(upper_leg_angle) * self.LEG_H / 2
            upper_leg_x = init_x - i * MAIN_BODY_BOTTOM_WIDTH / self.SCALE / 2 - upper_leg_x_distance
            upper_leg_y = init_y + upper_leg_y_distance - self.LEG_DOWN

            upper_leg = world.CreateDynamicBody(
                position=(upper_leg_x, upper_leg_y),
                angle=upper_leg_angle,
                fixtures=LEG_FD
            )
            upper_leg.color1 = leg_color1
            upper_leg.color2 = leg_color2

            rjd = revoluteJointDef(
                bodyA=main_body,
                bodyB=upper_leg,
                anchor=(init_x - i * MAIN_BODY_BOTTOM_WIDTH / self.SCALE / 2,
                        init_y - self.LEG_DOWN),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=-0.1*np.pi,
                upperAngle=0.1*np.pi,
            )

            upper_leg.userData = CustomBodyUserData(False, name="upper_leg")
            self.body_parts.append(upper_leg)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            ##### Second part of the leg #####
            middle_leg_angle = 0.5 * np.pi * i
            middle_leg_x_distance = np.sin(middle_leg_angle) * self.LEG_H / 2
            middle_leg_y_distance = -np.cos(middle_leg_angle) * self.LEG_H / 2
            middle_leg_x = upper_leg_x - upper_leg_x_distance - middle_leg_x_distance
            middle_leg_y = upper_leg_y + upper_leg_y_distance - middle_leg_y_distance
            middle_leg = world.CreateDynamicBody(
                position=(middle_leg_x, middle_leg_y),
                angle=middle_leg_angle,
                fixtures=LEG_FD
            )
            middle_leg.color1 = leg_color1
            middle_leg.color2 = leg_color2

            rjd = revoluteJointDef(
                bodyA=upper_leg,
                bodyB=middle_leg,
                anchor=(upper_leg_x - upper_leg_x_distance,
                        upper_leg_y + upper_leg_y_distance),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=-0.15*np.pi,
                upperAngle=0.15*np.pi,
            )

            middle_leg.userData = CustomBodyUserData(False, name="middle_leg")
            self.body_parts.append(middle_leg)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            ##### Third part of the leg #####
            lower_leg_angle = 0.7 * np.pi * i
            lower_leg_x_distance = np.sin(lower_leg_angle) * self.LEG_H / 2
            lower_leg_y_distance = -np.cos(lower_leg_angle) * self.LEG_H / 2
            lower_leg_x = middle_leg_x - middle_leg_x_distance - lower_leg_x_distance
            lower_leg_y = middle_leg_y - middle_leg_y_distance - lower_leg_y_distance
            lower_leg = world.CreateDynamicBody(
                position=(lower_leg_x, lower_leg_y),
                angle=lower_leg_angle,
                fixtures=LOWER_FD
            )
            lower_leg.color1 = leg_color1
            lower_leg.color2 = leg_color2

            rjd = revoluteJointDef(
                bodyA=middle_leg,
                bodyB=lower_leg,
                anchor=(middle_leg_x - middle_leg_x_distance,
                        middle_leg_y - middle_leg_y_distance ),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=-0.2*np.pi,
                upperAngle=0.2*np.pi,
            )

            lower_leg.userData = CustomBodyUserData(True, name="lower_leg")
            self.body_parts.append(lower_leg)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_KNEE,
                                                       True,
                                                       contact_body=lower_leg)
            self.motors.append(joint_motor)


===== .\TeachMyAgent\environments\envs\bodies\walkers\WalkerAbstractBody.py =====
from TeachMyAgent.environments.envs.bodies.AbstractBody import AbstractBody
from TeachMyAgent.environments.envs.bodies.BodyTypesEnum import BodyTypesEnum

class WalkerAbstractBody(AbstractBody):
    '''
        Base class for walkers.
    '''
    def __init__(self, scale, motors_torque, nb_steps_under_water):
        '''
            Creates a walker, which cannot survive under water.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                nb_steps_under_water: How many consecutive steps the embodiment can survive under water
        '''
        super(WalkerAbstractBody, self).__init__(scale, motors_torque)

        self.body_type = BodyTypesEnum.WALKER
        self.nb_steps_can_survive_under_water = nb_steps_under_water

===== .\TeachMyAgent\environments\envs\bodies\walkers\WheelBody.py =====
import numpy as np
import math
from Box2D.b2 import edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener

from TeachMyAgent.environments.envs.bodies.walkers.WalkerAbstractBody import WalkerAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData

MAIN_BODY_POLYGONS = [
    [(-10, +10), (+10, +10),
    (+10, -10), (-10, -10)]
]
HULL_BOTTOM_WIDTH = 20
SPEED_HIP     = 4
SPEED_KNEE    = 6

class WheelBody(WalkerAbstractBody):
    '''
        Walking 'wheel' embodiment.
    '''
    def __init__(self, scale, motors_torque=500, body_scale=1, nb_steps_under_water=600,
                 reset_on_hull_critical_contact=False):
        '''
            Creates an embodiment with a square hull and a pair of leg at each of its side.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                body_scale: If the hull must be reduced or increased (1 means leave it as it is)
                 nb_steps_under_water: How many consecutive steps the embodiment can survive under water
                reset_on_hull_critical_contact: Whether a contact detected with the head should stop the episode
        '''
        super(WheelBody, self).__init__(scale, motors_torque, nb_steps_under_water)
        self.LEG_W, self.LEG_H = 4 / self.SCALE, 10 / self.SCALE
        self.TORQUE_PENALTY = 0.00035 / 2 # 4 legs = 2 pair of legs
        self.reset_on_hull_critical_contact = reset_on_hull_critical_contact

        self.body_scale = body_scale

        self.AGENT_WIDTH = HULL_BOTTOM_WIDTH * self.body_scale / self.SCALE
        self.AGENT_HEIGHT = 20 * self.body_scale / self.SCALE + \
                            self.LEG_H * 4
        self.AGENT_CENTER_HEIGHT = 20 * self.body_scale / self.SCALE / 2 + \
                                   self.LEG_H * 2

        self.remove_reward_on_head_angle = True

    def draw(self, world, init_x, init_y, force_to_center):
        ''' Circular body
        MAIN_BODY_FIXTURES = fixtureDef(
            shape=circleShape(radius=0.4),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F
        )
        '''
        MAIN_BODY_FIXTURES = [
            fixtureDef(
                shape=polygonShape(vertices=[(x * self.body_scale / self.SCALE, y * self.body_scale / self.SCALE) for x, y in polygon]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x000F)
            for polygon in MAIN_BODY_POLYGONS
        ]

        LEG_FD = fixtureDef(
            shape=polygonShape(box=(self.LEG_W / 2, self.LEG_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        LOWER_FD = fixtureDef(
            shape=polygonShape(box=(0.8 * self.LEG_W / 2, self.LEG_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        main_body = world.CreateDynamicBody(
            position=(init_x, init_y),
            fixtures=MAIN_BODY_FIXTURES
        )

        basis_color1 = (0.6, 0.3, 0.5)
        basis_color2 = (0.4, 0.2, 0.3)
        main_body.color1 = tuple([c - 0.1 for c in basis_color1])
        main_body.color2 = tuple([c - 0.1 for c in basis_color2])
        leg_color1 = tuple([c + 0.1 for c in basis_color1])
        leg_color2 = tuple([c + 0.1 for c in basis_color2])

        main_body.ApplyForceToCenter((force_to_center, 0), True)

        main_body.userData = CustomBodyUserData(True, is_contact_critical=self.reset_on_hull_critical_contact, name="main_body")
        self.body_parts.append(main_body)
        self.reference_head_object = main_body

        for j in [[0, -1, 0], [0, 1, 0],[-1, 0, np.pi/2], [1, 0, np.pi/2]]:
            x_position = j[0] * (HULL_BOTTOM_WIDTH * self.body_scale / self.SCALE / 2)
            y_position = j[1] * (HULL_BOTTOM_WIDTH * self.body_scale / self.SCALE / 2)
            # for i in [-1, +1]:
            leg_x = init_x + j[0] * (self.LEG_H / 2) + x_position
            leg_y = init_y + j[1] * (self.LEG_H / 2) + y_position
            leg = world.CreateDynamicBody(
                position=(leg_x, leg_y),
                angle=(j[2]),
                fixtures=LEG_FD
            )
            leg.color1 = leg_color1
            leg.color2 = leg_color2
            rjd = revoluteJointDef(
                bodyA=main_body,
                bodyB=leg,
                anchor=(init_x + x_position, init_y + y_position),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=-0.8,
                upperAngle=1.1,
            )

            leg.userData = CustomBodyUserData(False, name="leg")
            self.body_parts.append(leg)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            lower = world.CreateDynamicBody(
                position=(leg_x + j[0] * (self.LEG_H),
                          leg_y + j[1] * (self.LEG_H)),
                angle=(j[2]),
                fixtures=LOWER_FD
            )
            lower.color1 = leg_color1
            lower.color2 = leg_color2
            rjd = revoluteJointDef(
                bodyA=leg,
                bodyB=lower,
                anchor=(leg_x + j[0] * (self.LEG_H / 2),
                        leg_y + j[1] * (self.LEG_H / 2)),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=-1.6,
                upperAngle=-0.1,
            )

            lower.userData = CustomBodyUserData(True, name="lower")
            self.body_parts.append(lower)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(
                SPEED_KNEE,
                True,
                contact_body=lower,
                angle_correction=1.0)
            self.motors.append(joint_motor)

===== .\TeachMyAgent\environments\envs\bodies\walkers\__init__.py =====


===== .\TeachMyAgent\environments\envs\bodies\walkers\old\OldBigQuadruBody.py =====
# Taken from https://github.com/flowersteam/teachDeepRL

import numpy as np
from Box2D.b2 import edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener

from TeachMyAgent.environments.envs.bodies.walkers.WalkerAbstractBody import WalkerAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData

HULL_POLYGONS = [
        [(-46, +13), (+6, +13), (+50, +5),
        (+50, -12), (-46, -12)]
    ]
HULL_BOTTOM_WIDTH = 96
SPEED_HIP     = 4
SPEED_KNEE    = 6

class OldBigQuadruBody(WalkerAbstractBody):
    '''
        Quadrupedal walker implemented in https://github.com/flowersteam/teachDeepRL.
    '''
    def __init__(self, scale, motors_torque=300, nb_steps_under_water=600, reset_on_hull_critical_contact=False):
        '''
            Creates a big quadrupedal walker.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                motors_torque: Maximum torque the embodiment can use on its motors
                 nb_steps_under_water: How many consecutive steps the embodiment can survive under water
                reset_on_hull_critical_contact: Whether a contact detected with the head should stop the episode
        '''
        super(OldBigQuadruBody, self).__init__(scale, motors_torque, nb_steps_under_water)
        self.LEG_DOWN = -8 / self.SCALE  # 0 = center of hull
        self.LEG_W, self.LEG_H = 10 / self.SCALE, 51 / self.SCALE
        self.TORQUE_PENALTY = 0.00035 / 2 # Because 2 pairs of legs
        self.reset_on_hull_critical_contact = reset_on_hull_critical_contact

        # Approximative...
        self.AGENT_WIDTH = HULL_BOTTOM_WIDTH / self.SCALE
        self.AGENT_HEIGHT = 25 / self.SCALE + \
                            self.LEG_H * 2 - self.LEG_DOWN
        self.AGENT_CENTER_HEIGHT = self.LEG_H * 2 + self.LEG_DOWN

        self.old_morphology = True

        self.nb_motors = 8
        self.state_size = self.nb_motors * 2 + 4

    def draw(self, world, init_x, init_y, force_to_center):
        HULL_FIXTURES = [
            fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in polygon]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x000F)
            for polygon in HULL_POLYGONS
        ]
        LEG_FD = fixtureDef(shape=polygonShape(box=(self.LEG_W / 2, self.LEG_H / 2)), density=1.0, restitution=0.0, categoryBits=0x20, maskBits=0x000F)
        LOWER_FD = fixtureDef(shape=polygonShape(box=(0.8 * self.LEG_W / 2, self.LEG_H / 2)), density=1.0, restitution=0.0, categoryBits=0x20, maskBits=0x000F)

        hull = world.CreateDynamicBody(position=(init_x, init_y), fixtures=HULL_FIXTURES)
        hull.color1, hull.color2 = (0.5, 0.4, 0.9), (0.3, 0.3, 0.5)
        hull.ApplyForceToCenter((force_to_center, 0), True)
        hull.userData = CustomBodyUserData(True, is_contact_critical=self.reset_on_hull_critical_contact, name="hull")
        self.body_parts.append(hull)
        self.reference_head_object = hull

        # ===== B·∫ÆT ƒê·∫¶U S·ª¨A L·ªñI V·∫¨T L√ù =====
        # S·ª≠ d·ª•ng logic t√≠nh to√°n v·ªã tr√≠ tuy·ªát ƒë·ªëi ƒë·ªÉ tƒÉng ƒë·ªô ·ªïn ƒë·ªãnh
        for x_anchor_rel in [-0.7, 0.5]: # T·ª∑ l·ªá v·ªã tr√≠ m·ªè neo tr√™n th√¢n
            absolute_x = init_x + np.interp(x_anchor_rel, [-1,1], [-HULL_BOTTOM_WIDTH / 2 / self.SCALE, HULL_BOTTOM_WIDTH / 2 / self.SCALE])
            for i in [-1, +1]:
                leg = world.CreateDynamicBody(position=(absolute_x, init_y - self.LEG_H / 2 - self.LEG_DOWN), fixtures=LEG_FD)
                leg.color1, leg.color2 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.), (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
                rjd = revoluteJointDef(bodyA=hull, bodyB=leg, anchor=(absolute_x, init_y - self.LEG_DOWN), enableMotor=True, enableLimit=True, maxMotorTorque=self.MOTORS_TORQUE, motorSpeed=i, lowerAngle=-0.8, upperAngle=1.1)
                leg.userData = CustomBodyUserData(False, name="leg")
                self.body_parts.append(leg)
                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
                self.motors.append(joint_motor)
                
                lower = world.CreateDynamicBody(position=(absolute_x, init_y - self.LEG_H * 3 / 2 - self.LEG_DOWN), fixtures=LOWER_FD)
                lower.color1, lower.color2 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.), (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
                rjd = revoluteJointDef(bodyA=leg, bodyB=lower, anchor=(absolute_x, init_y - self.LEG_DOWN - self.LEG_H), enableMotor=True, enableLimit=True, maxMotorTorque=self.MOTORS_TORQUE, motorSpeed=1, lowerAngle=-1.6, upperAngle=-0.1)
                lower.userData = CustomBodyUserData(True, name="lower")
                self.body_parts.append(lower)
                joint_motor = world.CreateJoint(rjd)
                joint_motor.userData = CustomMotorUserData(SPEED_KNEE, True, contact_body=lower, angle_correction=1.0)
                self.motors.append(joint_motor)

===== .\TeachMyAgent\environments\envs\bodies\walkers\old\OldClassicBipedalBody.py =====
# Taken from https://github.com/flowersteam/teachDeepRL

from Box2D.b2 import edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener

from TeachMyAgent.environments.envs.bodies.walkers.WalkerAbstractBody import WalkerAbstractBody
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomBodyUserData, CustomMotorUserData

HULL_POLYGONS = [
    [(-30, +9), (+6, +9), (+34, +1),
    (+34, -8), (-30, -8)]
]
HULL_BOTTOM_WIDTH = 64
SPEED_HIP     = 4
SPEED_KNEE    = 6

class OldClassicBipedalBody(WalkerAbstractBody):
    '''
        Bipedal walker implemented in https://gym.openai.com/envs/BipedalWalker-v2/.
    '''
    def __init__(self, scale, nb_steps_under_water=600, reset_on_hull_critical_contact=True):
        '''
            Creates a bipedal walker with a torque of 80.

            Args:
                scale: Scale value used in the environment (to adapt the embodiment to its environment)
                 nb_steps_under_water: How many consecutive steps the embodiment can survive under water
                reset_on_hull_critical_contact: Whether a contact detected with the head should stop the episode
        '''
        super(OldClassicBipedalBody, self).__init__(scale, 80, nb_steps_under_water)
        self.LEG_DOWN = -8 / self.SCALE # 0 = center of hull
        self.LEG_W, self.LEG_H = 8 / self.SCALE, 34 / self.SCALE
        self.TORQUE_PENALTY = 0.00035
        self.reset_on_hull_critical_contact = reset_on_hull_critical_contact

        # Approximative...
        self.AGENT_WIDTH = HULL_BOTTOM_WIDTH / self.SCALE
        self.AGENT_HEIGHT = 17 / self.SCALE + \
                            self.LEG_H * 2 - self.LEG_DOWN + 0.5
        self.AGENT_CENTER_HEIGHT = self.LEG_H * 2 + self.LEG_DOWN + 0.5

        self.old_morphology = True

        self.body_parts = []
        self.nb_motors = 4
        self.motors = []
        self.state_size = self.nb_motors * 2 + 2

    def draw(self, world, init_x, init_y, force_to_center):
        HULL_FIXTURES = [
            fixtureDef(
                shape=polygonShape(vertices=[(x / self.SCALE, y / self.SCALE) for x, y in polygon]),
                density=5.0,
                friction=0.1,
                categoryBits=0x20,
                maskBits=0x000F)  # 0.99 bouncy
            for polygon in HULL_POLYGONS
        ]

        LEG_FD = fixtureDef(
            shape=polygonShape(box=(self.LEG_W / 2, self.LEG_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        LOWER_FD = fixtureDef(
            shape=polygonShape(box=(0.8 * self.LEG_W / 2, self.LEG_H / 2)),
            density=1.0,
            restitution=0.0,
            categoryBits=0x20,
            maskBits=0x000F)

        hull = world.CreateDynamicBody(
            position=(init_x, init_y),
            fixtures=HULL_FIXTURES
        )
        hull.color1 = (0.5, 0.4, 0.9)
        hull.color2 = (0.3, 0.3, 0.5)
        hull.ApplyForceToCenter((force_to_center, 0), True)

        # hull.userData = CustomBodyUserData(True, is_contact_critical=True, name="hull")
        hull.userData = CustomBodyUserData(True, is_contact_critical=self.reset_on_hull_critical_contact, name="hull")
        self.body_parts.append(hull)
        self.reference_head_object = hull

        for i in [-1, +1]:
            leg = world.CreateDynamicBody(
                position=(init_x, init_y - self.LEG_H / 2 - self.LEG_DOWN),
                angle=(i * 0.05),#2¬∞
                fixtures=LEG_FD
            )
            leg.color1 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.)
            leg.color2 = (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
            rjd = revoluteJointDef(
                bodyA=hull,
                bodyB=leg,
                localAnchorA=(0, self.LEG_DOWN),
                localAnchorB=(0, self.LEG_H / 2),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=i,
                lowerAngle=-0.8,
                upperAngle=1.1,
            )

            leg.userData = CustomBodyUserData(False, name="leg")
            self.body_parts.append(leg)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(SPEED_HIP, False)
            self.motors.append(joint_motor)

            lower = world.CreateDynamicBody(
                position=(init_x, init_y - self.LEG_H * 3 / 2 - self.LEG_DOWN),
                angle=(i * 0.05), #2¬∞
                fixtures=LOWER_FD
            )
            lower.color1 = (0.6 - i / 10., 0.3 - i / 10., 0.5 - i / 10.)
            lower.color2 = (0.4 - i / 10., 0.2 - i / 10., 0.3 - i / 10.)
            rjd = revoluteJointDef(
                bodyA=leg,
                bodyB=lower,
                localAnchorA=(0, -self.LEG_H / 2),
                localAnchorB=(0, self.LEG_H / 2),
                enableMotor=True,
                enableLimit=True,
                maxMotorTorque=self.MOTORS_TORQUE,
                motorSpeed=1,
                lowerAngle=-1.6,
                upperAngle=-0.1,
            )

            lower.userData = CustomBodyUserData(True, name="lower")
            self.body_parts.append(lower)

            joint_motor = world.CreateJoint(rjd)
            joint_motor.userData = CustomMotorUserData(
                SPEED_KNEE,
                True,
                contact_body=lower,
                angle_correction=1.0)
            self.motors.append(joint_motor)

===== .\TeachMyAgent\environments\envs\bodies\walkers\old\__init__.py =====


===== .\TeachMyAgent\environments\envs\Box2D_dynamics\climbing_dynamics.py =====
import Box2D
from Box2D.b2 import (edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener)
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomUserDataObjectTypes

class ClimbingDynamics(object):
    def before_step_climbing_dynamics(self, actions, body, world):
        '''
        Check if sensors should grasp or release.
        If releasing and a joint exists, destroy it.
        '''
        for i in range(len(body.sensors)):
            action_to_check = actions[len(actions) - i - 1]
            sensor_to_check = body.sensors[len(body.sensors) - i - 1]

            if action_to_check > 0:
                sensor_to_check.userData.ready_to_attach = True
            else:
                sensor_to_check.userData.ready_to_attach = False
                if sensor_to_check.userData.has_joint:
                    sensor_to_check.userData.has_joint = False
                    joint_to_destroy = next((_joint.joint for _joint in sensor_to_check.joints
                                             if isinstance(_joint.joint, Box2D.b2RevoluteJoint)), None)
                    if joint_to_destroy is not None:
                        world.DestroyJoint(joint_to_destroy)

    def after_step_climbing_dynamics(self, contact_detector, world):
        '''
        Create climbing joints if sensors are still overlapping after Box2D solver execution.
        '''
        for sensor in contact_detector.contact_dictionaries:
            if len(contact_detector.contact_dictionaries[sensor]) > 0 and \
                    sensor.userData.ready_to_attach and not sensor.userData.has_joint:
                other_body = contact_detector.contact_dictionaries[sensor][0]

                # Simple overlap check (fast approximation)
                other_body_shape = other_body.fixtures[0].shape
                x_values = [v[0] for v in other_body_shape.vertices]
                y_values = [v[1] for v in other_body_shape.vertices]
                radius = sensor.fixtures[0].shape.radius + 0.01

                if (sensor.worldCenter[0] + radius > min(x_values) and sensor.worldCenter[0] - radius < max(x_values) and
                    sensor.worldCenter[1] + radius > min(y_values) and sensor.worldCenter[1] - radius < max(y_values)):
                    rjd = revoluteJointDef(
                        bodyA=sensor,
                        bodyB=other_body,
                        anchor=sensor.worldCenter
                    )

                    joint = world.CreateJoint(rjd)
                    joint.bodyA.userData.joint = joint
                    sensor.userData.has_joint = True
                else:
                    contact_detector.contact_dictionaries[sensor].remove(other_body)
                    if len(contact_detector.contact_dictionaries[sensor]) == 0:
                        sensor.userData.has_contact = False


class ClimbingContactDetector(contactListener):
    '''
    Stores contacts between sensors and graspable surfaces.
    '''
    def __init__(self):
        super(ClimbingContactDetector, self).__init__()
        self.contact_dictionaries = {}

    def BeginContact(self, contact):
        bodies = [contact.fixtureA.body, contact.fixtureB.body]
        for idx, body in enumerate(bodies):
            if body.userData.object_type == CustomUserDataObjectTypes.BODY_SENSOR and body.userData.check_contact:
                other_body = bodies[(idx + 1) % 2]
                if other_body.userData.object_type in (
                    CustomUserDataObjectTypes.GRIP_TERRAIN,
                    CustomUserDataObjectTypes.SENSOR_GRIP_TERRAIN,
                ):
                    body.userData.has_contact = True
                    if body in self.contact_dictionaries:
                        self.contact_dictionaries[body].append(other_body)
                    else:
                        self.contact_dictionaries[body] = [other_body]

    def EndContact(self, contact):
        bodies = [contact.fixtureA.body, contact.fixtureB.body]
        for idx, body in enumerate(bodies):
            # Safe attribute checks to prevent access violations
            if (hasattr(body, 'userData') and body.userData is not None and
                hasattr(body.userData, 'object_type') and
                body.userData.object_type == CustomUserDataObjectTypes.BODY_SENSOR and
                body.userData.check_contact and body.userData.has_contact):

                other_body = bodies[(idx + 1) % 2]

                if hasattr(other_body, 'userData') and other_body.userData is not None:
                    if body in self.contact_dictionaries and other_body in self.contact_dictionaries[body]:
                        self.contact_dictionaries[body].remove(other_body)

                    if body in self.contact_dictionaries and len(self.contact_dictionaries[body]) == 0:
                        body.userData.has_contact = False

    def Reset(self):
        self.contact_dictionaries = {}


===== .\TeachMyAgent\environments\envs\Box2D_dynamics\water_dynamics.py =====
import Box2D
from Box2D.b2 import (edgeShape, circleShape, fixtureDef, polygonShape, revoluteJointDef, contactListener)
from copy import copy
from TeachMyAgent.environments.envs.utils.custom_user_data import CustomUserDataObjectTypes
import numpy as np


class WaterDynamics(object):
    '''
    Simplified water physics simulation using buoyancy, drag, lift, and push forces.
    Based on: https://www.iforce2d.net/b2dtut/buoyancy
    '''
    def __init__(self, gravity, drag_mod=0.25, lift_mod=0.25, push_mod=0.05,
                 max_drag=2000, max_lift=500, max_push=20):
        self.gravity = gravity
        self.drag_mod = drag_mod
        self.lift_mod = lift_mod
        self.push_mod = push_mod
        self.max_drag = max_drag
        self.max_lift = max_lift
        self.max_push = max_push

    def compute_centroids(self, vectors):
        '''Compute the centroid and area of a polygon.'''
        count = len(vectors)
        assert count >= 3

        c = Box2D.b2Vec2(0, 0)
        area = 0
        ref_point = Box2D.b2Vec2(0, 0)
        inv3 = 1 / 3

        for i in range(count):
            p1 = ref_point
            p2 = vectors[i]
            p3 = vectors[i + 1] if i + 1 < count else vectors[0]

            e1 = p2 - p1
            e2 = p3 - p1
            d = Box2D.b2Cross(e1, e2)

            triangle_area = 0.5 * d
            area += triangle_area
            c += triangle_area * inv3 * (p1 + p2 + p3)

        if area > Box2D.b2_epsilon:
            c *= 1 / area
        else:
            area = 0

        return c, area

    def inside(self, cp1, cp2, p):
        '''Check if point p is inside an edge defined by cp1, cp2.'''
        return (cp2.x - cp1.x) * (p.y - cp1.y) > (cp2.y - cp1.y) * (p.x - cp1.x)

    def intersection(self, cp1, cp2, s, e):
        '''Find the intersection point of two line segments.'''
        dc = Box2D.b2Vec2(cp1.x - cp2.x, cp1.y - cp2.y)
        dp = Box2D.b2Vec2(s.x - e.x, s.y - e.y)
        n1 = cp1.x * cp2.y - cp1.y * cp2.x
        n2 = s.x * e.y - s.y * e.x
        n3 = 1.0 / (dc.x * dp.y - dc.y * dp.x)
        return Box2D.b2Vec2((n1 * dp.x - n2 * dc.x) * n3,
                            (n1 * dp.y - n2 * dc.y) * n3)

    def find_intersection(self, fixture_A, fixture_B):
        '''Find intersection polygon between two fixtures.'''
        output_vertices = []
        polygon_A = fixture_A.shape
        polygon_B = fixture_B.shape

        for v in polygon_A.vertices:
            output_vertices.append(fixture_A.body.GetWorldPoint(v))

        clip_polygon = [fixture_B.body.GetWorldPoint(v) for v in polygon_B.vertices]

        cp1 = clip_polygon[-1]
        for cp2 in clip_polygon:
            if not output_vertices:
                break

            input_list = copy(output_vertices)
            output_vertices.clear()
            s = input_list[-1]

            for e in input_list:
                if self.inside(cp1, cp2, e):
                    if not self.inside(cp1, cp2, s):
                        output_vertices.append(self.intersection(cp1, cp2, s, e))
                    output_vertices.append(e)
                elif self.inside(cp1, cp2, s):
                    output_vertices.append(self.intersection(cp1, cp2, s, e))
                s = e
            cp1 = cp2
        return len(output_vertices) != 0, output_vertices

    def calculate_forces(self, fixture_pairs):
        '''Apply buoyancy, drag, lift, and push forces for intersecting fixtures.'''
        for pair in fixture_pairs:
            density = pair[0].density
            has_intersection, intersection_points = self.find_intersection(pair[0], pair[1])

            if not has_intersection:
                continue

            centroid, area = self.compute_centroids(intersection_points)

            # Buoyancy
            displaced_mass = density * area
            buoyancy_force = displaced_mass * -self.gravity
            pair[1].body.ApplyForce(force=buoyancy_force, point=centroid, wake=True)

            # Hydrodynamic forces
            for i in range(len(intersection_points)):
                v0 = intersection_points[i]
                v1 = intersection_points[(i + 1) % len(intersection_points)]
                mid_point = 0.5 * (v0 + v1)

                # Drag
                vel_dir = pair[1].body.GetLinearVelocityFromWorldPoint(mid_point) - \
                          pair[0].body.GetLinearVelocityFromWorldPoint(mid_point)
                vel = vel_dir.Normalize()

                edge = v1 - v0
                edge_length = edge.Normalize()
                normal = Box2D.b2Cross(-1, edge)
                drag_dot = Box2D.b2Dot(normal, vel_dir)

                if drag_dot >= 0:  # Backward edge
                    drag_mag = drag_dot * self.drag_mod * edge_length * density * vel * vel
                    drag_mag = min(drag_mag, self.max_drag)
                    drag_force = drag_mag * -vel_dir
                    pair[1].body.ApplyForce(force=drag_force, point=mid_point, wake=True)

                    # Lift
                    lift_dot = Box2D.b2Dot(edge, vel_dir)
                    lift_mag = drag_dot * lift_dot * self.lift_mod * edge_length * density * vel * vel
                    lift_mag = min(lift_mag, self.max_lift)
                    lift_dir = Box2D.b2Cross(1, vel_dir)
                    lift_force = lift_mag * lift_dir
                    pair[1].body.ApplyForce(force=lift_force, point=mid_point, wake=True)

                # Push (torque-based linear force)
                body_to_check = pair[1].body
                joints_to_check = [
                    joint_edge.joint for joint_edge in body_to_check.joints
                    if joint_edge.joint.bodyB == body_to_check
                ]

                for joint in joints_to_check:
                    if joint.lowerLimit < joint.angle < joint.upperLimit:
                        torque = joint.GetMotorTorque(60)
                        moment_of_inertia = body_to_check.inertia
                        angular_velocity = body_to_check.angularVelocity
                        angular_inertia = moment_of_inertia * angular_velocity

                        world_center = body_to_check.worldCenter
                        anchor = joint.anchorB
                        lever_vector = world_center - anchor
                        force_at_center = Box2D.b2Cross(lever_vector, -torque)

                        push_dot = Box2D.b2Dot(normal, force_at_center)
                        if push_dot > 0:
                            vel = torque + angular_inertia
                            push_mag = push_dot * self.push_mod * edge_length * density * vel * vel
                            push_force = np.clip(push_mag * -force_at_center, -self.max_push, self.max_push)
                            body_to_check.ApplyForce(force=push_force, point=anchor, wake=True)


class WaterContactDetector(contactListener):
    '''Tracks fixtures that are in contact with water.'''
    def __init__(self):
        super(WaterContactDetector, self).__init__()
        self.fixture_pairs = []

    def BeginContact(self, contact):
        fA, fB = contact.fixtureA, contact.fixtureB
        if fA.body.userData.object_type == CustomUserDataObjectTypes.WATER and \
           fB.body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT:
            self.fixture_pairs.append((fA, fB))
        elif fB.body.userData.object_type == CustomUserDataObjectTypes.WATER and \
             fA.body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT:
            self.fixture_pairs.append((fB, fA))

    def EndContact(self, contact):
        '''Safely remove fixture pairs when contact ends.'''
        fA, fB = contact.fixtureA, contact.fixtureB

        # Safety checks to prevent access violations on destroyed objects
        if not (hasattr(fA, 'body') and hasattr(fB, 'body') and
                hasattr(fA.body, 'userData') and hasattr(fB.body, 'userData')):
            return

        pair_to_remove = None
        if fA.body.userData.object_type == CustomUserDataObjectTypes.WATER and \
           fB.body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT:
            pair_to_remove = (fA, fB)
        elif fB.body.userData.object_type == CustomUserDataObjectTypes.WATER and \
             fA.body.userData.object_type == CustomUserDataObjectTypes.BODY_OBJECT:
            pair_to_remove = (fB, fA)

        if pair_to_remove and pair_to_remove in self.fixture_pairs:
            self.fixture_pairs.remove(pair_to_remove)

    def Reset(self):
        '''Clear all stored contacts.'''
        self.fixture_pairs = []


===== .\TeachMyAgent\environments\envs\Box2D_dynamics\__init__.py =====


===== .\TeachMyAgent\environments\envs\PCGAgents\CPPN\BaseCPPN.py =====
import tensorflow as tf
import numpy as np

class BaseCPPN():
    '''
        Simple Base CPPN class wich takes an input vector in addition of a vector defining the x position.
    '''
    def __init__(self, x_dim, input_dim, batch_size=1, output_dim=1, weights_path=None):
        '''
            Builds the computational graph.

            Args:
                x_dim: How many times the CPPN should slide on the x axis
                input_dim: Size of the input vector controlling the generated pattern
                batch_size: Size of batch provided
                output_dim: Size of the output vector
                weights_path: Path to load weights. If None, weights are randomly sampled
        '''
        self.batch_size = batch_size
        self.output_dim = output_dim
        self.x_dim = x_dim
        self.input_dim = input_dim

        # builds the generator network
        self.G = self.generator()

        self.init()

        if weights_path is not None:
            saver = tf.train.Saver()
            saver.restore(self.sess, weights_path)

    def init(self):
        '''
            Initialize the tf session.
        '''
        config = tf.ConfigProto()
        config.gpu_options.allow_growth = True
        self.sess = tf.Session(config=config)
        init = tf.global_variables_initializer()
        self.sess.run(init)

    def generator(self):
        '''
            Build the computational graph.
        '''
        tf.reset_default_graph()
        # inputs to cppn
        self.input = tf.placeholder(tf.float32, [self.x_dim, self.input_dim + 1])

        output_weights = tf.Variable(tf.truncated_normal([self.input_dim + 1, self.output_dim]))
        output = tf.matmul(self.input, output_weights)
        result = tf.reshape(output, [self.x_dim])

        return result

    def generate(self, input_vector):
        '''
            Generate an output of size `batch_size*x_dim*output_size` given the input vector
        '''
        x = np.arange(self.x_dim)
        scaled_x = x / (self.x_dim - 1)
        x_vec = scaled_x.reshape((self.x_dim, 1))
        reshaped_input_vector = np.ones((self.x_dim, self.input_dim)) * input_vector
        final_input = np.concatenate((x_vec, reshaped_input_vector), axis=1)
        return self.sess.run(self.G, feed_dict={self.input: final_input})

    def close(self):
        '''
            Close the tf session.
        '''
        self.sess.close()

===== .\TeachMyAgent\environments\envs\PCGAgents\CPPN\cppn_pytorch.py =====
import torch
import torch.nn as nn
import numpy as np
import os


class CPPN_Pytorch(nn.Module):
    """
    PyTorch version of TanHSoftplusMixCPPN.
    - Matches the original TensorFlow model (no bias terms).
    - Supports loading pretrained weights converted from TensorFlow.
    """
    def __init__(self, x_dim: int, input_dim: int, output_dim: int = 2):
        super(CPPN_Pytorch, self).__init__()
        self.x_dim = x_dim
        self.input_dim = input_dim

        # Important: all layers use `bias=False` to match the original model
        self.net = nn.Sequential(
            nn.Linear(input_dim + 1, 64, bias=False),
            nn.Tanh(),
            nn.Linear(64, 64, bias=False),
            nn.Softplus(),
            nn.Linear(64, 64, bias=False),
            nn.Tanh(),
            nn.Linear(64, 64, bias=False),
            nn.Softplus(),
            nn.Linear(64, output_dim, bias=False)
        )
        print("CPPN (PyTorch) initialized ‚Äî no bias parameters.")

    def load_tf_weights(self, weights_path: str) -> None:
        """Load pretrained weights (converted from TensorFlow)."""
        if not os.path.exists(weights_path):
            print(f"Weight file '{weights_path}' not found. Using random initialization.")
            print("Run 'convert_weights.py' to generate the .pt file.")
            return

        state_dict = torch.load(weights_path)
        self.net.load_state_dict(state_dict)
        print("Successfully loaded original TensorFlow weights into CPPN (PyTorch).")

    def generate(self, input_vector: np.ndarray) -> np.ndarray:
        """
        Generate terrain data from an input vector.

        Args:
            input_vector: NumPy array representing the latent input.

        Returns:
            NumPy array of generated terrain values.
        """
        input_vector_t = torch.from_numpy(input_vector).float()

        x = np.arange(self.x_dim)
        scaled_x = x / (self.x_dim - 1)
        x_vec_t = torch.from_numpy(scaled_x).float().reshape((self.x_dim, 1))

        # Repeat input vector across the x-axis and concatenate
        reshaped_input = input_vector_t.repeat(self.x_dim, 1)
        final_input = torch.cat((x_vec_t, reshaped_input), dim=1)

        with torch.no_grad():
            output = self.net(final_input)

        return output.numpy()


===== .\TeachMyAgent\environments\envs\PCGAgents\CPPN\TanHSoftplusMixCPPN.py =====
import tensorflow as tf
from TeachMyAgent.environments.envs.PCGAgents.CPPN.BaseCPPN import BaseCPPN

class TanHSoftplusMixCPPN(BaseCPPN):
    '''
        Feedforward CPPN with 4 layers of 64 units alternating TanH/Softplus activation functions.
    '''
    def generator(self):
        tf.reset_default_graph()
        # inputs to cppn
        self.input = tf.placeholder(tf.float32, [self.x_dim, self.input_dim + 1])

        self.h1_weights = tf.Variable(tf.truncated_normal([self.input_dim + 1, 64], mean=0.0, stddev=2.0))
        h1 = tf.nn.tanh(tf.matmul(self.input, self.h1_weights))

        self.h2_weights = tf.Variable(tf.truncated_normal([64, 64], mean=0.0, stddev=2.0))
        h2 = tf.nn.softplus(tf.matmul(h1, self.h2_weights))

        self.h3_weights = tf.Variable(tf.truncated_normal([64, 64], mean=0.0, stddev=2.0))
        h3 = tf.nn.tanh(tf.matmul(h2, self.h3_weights))

        self.h4_weights = tf.Variable(tf.truncated_normal([64, 64], mean=0.0, stddev=2.0))
        h4 = tf.nn.softplus(tf.matmul(h3, self.h4_weights))

        self.output_weights = tf.Variable(tf.truncated_normal([64, self.output_dim], mean=0.0, stddev=2.0))
        output = tf.matmul(h4, self.output_weights)
        result = tf.reshape(output, [self.x_dim, self.output_dim])

        return result

===== .\TeachMyAgent\environments\envs\utils\custom_user_data.py =====
from enum import Enum


class CustomUserDataObjectTypes(Enum):
    """Enumeration of object types for custom user data."""
    BODY_OBJECT = 0
    WATER = 1
    TERRAIN = 2
    GRIP_TERRAIN = 3       # Graspable terrain
    MOTOR = 4
    BODY_SENSOR = 5
    SENSOR_GRIP_TERRAIN = 6  # Graspable sensor terrain (e.g., creeper)


class CustomUserData:
    """
    Base class for storing custom properties on simulation objects.
    """
    def __init__(self, name: str, object_type: CustomUserDataObjectTypes):
        self.name = name
        self.object_type = object_type


class CustomMotorUserData(CustomUserData):
    """
    User data for joints with `enableMotor=True`.
    Stores motor control parameters and contact linkage info.
    """
    def __init__(self, speed_control: bool, check_contact: bool,
                 angle_correction: float = 0.0, contact_body=None):
        """
        Args:
            speed_control: Whether this motor is controlled by speed.
            check_contact: If True, a `contact_body` must be provided.
                           Used in the observation space to provide contact info
                           for linked objects.
            angle_correction: Correction term for the joint angle (default=0.0).
            contact_body: Body to monitor for contact events.
        """
        super().__init__("motor", CustomUserDataObjectTypes.MOTOR)
        self.speed_control = speed_control
        self.check_contact = check_contact
        self.angle_correction = angle_correction
        self.contact_body = contact_body


class CustomBodyUserData(CustomUserData):
    """
    User data for body parts.
    Defines collision and termination behavior.
    """
    def __init__(self, check_contact: bool, is_contact_critical: bool = False,
                 name: str = "body_part",
                 object_type: CustomUserDataObjectTypes = CustomUserDataObjectTypes.BODY_OBJECT):
        """
        Args:
            check_contact: If False, collisions for this body are ignored.
            is_contact_critical: If True, a collision ends the episode.
            name: Name of the body part.
            object_type: Type of body (default = BODY_OBJECT).
        """
        super().__init__(name, object_type)
        self.check_contact = check_contact
        self.is_contact_critical = is_contact_critical
        self.has_contact = False


class CustomBodySensorUserData(CustomBodyUserData):
    """
    User data for sensors attached to bodies.
    """
    def __init__(self, check_contact: bool, is_contact_critical: bool = False,
                 name: str = "body_sensor"):
        super().__init__(
            check_contact=check_contact,
            is_contact_critical=is_contact_critical,
            name=name,
            object_type=CustomUserDataObjectTypes.BODY_SENSOR
        )
        self.has_joint = False
        self.ready_to_attach = False


===== .\TeachMyAgent\environments\envs\utils\rendering.py =====
import os
import sys
import math
import numpy as np

# --- macOS compatibility fix for pyglet ---
if "Apple" in sys.version:
    if "DYLD_FALLBACK_LIBRARY_PATH" in os.environ:
        os.environ["DYLD_FALLBACK_LIBRARY_PATH"] += ":/usr/lib"

# --- Import pyglet safely ---
try:
    import pyglet
except ImportError:
    raise ImportError("Pyglet is required for rendering. Please install it via `pip install pyglet`.")

try:
    from pyglet.gl import *
except ImportError:
    raise ImportError(
        "Error importing OpenGL from pyglet. "
        "This likely occurred because pyglet installed the wrong architecture binaries."
    )

RAD2DEG = 57.29577951308232


# ============================================================================ #
#                                Utility Functions                             #
# ============================================================================ #

def get_display(spec):
    """
    Converts a display specification (e.g., ':0') into a pyglet Display object.
    Pyglet only supports multiple displays on Linux.

    Args:
        spec (str or None): Display specification string.

    Returns:
        pyglet.canvas.Display or None
    """
    if spec is None:
        return None
    elif isinstance(spec, str):
        return pyglet.canvas.Display(spec)
    else:
        raise ValueError(
            f"Invalid display specification: {spec}. Must be a string like ':0' or None."
        )


# ============================================================================ #
#                                   Viewer                                     #
# ============================================================================ #

class Viewer:
    def __init__(self, width, height, display=None, visible=True):
        display = get_display(display)
        self.width = width
        self.height = height

        self.window = pyglet.window.Window(
            width=width, height=height, display=display, vsync=False, resizable=True, visible=visible
        )
        self.window.on_close = self.window_closed_by_user
        self.window.push_handlers(self)

        self.geoms = []
        self.onetime_geoms = []
        self.transform = Transform()

        glEnable(GL_BLEND)
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)

    def close(self):
        """Safely close the rendering window."""
        if self.window:
            self.window.close()
            self.window = None

    def window_closed_by_user(self):
        """Ensure proper cleanup when the user closes the window."""
        self.close()

    def on_resize(self, width, height):
        """Handle window resizing."""
        self.width = width
        self.height = height

    def set_bounds(self, left, right, bottom, top):
        """Set the visible bounds of the window."""
        assert right > left and top > bottom
        scalex = self.width / (right - left)
        scaley = self.height / (top - bottom)
        self.transform = Transform(
            translation=(-left * scalex, -bottom * scaley),
            scale=(scalex, scaley)
        )

    def add_geom(self, geom):
        """Add a persistent geometry to be rendered each frame."""
        self.geoms.append(geom)

    def add_onetime(self, geom):
        """Add a geometry to be rendered once."""
        self.onetime_geoms.append(geom)

    def render(self, return_rgb_array=False):
        """
        Render the current scene.
        Returns the RGB image array if `return_rgb_array=True`.
        """

        # --- Safety Check 1: Handle rendering after window close ---
        if self.window is None or self.window.has_exit:
            if return_rgb_array:
                return np.zeros((self.height, self.width, 3), dtype=np.uint8)
            return None

        glClearColor(1, 1, 1, 1)
        self.window.clear()
        self.window.switch_to()
        self.window.dispatch_events()  # Process on_close event if triggered

        # --- Safety Check 2: Recheck window status after event dispatch ---
        if self.window is None or self.window.has_exit:
            if return_rgb_array:
                return np.zeros((self.height, self.width, 3), dtype=np.uint8)
            return None

        glViewport(0, 0, self.width, self.height)
        self.transform.enable()

        for geom in self.geoms:
            geom.render()
        for geom in self.onetime_geoms:
            geom.render()

        self.transform.disable()

        arr = None
        if return_rgb_array:
            buffer = pyglet.image.get_buffer_manager().get_color_buffer()
            image_data = buffer.get_image_data()
            arr = np.frombuffer(image_data.get_data(), dtype=np.uint8)
            arr = arr.reshape(buffer.height, buffer.width, 4)
            arr = arr[::-1, :, 0:3]

        self.window.flip()
        self.onetime_geoms = []
        return arr

    # --- Drawing Utilities ---

    def draw_circle(self, radius=10, res=30, filled=True, **attrs):
        geom = make_circle(radius=radius, res=res, filled=filled)
        _add_attrs(geom, attrs)
        self.add_onetime(geom)
        return geom

    def draw_polygon(self, v, filled=True, **attrs):
        geom = make_polygon(v, filled=filled)
        _add_attrs(geom, attrs)
        self.add_onetime(geom)
        return geom

    def draw_polyline(self, v, **attrs):
        geom = make_polyline(v)
        _add_attrs(geom, attrs)
        self.add_onetime(geom)
        return geom

    def draw_line(self, start, end, **attrs):
        geom = Line(start, end)
        _add_attrs(geom, attrs)
        self.add_onetime(geom)
        return geom

    def get_mouse_coords(self):
        return (self.mouse_x, self.mouse_y)


# ============================================================================ #
#                            Geometry and Attributes                           #
# ============================================================================ #

class Geom:
    """Base geometry class."""
    def __init__(self):
        self._color = Color((0, 0, 0, 1.0))
        self.attrs = [self._color]

    def render(self):
        for attr in reversed(self.attrs):
            attr.enable()
        self.render1()
        for attr in self.attrs:
            attr.disable()

    def render1(self):
        raise NotImplementedError

    def add_attr(self, attr):
        self.attrs.append(attr)

    def set_color(self, r, g, b):
        self._color.vec4 = (r, g, b, 1)


class Attr:
    """Base attribute class."""
    def enable(self):
        raise NotImplementedError

    def disable(self):
        pass


class Transform(Attr):
    """Represents translation, rotation, and scaling transformations."""
    def __init__(self, translation=(0.0, 0.0), rotation=0.0, scale=(1.0, 1.0)):
        self.set_translation(*translation)
        self.set_rotation(rotation)
        self.set_scale(*scale)

    def enable(self):
        glPushMatrix()
        glTranslatef(self.translation.x, self.translation.y, 0)
        glRotatef(RAD2DEG * self.rotation, 0, 0, 1.0)
        glScalef(self.scale.x, self.scale.y, 1.0)

    def disable(self):
        glPopMatrix()

    def set_translation(self, newx, newy):
        self.translation = Vec2(newx, newy)

    def set_rotation(self, newa):
        self.rotation = newa

    def set_scale(self, newx, newy):
        self.scale = Vec2(newx, newy)


class Color(Attr):
    def __init__(self, vec4):
        self.vec4 = vec4

    def enable(self):
        glColor4f(*self.vec4)


class LineWidth(Attr):
    def __init__(self, stroke):
        self.stroke = stroke

    def enable(self):
        glLineWidth(self.stroke)


# ============================================================================ #
#                                 Primitives                                   #
# ============================================================================ #

class Point(Geom):
    def render1(self):
        glBegin(GL_POINTS)
        glVertex3f(0.0, 0.0, 0.0)
        glEnd()


class FilledPolygon(Geom):
    def __init__(self, v):
        super().__init__()
        self.v = v

    def render1(self):
        if len(self.v) == 4:
            glBegin(GL_QUADS)
        elif len(self.v) > 4:
            glBegin(GL_POLYGON)
        else:
            glBegin(GL_TRIANGLES)
        for p in self.v:
            glVertex3f(p[0], p[1], 0)
        glEnd()


class PolyLine(Geom):
    def __init__(self, v, close):
        super().__init__()
        self.v = v
        self.close = close

    def render1(self):
        glBegin(GL_LINE_LOOP if self.close else GL_LINE_STRIP)
        for p in self.v:
            glVertex3f(p[0], p[1], 0)
        glEnd()


class Line(Geom):
    def __init__(self, start=(0.0, 0.0), end=(0.0, 0.0)):
        super().__init__()
        self.start = start
        self.end = end

    def render1(self):
        glBegin(GL_LINES)
        glVertex2f(*self.start)
        glVertex2f(*self.end)
        glEnd()


class Image(Geom):
    def __init__(self, fname, width, height):
        super().__init__()
        self.set_color(1.0, 1.0, 1.0)
        self.img = pyglet.image.load(fname)
        self.width = width
        self.height = height

    def render1(self):
        self.img.blit(-self.width / 2, -self.height / 2, width=self.width, height=self.height)


# ============================================================================ #
#                           Helper Functions                                   #
# ============================================================================ #

def make_circle(radius=10, res=30, filled=True):
    points = [(math.cos(2 * math.pi * i / res) * radius,
               math.sin(2 * math.pi * i / res) * radius) for i in range(res)]
    return FilledPolygon(points) if filled else PolyLine(points, True)


def make_polygon(v, filled=True):
    return FilledPolygon(v) if filled else PolyLine(v, True)


def make_polyline(v):
    return PolyLine(v, False)


def _add_attrs(geom, attrs):
    if "color" in attrs:
        geom.set_color(*attrs["color"])
    if "linewidth" in attrs:
        geom.add_attr(LineWidth(attrs["linewidth"]))


# ============================================================================ #
#                             Simple Image Viewer                              #
# ============================================================================ #

class SimpleImageViewer:
    def __init__(self, display=None, maxwidth=500):
        self.window = None
        self.isopen = False
        self.display = display
        self.maxwidth = maxwidth

    def imshow(self, arr):
        if self.window is None:
            height, width, _ = arr.shape
            if width > self.maxwidth:
                scale = self.maxwidth / width
                width = int(scale * width)
                height = int(scale * height)
            self.window = pyglet.window.Window(
                width=width, height=height, display=self.display, vsync=False, resizable=True
            )
            self.width = width
            self.height = height
            self.isopen = True

            @self.window.event
            def on_resize(width, height):
                self.width = width
                self.height = height

            @self.window.event
            def on_close():
                self.isopen = False

        assert arr.shape[0] == self.height and arr.shape[1] == self.width, \
            f"Image shape {arr.shape} does not match window size {(self.height, self.width)}."

        image = pyglet.image.ImageData(
            self.width, self.height, "RGB", arr.tobytes(), pitch=self.width * -3
        )
        self.window.clear()
        self.window.switch_to()
        self.window.dispatch_events()
        image.blit(0, 0)
        self.window.flip()

    def close(self):
        if self.isopen:
            self.window.close()
            self.isopen = False

    def __del__(self):
        self.close()


# ============================================================================ #
#                                   Vec2                                       #
# ============================================================================ #

class Vec2:
    """Simple 2D vector class."""
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

    def __repr__(self):
        return f"Vec2({self.x:.2f}, {self.y:.2f})"


===== .\TeachMyAgent\environments\envs\utils\__init__.py =====


===== .\utils\env_utils.py =====
# env_utils.py
import gymnasium as gym
import numpy as np
import tkinter as tk
from TeachMyAgent.environments.envs.bodies.BodiesEnum import BodiesEnum
from TeachMyAgent.environments.envs.bodies.BodyTypesEnum import BodyTypesEnum

def get_screen_resolution():
    """Get screen resolution."""
    try:
        root = tk.Tk()
        root.withdraw()
        w, h = root.winfo_screenwidth(), root.winfo_screenheight()
        root.destroy()
        return w, h
    except Exception:
        return 1280, 720

def collect_env_params(env_key, args):
    """Collect environment parameters from command-line args into a dictionary."""
    params = {}
    if env_key == 'stump':
        if hasattr(args, 'roughness') and args.roughness is not None:
            params['roughness'] = args.roughness
        if hasattr(args, 'stump_height') and args.stump_height is not None:
            params['stump_height'] = tuple(args.stump_height)
        if hasattr(args, 'stump_width') and args.stump_width is not None:
            params['stump_width'] = tuple(args.stump_width)
        if hasattr(args, 'obstacle_spacing') and args.obstacle_spacing is not None:
            params['obstacle_spacing'] = args.obstacle_spacing
    
    elif env_key == 'parkour':
        if hasattr(args, 'input_vector') and args.input_vector is not None:
            params['input_vector'] = np.array(args.input_vector)
        if hasattr(args, 'water_level') and args.water_level is not None:
            params['water_level'] = args.water_level
        if hasattr(args, 'creepers_width') and args.creepers_width is not None:
            params['creepers_width'] = args.creepers_width
        if hasattr(args, 'creepers_height') and args.creepers_height is not None:
            params['creepers_height'] = args.creepers_height
        if hasattr(args, 'creepers_spacing') and args.creepers_spacing is not None:
            params['creepers_spacing'] = args.creepers_spacing
    
    return params

def build_and_setup_env(env_key, body_name, user_params, render_mode=None):
    """Create and configure the environment with default and user parameters."""
    
    mapping = {
        'stump': ('parametric-continuous-stump-tracks-v0', 'walker_type'),
        'parkour': ('parametric-continuous-parkour-v0', 'agent_body_type'),
    }
    env_id, param_name = mapping.get(env_key, (None, None))
    if not env_id:
        raise ValueError(f"Invalid environment '{env_key}'.")

    env_kwargs = {param_name: body_name}
    
    if render_mode:
        env_kwargs['render_mode'] = render_mode
        
    if env_key == "parkour":
        body_type = BodiesEnum.get_body_type(body_name)
        lidar_map = {BodyTypesEnum.CLIMBER: 'up', BodyTypesEnum.SWIMMER: 'full'}
        env_kwargs['lidars_type'] = lidar_map.get(body_type, 'down')
        print(f"Automatically set Lidar to '{env_kwargs['lidars_type']}' for body '{body_name}'.")

        if body_type in [BodyTypesEnum.SWIMMER, BodyTypesEnum.AMPHIBIAN]:
            from TeachMyAgent.environments.envs.parametric_continuous_parkour import WATER_DENSITY
            env_kwargs['density'] = WATER_DENSITY
            print(f"Automatically set density for body '{body_name}'.")
    
    env = gym.make(env_id, **env_kwargs)
    
    # --- Apply default and user-defined parameters ---
    if env_key == "stump":
        default_params = {"roughness": 0.0, "stump_height": (0.1, 0.05)}
        default_params.update(user_params)
        env.unwrapped.set_environment(**default_params)
        print("STUMP environment configured with:", default_params)

    elif env_key == "parkour":
        default_params = {
            "input_vector": np.array([-0.25, 0.8, 0.0]),
            "water_level": 0.1,
            "creepers_width": 0.25,
            "creepers_height": 2.0,
            "creepers_spacing": 1.5
        }
        if 'creepers_height' in user_params and user_params['creepers_height'] == 0:
            user_params['creepers_width'] = None

        default_params.update(user_params)
        env.unwrapped.set_environment(**default_params)
        print("PARKOUR environment configured with:", default_params)
        
    return env

def setup_render_window(env, args):
    """Compute and apply render window resolution."""
    if hasattr(env.unwrapped, "_SET_RENDERING_VIEWPORT_SIZE"):
        screen_w, screen_h = get_screen_resolution()
        if args.fullscreen:
            render_width, render_height = screen_w, screen_h
        elif args.width and args.height:
            render_width, render_height = args.width, args.height
        else:
            render_height = int(screen_h * 0.8)
            render_width = int(render_height * 16 / 9)
        
        print(f"Render resolution set to: {render_width}x{render_height}")
        env.unwrapped._SET_RENDERING_VIEWPORT_SIZE(render_width, render_height, keep_ratio=False)


===== .\utils\marl_utils.py =====
import gymnasium as gym
import numpy as np

class SB3MultiAgentWrapper(gym.Wrapper):
    """
    Wrapper that converts an RLlib MultiAgentEnv into a Stable Baselines 3‚Äìcompatible
    environment by flattening observations and actions across all agents.
    """
    def __init__(self, env):
        super().__init__(env)
        # RLlib's MultiAgentEnv doesn‚Äôt follow gym.Wrapper‚Äôs API,
        # so we access the base environment via self.env.
        self.agents = self.env.possible_agents
        
        agent_obs_space = self.env.observation_space[self.agents[0]]
        agent_act_space = self.env.action_space[self.agents[0]]
        
        self.observation_space = gym.spaces.Box(
            low=np.tile(agent_obs_space.low, len(self.agents)),
            high=np.tile(agent_obs_space.high, len(self.agents)),
            dtype=agent_obs_space.dtype
        )

        if isinstance(agent_act_space, gym.spaces.Box):
            self.action_space = gym.spaces.Box(
                low=np.tile(agent_act_space.low, len(self.agents)),
                high=np.tile(agent_act_space.high, len(self.agents)),
                dtype=agent_act_space.dtype
            )
        else:
            raise NotImplementedError("Only Box action spaces are supported in this wrapper.")

    def reset(self, **kwargs):
        obs, info = self.env.reset(**kwargs)
        return self._flatten_obs(obs), info

    def step(self, action):
        split_actions = np.split(action, len(self.agents))
        action_dict = {agent: act for agent, act in zip(self.agents, split_actions)}
        
        obs, reward, terminated, truncated, info = self.env.step(action_dict)
        
        flat_obs = self._flatten_obs(obs)
        total_reward = sum(reward.values()) if isinstance(reward, dict) else reward
        all_done = terminated.get('__all__', False)
        all_trunc = truncated.get('__all__', False)
        
        return flat_obs, total_reward, all_done or all_trunc, info

    def _flatten_obs(self, obs_dict):
        """Flatten agent observations from a dict into a single NumPy array."""
        obs_list = []
        for agent in self.agents:
            if agent in obs_dict:
                obs_list.append(obs_dict[agent])
            else:
                # If an agent is done, its observation may be missing from the dict
                obs_list.append(np.zeros_like(self.env.observation_space[agent].sample()))
        return np.concatenate(obs_list)

    @property
    def unwrapped(self):
        """Return the base environment (for attributes like `viewer`)."""
        return self.env


===== .\utils\shared_args.py =====
# shared_args.py
import argparse

def available_bodies():
    """Return a list of available agent bodies."""
    from TeachMyAgent.environments.envs.bodies.BodiesEnum import BodiesEnum
    return [e.name for e in BodiesEnum]

def add_common_args(parser):
    """Add common arguments for environment and agent."""
    parser.add_argument('--env', type=str, default='parkour',
                        choices=['stump', 'parkour'],
                        help="Select environment.")
    parser.add_argument('--body', type=str, default='classic_bipedal',
                        help=f"Select body. Available: {available_bodies()}")
    return parser

def add_environment_args(parser):
    """Add all environment parameters to the ArgumentParser."""
    # Stump environment parameters
    stump_group = parser.add_argument_group('Stump Environment Parameters')
    stump_group.add_argument('--roughness', type=float, help="Terrain roughness.")
    stump_group.add_argument('--stump_height', type=float, nargs=2, metavar=('MEAN', 'STD'),
                             help="Mean and standard deviation of obstacle height.")
    stump_group.add_argument('--stump_width', type=float, nargs=2, metavar=('MEAN', 'STD'),
                             help="Mean and standard deviation of obstacle width.")
    stump_group.add_argument('--obstacle_spacing', type=float, help="Spacing between obstacles.")

    # Parkour environment parameters
    parkour_group = parser.add_argument_group('Parkour Environment Parameters')
    parkour_group.add_argument('--input_vector', type=float, nargs='+',
                               help="Input vector for CPPN terrain generation.")
    parkour_group.add_argument('--water_level', type=float, help="Water level (0.0‚Äì1.0).")
    parkour_group.add_argument('--creepers_width', type=float, help="Width of climbing objects.")
    parkour_group.add_argument('--creepers_height', type=float,
                               help="Height of climbing objects (0 = none).")
    parkour_group.add_argument('--creepers_spacing', type=float,
                               help="Spacing between climbing objects.")
    
    return parser

def add_render_args(parser):
    """Add rendering/display parameters to the ArgumentParser."""
    render_group = parser.add_argument_group('Rendering Parameters')
    render_group.add_argument('--width', type=int, help="Window width (manual override).")
    render_group.add_argument('--height', type=int, help="Window height (manual override).")
    render_group.add_argument('--fullscreen', action='store_true', help="Enable fullscreen mode.")
    return parser


===== .\utils\__init__.py =====


===== DIRECTORY TREE =====
./
    LICENSE
    README.md
    requirements.txt
    run.py
    configs/
        main_pipeline.yaml
    preprocessing/
        convert_weight.py
        __init__.py
    scripts/
        check_all.py
        demo.py
        record.py
        run_single_test.py
        test_suite.py
        train_acl.py
        train_marl.py
        train_ppo.py
        watch.py
        __init__.py
    TeachMyAgent/
        __init__.py
        environments/
            __init__.py
            envs/
                interactive_multi_agent_parkour.py
                LidarCallback_class.py
                multi_agent_parametric_parkour.py
                parametric_continuous_parkour.py
                parametric_continuous_stump_tracks.py
                __init__.py
                bodies/
                    AbstractBody.py
                    BodiesEnum.py
                    BodyTypesEnum.py
                    __init__.py
                    amphibians/
                        AmphibianAbstractBody.py
                        AmphibiousBipedalBody.py
                        __init__.py
                    climbers/
                        ClimberAbstractBody.py
                        ClimbingChestProfileChimpanzee.py
                        ClimbingProfileChimpanzee.py
                        __init__.py
                    swimmers/
                        FishBody.py
                        SwimmerAbstractBody.py
                        __init__.py
                    walkers/
                        BigQuadruBody.py
                        ClassicBipedalBody.py
                        MillipedeBody.py
                        ProfileChimpanzee.py
                        SmallBipedalBody.py
                        SpiderBody.py
                        WalkerAbstractBody.py
                        WheelBody.py
                        __init__.py
                        old/
                            OldBigQuadruBody.py
                            OldClassicBipedalBody.py
                            __init__.py
                Box2D_dynamics/
                    climbing_dynamics.py
                    water_dynamics.py
                    __init__.py
                PCGAgents/
                    CPPN/
                        BaseCPPN.py
                        cppn_pytorch.py
                        GroundAndCeiling_CPPN_Analysis.ipynb
                        TanHSoftplusMixCPPN.py
                        weights/
                            same_ground_ceiling_cppn_pytorch.pt
                            ground_cppn/
                                .data-00000-of-00001
                                .index
                                .meta
                                checkpoint
                            same_ground_ceiling_cppn/
                                checkpoint
                                model.ckpt.data-00000-of-00001
                                model.ckpt.index
                                model.ckpt.meta
                utils/
                    custom_user_data.py
                    rendering.py
                    __init__.py
    utils/
        env_utils.py
        marl_utils.py
        shared_args.py
        __init__.py
    _utils/
        ok.txt
        ok2.txt
